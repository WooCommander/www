import type { Question } from '../types';

export const questions: Question[] = [
    {
        "id": "100",
        "title": "Как объявить константу и переменную, в чем отличие? Что такое var и почему не используем? Правильное наименование. (переменные и константы).",
        "answer": "Объявление:\nlet count \\= 0;      // переменная\nconst MAX\\_USERS \\= 5; // константа\n\nРазличия let и const\n\n| Критерий | let | const |\n| :---- | :---- | :---- |\n| Переприсваивание | Можно | Нельзя |\n| Блочная область видимости | Да | Да |\n| Hoisting | Есть, но TDZ | Есть, но TDZ |\n| Инициализация | Можно позже | Обязательно сразу |\n\nlet a;\na \\= 10;\nconst b \\= 5;\n// b \\= 6 ❌\n\nЧто такое **var** и почему его не используют?\n\n**var** — устаревший способ объявления переменных в JavaScript (до ES6).\nПочему var не используют\n\n1. Функциональная, а не блочная область видимости\n2. Hoisting с инициализацией undefined\n3. Разрешено повторное объявление\n4. Проблемы в асинхронном коде\n5. Загрязнение глобальной области (window)\n\nconsole.log(x); // undefined\nvar x \\= 10;\nПравильное наименование переменных и констант\n\nПеременные\n\n* camelCase\n* Говорящие имена\n* Глаголы для действий, существительные для данных\n\nlet userName;\nlet isLoading;\nlet totalPrice;\n\nКонстанты\n\n* SCREAMING\\_SNAKE\\_CASE — для глобальных/конфигурационных значений\n* camelCase — для локальных неизменяемых значений\n\n\nconst API\\_URL \\= \"https://api.example.com\";\nconst maxItems \\= 10;\n\nЧего избегать\nlet x;      // ❌ неинформативно\nlet data;   // ❌ слишком общее\nlet temp1;  // ❌\n\n**Идеальная финальная формулировка:**\nВ современном JavaScript переменные объявляются через let, а константы через const. const запрещает переприсваивание, но не делает объекты неизменяемыми. var — устаревший механизм с функциональной областью видимости и hoisting, из\\-за чего может приводить к ошибкам, поэтому в новом коде не используется. Переменные именуются в camelCase, константы — в SCREAMING\\_SNAKE\\_CASE для глобальных значений.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-ob-yavit-konstantu-i-peremennuyu-v-chem-otlichie-chto-takoe-var-i-pochemu-ne-ispol-zuem-pravil-noe-naimenovanie"
    },
    {
        "id": "101",
        "title": "Какие основные типы данны? Что будет при делении на 0? Что будет при \"\"\\\\2 ? Что такое value и reference типы? В чём разница между null и undefined? Какие значения являются falsy? Как узнать тип переменной? (типы данных)",
        "answer": "Какие основные типы данных в JavaScript?\n\n**Примитивные** (value types): number, string, boolean, null, undefined, symbol, bigint.\n**Ссылочные** (reference types): object (включая Object, Array, Function, Date, Map, Set и т.д.)\n**Что будет при делении на 0?**\n\n5 / 0 – Infinity; \\-5 / 0 – \\-Infinity; 0 / 0  –  NaN\nJavaScript **не выбрасывает ошибку**, а возвращает специальные числовые значения.\n**Что будет при \" \" / 2?**\n\n\"\" / 2 – 0\nПустая строка приводится к числу 0\\. Оператор / выполняет **неявное приведение типов**.\n**Value и Reference типы**\n\nValue\n\n* Хранятся и передаются **как копия**\n* Изменение не влияет на оригинал\n\nlet a \\= 5;\nlet b \\= a;\nb \\= 10;\n// a \\=== 5\n\nReference\n\n* Хранятся и передаются **по ссылке**\n* Изменения видны во всех ссылках\n\nconst obj1 \\= { x: 1 };\nconst obj2 \\= obj1;\nobj2.x \\= 2;\n// obj1.x \\=== 2\n\nРазница между null и undefined\n\n| Критерий | null | undefined |\n| ----- | ----- | ----- |\n| Значение | намеренно задано | не инициализировано |\n| Тип | object (баг) | undefined |\n| Использование | задаётся вручную | значение по умолчанию |\n\nlet a;        // undefined\nlet b \\= null; // null\n**Falsy значения**: Значения, приводящиеся к false:false, 0, \\-0, 0n, \"\", null, undefined, NaN\n\n**Как узнать тип переменной?**\n\nОсновной способ: **typeof** value;\nОсобенности typeof\ntypeof null      // \"object\" ❌\ntypeof \\[\\]        // \"object\"\ntypeof function(){} // \"function\"\nКорректные проверки\nArray.isArray(val);    // массив\nval \\=== null;          // null\nNumber.isNaN(val);     // NaN\n\n**Идеальная финальная формулировка**\n\nВ JavaScript есть примитивные типы, которые передаются по значению, и ссылочные типы, которые передаются по ссылке. Деление на ноль не выбрасывает ошибку, а возвращает Infinity или NaN. Язык допускает неявное приведение типов, например пустая строка при делении приводится к нулю. null — это намеренное отсутствие значения, undefined — отсутствие инициализации. Тип значения можно определить через typeof, учитывая его ограничения.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "kakie-osnovnye-tipy-danny-chto-budet-pri-delenii-na-0-chto-budet-pri-2-chto-takoe-value-i-reference-tipy-v-chem-raznitsa-mezhdu-null-i-undefined-kakie-znacheniya-yavlyayutsya-falsy-kak-uznat-tip-peremennoy"
    },
    {
        "id": "102",
        "title": "Что такое явное и неявное преобразование? Особенности преобразование к number и boolean. (преобразование типов)",
        "answer": "Неявное преобразование (Implicit Coercion)\nПроисходит **автоматически движком JavaScript** при выполнении операций, когда типы операндов не совпадают.\n\"2\" \\* 2  // 4; \"5\" \\- 1 // 4; true \\+ 1 // 2\nИспользуется операторами: \\+, \\-, \\*, /, \\==, логическими операциями.\nЯвное преобразование (Explicit Coercion)\nВыполняется **разработчиком намеренно** с помощью встроенных функций.\nNumber(\"5\")   // 5; String(10) // \"10\"; Boolean(1) // true\n\n**Преобразование к number**\n\n**Неявное**: \"10\" \\- 2    // 8; \" \" / 2     // 0; true \\* 2    // 2, false \\+ 1   // 1\n**Явное**: Number(\"10\") – 10; Number(\"abc\") –  NaN; Number(\"\") –  0; Number(null) – 0; Number(undefined) – NaN\n\nВажные нюансы\n\n* NaN — результат неудачного числового преобразования\n* NaN \\!== NaN\n* Проверка: Number.isNaN()\n\n**Преобразование к boolean**\n\nFalsy значения: false, 0, \\-0, 0n, \"\", null, undefined, NaN\nTruthy — всё остальное, включая: \"0\", \"false\", \\[\\], {}\n\n**Идеальная финальная формулировка**\n\nЯвное преобразование выполняется разработчиком с помощью функций Number, String, Boolean. Неявное преобразование происходит автоматически при выполнении операций над значениями разных типов. Наиболее сложные преобразования связаны с приведением к number и boolean, поэтому в продакшн-коде рекомендуется использовать явное приведение и строгие сравнения.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "chto-takoe-yavnoe-i-neyavnoe-preobrazovanie-osobennosti-preobrazovanie-k-number-i-boolean"
    },
    {
        "id": "103",
        "title": "В каком порядке выполняются операторы? Как взять остаток от деления, возвести в степень? (Базовые операторы Таблица приоритетов)",
        "answer": "Операторы выполняются согласно **приоритету операторов** — от более высокого к более низкому.\nПри равном приоритете учитывается **ассоциативность** (слева направо или справа налево).\nКлючевые группы приоритетов (от высокого к низкому)\n\n1. Группировка (...)\n2. Постфиксные  value++; value--\n3. Унарные \\++value; \\--value; \\!value; \\+value; typeof\n4. Возведение в степень \\*\\*   // ассоциативность справа налево\n5. Умножение / деление / остаток \\*  /  %\n6. Сложение / вычитание \\+  \\-\n7. Сравнение \\< \\> \\<= \\>=\n8. Равенство \\== \\!= \\=== \\!==\n9. Логические  &&; ||\n10. Тернарный condition ? a : b\n11. Присваивание  \\= \\+= \\-= \\*= /= \\*\\*=\n\n##\n\nКак взять остаток от деления?\nИспользуется оператор %\n5 % 2 // 1\n10 % 3 // 1\nВажно:\n\n* % — это **остаток**, а не математический модуль\n* С отрицательными числами результат может быть отрицательным\n\nКак возвести в степень?\n**Современный способ**  2 \\*\\* 3 // 8\n**Старый способ** Math.pow(2, 3); // 8\nПримеры приоритета\n2 \\+ 3 \\* 4      // 14\t\t(2 \\+ 3\\) \\* 4    // 20\n2 \\*\\* 3 \\*\\* 2    // 512\t\t// 2 \\*\\* (3 \\*\\* 2\\)\nПрактическое правило\n\n* Всегда используйте **скобки**, если порядок неочевиден\n* Не полагайтесь на знание всей таблицы приоритетов\n\nИдеальная формулировка для собеседования\nОператоры в JavaScript выполняются согласно таблице приоритетов. Сначала выполняются унарные и арифметические операции, затем сравнения, логические операции и присваивание. Остаток от деления вычисляется оператором %, а возведение в степень — оператором \\*\\*, который имеет правую ассоциативность.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "v-kakom-poryadke-vypolnyayutsya-operatory-kak-vzyat-ostatok-ot-deleniya-vozvesti-v-stepen"
    },
    {
        "id": "104",
        "title": "В чём разница между двойным и тройным равно? Каков принцип сравнения строк и разных типов? Сравнение null и undefined с числами. (Операторы сравнения)",
        "answer": "Разница между \\== и \\===\n\n| Оператор | Проверяет | Преобразование типов |\n| ----- | ----- | ----- |\n| \\== | только значение | **неявное приведение типов** (coercion) |\n| \\=== | значение и тип | **строгое сравнение**, без приведения |\n\nПримеры\n5 \\== \"5\"    // true  (строка \\-\\> число)\t\t\t5 \\=== \"5\"   // false (разные типы)\nnull \\== undefined  // true\t\t\t\tnull \\=== undefined // false\n**Принцип сравнения строк**\n\n* Сравниваются **символы по Unicode** (лексикографически)\n* Приведение к числу не выполняется  (\"2\" \\> \"10\" // true, потому что \"2\" \\> \"1\" (первый символ))\n* Если один операнд **не строка**, выполняется приведение к числу (\"5\" \\> 3 // true, \"5\" \\-\\> 5\\)\n\n**Сравнение разных типов**\n\n1. **Булевы значения** → преобразуются к числу (true → 1, false → 0\\)\n2. **Строка и число** → строка преобразуется к числу\n3. **null / undefined** имеют особые правила:\n\n**Сравнение \t\t\tРезультат**\nnull \\== undefined\t\ttrue\nnull \\=== undefined\t\tfalse\nnull \\> 0\t\t\tfalse\nnull \\< 1\t\t\ttrue\nundefined \\> 0\t\t\tfalse\nundefined \\< 1\t\t\tfalse\nundefined \\== 0\t\tfalse\n**Важно:** null и undefined при числовом сравнении ведут себя по-разному.\nКлючевые правила\n\n* Использовать \\=== и \\!== по умолчанию\n* \\== допустимо только при проверке **null/undefined**\n* Всегда учитывать **неявное приведение типов** для чисел и строк\n\n**Идеальная формулировка для собеседования**\n\n\\== проверяет только значение с неявным приведением типов, а \\=== проверяет значение и тип без приведения. При сравнении строк учитывается порядок символов Unicode, а при сравнении разных типов происходит приведение: строки → числа, булевы → числа. null равен только undefined при \\==, но с числами сравнивается особым образом. В продакшн-коде рекомендуется использовать строгое сравнение (===).",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "v-chem-raznitsa-mezhdu-dvoynym-i-troynym-ravno-kakov-printsip-sravneniya-strok-i-raznyh-tipov-sravnenie-null-i-undefined-s-chislami"
    },
    {
        "id": 105,
        "title": "Как обработать несколько случаев одной функцией? Как тернарно можно заменить if else? (Условное ветвление)",
        "answer": "**Как обработать несколько случаев одной функцией?**\n**1\\. Используем if…else if…else**\nfunction checkNumber(num) {\nif (num \\> 0\\) {\nreturn \"Положительное\";\n} else if (num \\< 0\\) {\nreturn \"Отрицательное\";\n} else {\nreturn \"Ноль\";\n}\n}\n\n* Можно обрабатывать **любое количество случаев**\n* Удобно для диапазонов и сложных условий\n\n**2\\. Используем switch**\nfunction getDayName(day) {\nswitch(day) {\ncase 1:\nreturn \"Понедельник\";\ncase 2:\nreturn \"Вторник\";\ncase 3:\nreturn \"Среда\";\ndefault:\nreturn \"Другой день\";\n}\n}\n\n* Чаще используется для **сравнения с конкретными значениями**\n* Блоки case могут объединяться\n* Неявно сравнивает через \\===\n\n**3\\. Объект/Map как словарь**\nconst messages \\= {\n1: \"Понедельник\",\n2: \"Вторник\",\n3: \"Среда\",\n};\n\nfunction getMessage(day) {\nreturn messages\\[day\\] || \"Другой день\";\n}\n\n* Альтернатива множественным if или switch\n* Удобно для статических соответствий\n\n**Как тернарно заменить if…else**\nСинтаксис:\ncondition ? valueIfTrue : valueIfFalse\n**Примеры**\nlet age \\= 18;\nlet status \\= age \\>= 18 ? \"Взрослый\" : \"Несовершеннолетний\";\nМожно вкладывать тернарные операторы:\nlet num \\= 0;\nlet sign \\= num \\> 0 ? \"Положительное\" : num \\< 0 ? \"Отрицательное\" : \"Ноль\";\n\n**Важно:** вложенные тернарные операторы **не должны быть слишком сложными** — читаемость важнее.\n\n**Идеальная формулировка для собеседования**\n\nЧтобы обработать несколько случаев одной функцией, используют if…else if…else, switch или словари (объекты/Map). Для простых условных выражений можно использовать тернарный оператор condition ? valueIfTrue : valueIfFalse, а для нескольких вариантов допускаются вложенные тернарные выражения, хотя для читаемости лучше использовать if или switch.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "kak-obrabotat-neskol-ko-sluchaev-odnoy-funktsiey-kak-ternarno-mozhno-zamenit-if-else"
    },
    {
        "id": 106,
        "title": "Какие логические операторы знаете? Что возвращают? (Логические операторы)",
        "answer": "Какие логические операторы есть в JavaScript?\nОсновные логические операторы:\n\n1. && — логическое И\n2. || — логическое ИЛИ\n3. \\! — логическое НЕ\n4. ?? — nullish coalescing (ES2020)\n\nЧто возвращают логические операторы?\nЛогические операторы в JavaScript **возвращают не true/false, а один из операндов**.\n\nОператор && (И)\n\n* Возвращает **первое falsy значение**\n* Если все значения truthy — возвращает **последнее**\n\ntrue && \"text\"      // \"text\"\t\t0 && \"text\"         // 0\t\t\"a\" && 5 && true    // true\n\nИспользуется для:\n\n* проверки условий\n* условного выполнения кода\n\nisAuth && loadData();\n\nОператор || (ИЛИ)\n\n* Возвращает **первое truthy значение**\n* Если все falsy — возвращает **последнее**\n\nfalse || \"default\"  // \"default\"\t\t\t0 || 10    // 10\n\nИспользуется для:\n\n* задания значений по умолчанию\n\nconst name \\= input || \"Guest\";\n\nОператор \\! (НЕ)\n\n* Приводит значение к boolean и инвертирует его\n\n\\!true       // false\t\t\\!\\!\"text\"    // true\n\n\\!\\! — распространённый способ явного приведения к boolean.\n\nОператор ?? (Nullish coalescing)\n\n* Возвращает **первое значение, которое не null и не undefined**\n* **Не считает 0, \"\", false ошибочными**\n\n0 ?? 10    // 0\t\t\tnull ?? 10   // 10\t\tundefined ?? 5 // 5\nРазница || и ?? (важно)\n\n0 || 10   // 10 ❌\n0 ?? 10   // 0  ✅\n**Идеальная формулировка для собеседования**\n\nВ JavaScript есть логические операторы &&, ||, \\! и ??. Они используют short-circuit и возвращают не логическое значение, а один из операндов. && возвращает первое falsy значение, || — первое truthy, \\! инвертирует boolean, а ?? работает только с null и undefined, что удобно для значений по умолчанию.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-logicheskie-operatory-znaete-chto-vozvraschayut"
    },
    {
        "id": 107,
        "title": "Как работает ?? В чем отличие от ||? (Оператор объединения с null '??')",
        "answer": "Как работает оператор ?? (Nullish Coalescing)?\n?? возвращает **первый операнд, который не равен null и не равен undefined**.\nЕсли левый операнд — null или undefined, возвращается правый.\nconst value \\= a ?? b;\n\n**Примеры**\n\nnull ?? \"default\"        // \"default\"\nundefined ?? 10          // 10\n0 ?? 10                  // 0\n\"\" ?? \"text\"             // \"\"\nfalse ?? true            // false\n\n**Отличие ?? от ||**\n\nКлючевая разница\n\n* || работает с **falsy значениями**\n* ?? работает **только с null и undefined**\n\n**Сравнение**\n0 || 10     // 10  ❌\n0 ?? 10     // 0  ✅\n\n\"\" || \"x\"   // \"x\" ❌\n\"\" ?? \"x\"   // \"\"  ✅\n\nfalse || 1  // 1  ❌\nfalse ?? 1  // false ✅\n\n**Когда использовать ??**\n\n* Когда 0, \"\", false — **валидные значения**\n* Для значений по умолчанию из API, форм, настроек\n\nconst page \\= params.page ?? 1;\n\n**Важные ограничения**\n\n* Нельзя напрямую смешивать ?? с && или || без скобок\n\n// ❌ Ошибка\na ?? b || c\n\n// ✅ Правильно\n(a ?? b) || c\n\n**Идеальная формулировка для собеседования**\n\nОператор ?? возвращает первый операнд, который не является null или undefined. В отличие от ||, он не считает 0, пустую строку или false ошибочными значениями. Это позволяет безопасно задавать значения по умолчанию, не затирая валидные данные.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-rabotaet-v-chem-otlichie-ot"
    },
    {
        "id": 108,
        "title": "Какие вариации цикла while существуют? В чем отличие? (**Циклы while и for**)",
        "answer": "**Какие вариации цикла while существуют?**\nВ JavaScript есть **две формы цикла while**:\n\n1. while\n2. do...while\n\nЦикл while\nСинтаксис\nwhile (condition) {\n// код\n}\n\nКак работает\n\n* Сначала проверяется условие\n* Затем выполняется тело цикла\n* Может не выполниться ни разу\n\nПример\nlet i \\= 0;\nwhile (i \\< 3\\) {\nconsole.log(i);\ni++;\n}\n\nЦикл do...while\nСинтаксис\ndo {\n// код\n} while (condition);\n\nКак работает\n\n* Сначала выполняется тело\n* Затем проверяется условие\n* Выполняется **минимум один раз**\n\nПример\nlet i \\= 0;\ndo {\nconsole.log(i);\ni++;\n} while (i \\< 0);\n\nВ чём отличие while и do...while\n\n| Критерий | while | do...while |\n| :---- | :---- | :---- |\n| Проверка условия | До выполнения | После выполнения |\n| Минимум итераций | 0 | 1 |\n| Использование | когда условие заранее известно | когда тело должно выполниться хотя бы раз |\n\nСравнение с for\n\nЦикл for\nfor (let i \\= 0; i \\< 3; i++) {\nconsole.log(i);\n}\nКогда использовать\n\n* for — когда известны начало, конец и шаг\n* while — когда неизвестно количество итераций\n* do...while — когда требуется минимум одна итерация\n\n**Идеальная формулировка для собеседования**\n\nВ JavaScript есть два варианта цикла while: обычный while, где условие проверяется до выполнения тела, и do...while, который выполняется как минимум один раз. while используют, когда количество итераций заранее неизвестно, а do...while — когда код должен выполниться хотя бы один раз. В отличие от них, for удобен, когда известны начальные и конечные значения.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-variatsii-tsikla-while-suschestvuyut-v-chem-otlichie"
    },
    {
        "id": 109,
        "title": "Что такое break и continue? Что делает break? Почему нужно всегда указывать default? (Конструкция \"switch\")",
        "answer": "**Что такое break и continue?**\n\nbreak\n\n* **Прерывает выполнение цикла или switch полностью**\n* Управление передаётся за пределы конструкции\n\nfor (let i \\= 0; i \\< 5; i++) {\nif (i \\=== 2\\) break;\nconsole.log(i); // 0, 1\n}\n\nИспользуется также в switch.\n\ncontinue\n\n* **Пропускает текущую итерацию цикла**\n* Переходит к следующей итерации\n\nfor (let i \\= 0; i \\< 5; i++) {\nif (i \\=== 2\\) continue;\nconsole.log(i); // 0, 1, 3, 4\n}\n⚠️ В switch **continue не используется**.\n**Что делает break в switch?**\n\n* Завершает выполнение текущего case\n* Предотвращает **fall-through** (проваливание в следующий case)\n\nswitch (value) {\ncase 1:\ndoA();\nbreak;\ncase 2:\ndoB();\nbreak;\n}\nБез break код продолжит выполняться дальше.\n**Почему нужно всегда указывать default в switch?**\n\nПричины\n\n1. **Обработка неожиданных значений**\n2. **Защита от багов**\n3. **Повышение читаемости**\n4. **Логирование ошибок**\n\nswitch (status) {\ncase \"success\":\nhandleSuccess();\nbreak;\ncase \"error\":\nhandleError();\nbreak;\ndefault:\nhandleUnknown();\n}\n\nВажно\n\n* default — аналог else\n* Выполняется, если **ни один case не совпал**\n* Может быть размещён **в любом месте**, но по стандарту — в конце\n\n**Идеальная формулировка для собеседования**\n\nbreak завершает выполнение цикла или конструкции switch, а continue пропускает текущую итерацию цикла. В switch оператор break используется для предотвращения fall-through. Блок default обязателен, так как позволяет обработать неожиданные значения и делает поведение конструкции предсказуемым.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "chto-takoe-break-i-continue-chto-delaet-break-pochemu-nuzhno-vsegda-ukazyvat-default"
    },
    {
        "id": 110,
        "title": "Как работать с функциями? Что такое чистая функция? Отличие function declaration от function expression? Отличие стрелочных функций от function? (Функции, Function expression Стрелочные функции)",
        "answer": "**Как работать с функциями в JavaScript?**\n\nФункции — это **первоклассные объекты**:\n\n* могут быть присвоены переменным\n* переданы как аргументы\n* возвращены из других функций\n\nfunction sum(a, b) {\nreturn a \\+ b;\n}\n\n**Что такое чистая функция?**\n\n**Чистая функция** — функция, которая:\n\n1. **При одинаковых входных данных всегда возвращает одинаковый результат**\n2. **Не имеет побочных эффектов**\n\nПобочные эффекты:\n\n* изменение внешних переменных\n* мутация аргументов\n* работа с DOM\n* HTTP-запросы, console.log\n\n// ❌ не чистая\nlet total \\= 0;\nfunction add(x) {\ntotal \\+= x;\n}\n\n// ✅ чистая\nfunction add(a, b) {\nreturn a \\+ b;\n}\n\n**Function Declaration vs Function Expression**\n\nFunction Declaration\nfunction foo() {\nreturn \"hello\";\n}\n\n* Поднимается целиком (hoisting)\n* Доступна до объявления\n* Имеет имя\n\nFunction Expression\nconst foo \\= function () {\nreturn \"hello\";\n};\n\n* Не поднимается как функция\n* Выполняется только после объявления\n* Может быть анонимной\n\nКлючевое отличие\nFunction Declaration доступна до объявления, Function Expression — нет.\n\n**Стрелочные функции vs обычные функции**\nСинтаксис\nconst sum \\= (a, b) \\=\\> a \\+ b;\nОсновные отличия\n\n| Критерий | Function | Arrow function |\n| ----- | ----- | ----- |\n| this | динамический | **лексический** |\n| arguments | есть | нет |\n| new | можно | нельзя |\n| Hoisting | да (declaration) | нет |\n| super | есть | нет |\n\nПример this\nconst obj \\= {\nvalue: 10,\ngetValue: () \\=\\> this.value\n};\n\nobj.getValue(); // undefined\n\nКогда использовать стрелочные функции\n\n* Колбэки (map, filter, reduce)\n* Когда нужен лексический this\n* Короткие функции без контекста\n\nКогда НЕ использовать стрелочные функции\n\n* Методы объекта\n* Конструкторы\n* Когда нужен собственный this\n\n**Идеальная формулировка для собеседования**\n\nФункции в JavaScript являются объектами первого класса. Чистая функция не имеет побочных эффектов и возвращает одинаковый результат для одинаковых входных данных. Function Declaration поднимается целиком и доступна до объявления, в отличие от Function Expression. Стрелочные функции отличаются лексическим this, отсутствием arguments и невозможностью использования как конструктор.\n\n# Объекты и функции\n\n1. Как добавить свойство в объекте? Как удалить свойство из объекта? Как проверить что свойство существует? Как можно перебирать свойтсва? (Объекты)\n2. Что такое копирование по ссылке? Как сделать полную копию объекта? Какие проблемы есть при копировании по ссылке? Что такое вложенное клонирование? Глобальный метод для клонирования объектов? (Копирование объектов, Глоб.метод для клонирования)\n3. Как добавить метод в свойство объекта? Что такое this и как оно себя ведёт? Чему будет равно this указанное вне функций? Как работает this в стрелочных функциях? (Методы объекта)\n4. Что такое конструктор? Что такое new? Как ведёт себя return в конструкторе?  (Конструктор, new)\n5. Для чего нужен оператор «?» Как работает с функциями и массивами? Какую проблему решает? (Опциональная цепочка)\n6. Зачем нужен? Сравнение символов. Глобальные символы. Получаем символы через Object.keys? Как получить символы объекта? (Symbol  )\n7. Когда используется? Какие варианты преобразований? Какие способы задания преобразующих функций? Какие ограничения по возвращаемым значениям? Какой приоритет выполнения методов преобразований при разных операциях? (Объекты в примитивы)",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "kak-rabotat-s-funktsiyami-chto-takoe-chistaya-funktsiya-otlichie-function-declaration-ot-function-expression-otlichie-strelochnyh-funktsiy-ot-function"
    },
    {
        "id": 111,
        "title": "Как добавить свойство в объекте? Как удалить свойство из объекта? Как проверить что свойство существует? Как можно перебирать свойтсва? (Объекты)",
        "answer": "**Как добавить свойство в объект?**\n\nЧерез точку\nconst user \\= {};\nuser.name \\= \"Anna\";\nИспользуется, когда имя свойства известно заранее.\n\nЧерез квадратные скобки\nuser\\[\"age\"\\] \\= 25;\nuser\\[key\\] \\= \"value\";\nИспользуется для динамических ключей.\n\n**Как удалить свойство из объекта?**\n\ndelete user.age;\n**Удаляет свойство из объекта.**\n⚠️ Важно: delete влияет на производительность, для частых операций лучше использовать иммутабельные подходы.\n**Как проверить, что свойство существует?**\n\n1\\. in   \"name\" in user;\n\nПроверяет наличие свойства **в объекте и прототипе**.\n2\\. hasOwnProperty  user.hasOwnProperty(\"name\");\nПроверяет только **собственные свойства**.\n3\\. Проверка на undefined (не рекомендуется)   user.name \\!== undefined;\nНе отличает отсутствие свойства от значения undefined.\n\n**Как перебирать свойства объекта?**\n\nfor...in\nfor (const key in user) {\nif (user.hasOwnProperty(key)) {\nconsole.log(key, user\\[key\\]);\n}\n}\nПеребирает также свойства прототипа.\n\nObject.keys()\nObject.keys(user); // \\[\"name\", \"age\"\\]\nВозвращает массив ключей.\n\nObject.values()\nObject.values(user); // \\[\"Anna\", 25\\]\n\nObject.entries()\nObject.entries(user); // \\[\\[\"name\", \"Anna\"\\], \\[\"age\", 25\\]\\]\n\nУдобно для map, forEach.\n\n**Идеальная формулировка для собеседования**\n\nСвойства в объект добавляются через точечную нотацию или квадратные скобки. Удаление выполняется оператором delete. Проверить наличие свойства можно через in или hasOwnProperty, в зависимости от необходимости учитывать прототип. Перебирать свойства можно с помощью for...in или методов Object.keys, Object.values и Object.entries.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-dobavit-svoystvo-v-ob-ekte-kak-udalit-svoystvo-iz-ob-ekta-kak-proverit-chto-svoystvo-suschestvuet-kak-mozhno-perebirat-svoytsva"
    },
    {
        "id": 112,
        "title": "Что такое копирование по ссылке? Как сделать полную копию объекта? Какие проблемы есть при копировании по ссылке? Что такое вложенное клонирование? Глобальный метод для клонирования объектов? (Копирование объектов, Глоб.метод для клонирования)",
        "answer": "**Что такое копирование по ссылке?**\n\nКопирование по ссылке означает, что **переменные ссылаются на один и тот же объект в памяти**.\nconst a \\= { x: 1 };\nconst b \\= a;\n\nb.x \\= 2;\na.x; // 2\n\nИзменения через одну ссылку видны через другую.\n\nКакие проблемы есть при копировании по ссылке?\n\n* Неожиданная мутация данных\n* Сложность отладки\n* Побочные эффекты\n* Ошибки в React/Redux (нарушение иммутабельности)\n\n**Как сделать полную копию объекта?**\n\nПоверхностное копирование (shallow copy)\nКопируются только свойства первого уровня.\nconst copy1 \\= { ...obj };\nconst copy2 \\= Object.assign({}, obj);\n\n❌ Вложенные объекты всё ещё копируются по ссылке.\n\n**Что такое вложенное клонирование?**\n\n**Вложенное (глубокое) клонирование** — копирование объекта **со всеми вложенными уровнями**, без общих ссылок.\nСпособы глубокого клонирования\n\n1\\. structuredClone() — глобальный метод (лучший вариант)\nconst clone \\= structuredClone(obj);\n\n✔ Глубокое копирование\n✔ Поддерживает Date, Map, Set\n❌ Не копирует функции, DOM, Symbol\n\n2\\. JSON.parse(JSON.stringify()) (ограниченный способ)\nconst clone \\= JSON.parse(JSON.stringify(obj));\n\n❌ Теряет undefined, функции, Date, Map, Set\n❌ Не работает с циклическими ссылками\n\n3\\. Рекурсивное клонирование\nИспользуется при кастомной логике.\n\n**Глобальный метод для клонирования объектов**\n\n**structuredClone()** — стандартный глобальный метод для глубокого клонирования объектов.\n\n**Идеальная формулировка для собеседования**\n\nКопирование по ссылке означает, что несколько переменных указывают на один объект, из\\-за чего изменения отражаются везде. Поверхностное копирование копирует только верхний уровень, а вложенные объекты остаются по ссылке. Для полного вложенного клонирования используется structuredClone, который выполняет глубокое копирование без общих ссылок.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "chto-takoe-kopirovanie-po-ssylke-kak-sdelat-polnuyu-kopiyu-ob-ekta-kakie-problemy-est-pri-kopirovanii-po-ssylke-chto-takoe-vlozhennoe-klonirovanie-global-nyy-metod-dlya-klonirovaniya-ob-ektov"
    },
    {
        "id": 113,
        "title": "Как добавить метод в свойство объекта? Что такое this и как оно себя ведёт? Чему будет равно this указанное вне функций? Как работает this в стрелочных функциях? (Методы объекта)",
        "answer": "**Как добавить метод в объект?**\n\nМетод — это функция, являющаяся свойством объекта.\nКлассический способ\nconst user \\= {\nname: \"Anna\",\nsayHi: function () {\nreturn \\`Hi, ${this.name}\\`;\n}\n};\nСокращённый синтаксис (ES6)\nconst user \\= {\nname: \"Anna\",\nsayHi() {\nreturn \\`Hi, ${this.name}\\`;\n}\n};\nДинамическое добавление\nuser.logout \\= function () {\nthis.isAuth \\= false;\n};\n\n**Что такое this?**\n\nthis — это **контекст вызова функции**, то есть объект, от имени которого она была вызвана.\nthis определяется **в момент вызова**, а не в момент объявления (кроме стрелочных функций).\n\n**Чему равно this вне функций?**\n\n* **В браузере (не в strict mode)** — window\n* **В strict mode** — undefined\n* **В модулях (type=\"module\")** — undefined\n\nconsole.log(this); // window или undefined\n\n**Как работает this в обычных функциях?**\n\nconst user \\= {\nname: \"Anna\",\nsayHi() {\nconsole.log(this.name);\n}\n};\nuser.sayHi(); // \"Anna\"\n\nЕсли функцию вызвать без объекта:\nconst fn \\= user.sayHi;\nfn(); // undefined (или ошибка в strict mode)\n**Как работает this в стрелочных функциях?**\n\n* **Стрелочные функции не имеют собственного this**\n* Они **берут this из внешнего лексического окружения**\n\nconst user \\= {\nname: \"Anna\",\nsayHi: () \\=\\> {\nconsole.log(this.name);\n}\n};\nuser.sayHi(); // undefined\n\nПравило\n❌ Не использовать стрелочные функции как методы объекта\n✔ Использовать стрелочные функции в колбэках\n\n**Идеальная формулировка для собеседования**\n\nМетод — это функция, являющаяся свойством объекта. this указывает на объект, от имени которого была вызвана функция. Вне функций this ссылается на глобальный объект или undefined в строгом режиме. Стрелочные функции не имеют собственного this и берут его из внешнего контекста, поэтому их не используют как методы объектов.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-dobavit-metod-v-svoystvo-ob-ekta-chto-takoe-this-i-kak-ono-sebya-vedet-chemu-budet-ravno-this-ukazannoe-vne-funktsiy-kak-rabotaet-this-v-strelochnyh-funktsiyah"
    },
    {
        "id": 114,
        "title": "Что такое конструктор? Что такое new? Как ведёт себя return в конструкторе?  (Конструктор, new)",
        "answer": "**Что такое конструктор?**\n\n**Конструктор** — это функция, предназначенная для **создания и инициализации объектов одного типа**.\nПо соглашению:\n\n* имя с **заглавной буквы**\n* вызывается через new\n\nfunction User(name) {\nthis.name \\= name;\n}\n\n**Что такое new и как он работает?**\n\nОператор new выполняет **4 шага**:\n\n1. Создаёт новый пустой объект\n2. Устанавливает прототип:\nobj.\\_\\_proto\\_\\_ \\= Constructor.prototype\n3. Привязывает this к созданному объекту\n4. Возвращает объект (если return не переопределён)\n\nconst user \\= new User(\"Anna\");\n\n**Как ведёт себя return в конструкторе?**\n\n1\\. return с объектом\nЕсли вернуть объект — **он заменит this**:\nfunction User() {\nthis.name \\= \"Anna\";\nreturn { name: \"Kate\" };\n}\nnew User(); // { name: \"Kate\" }\n2\\. return с примитивом\nПримитив **игнорируется**, возвращается this:\nfunction User() {\nthis.name \\= \"Anna\";\nreturn 123;\n}\nnew User(); // { name: \"Anna\" }\n3\\. Без return\nВозвращается созданный объект (this).\n\nВажные ограничения\n\n* Конструктор **нельзя вызывать без new** (в strict mode — ошибка)\n* Стрелочные функции **не могут быть конструкторами**\n* new ломает контекст this при забывчивости\n\n**Идеальная формулировка для собеседования**\n\nКонструктор — это функция, используемая для создания объектов, которая вызывается через new. Оператор new создаёт объект, связывает его с прототипом конструктора, устанавливает this и возвращает объект. Если в конструкторе явно вернуть объект, он заменит this; если вернуть примитив — он будет проигнорирован.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "chto-takoe-konstruktor-chto-takoe-new-kak-vedet-sebya-return-v-konstruktore"
    },
    {
        "id": 115,
        "title": "Для чего нужен оператор «?» Как работает с функциями и массивами? Какую проблему решает? (Опциональная цепочка)",
        "answer": "**Для чего нужен оператор ?.?**\n\nОператор **опциональной цепочки (?.)** используется для **безопасного доступа к свойствам, методам и элементам массивов**, которые могут быть null или undefined.\nОн предотвращает ошибку:\n*Cannot read property of undefined*\n\n**Какую проблему он решает?**\n\nБез ?.:\nuser && user.profile && user.profile.name;\nС ?.:\nuser?.profile?.name;\n\n✔ Код короче\n✔ Читаемее\n✔ Без runtime-ошибок\n\n**Как работает ?.?**\n\n* Если значение **null или undefined**, выражение возвращает undefined\n* Дальнейшее вычисление **останавливается** (short-circuit)\n\nИспользование с объектами\t\t\tuser?.name;\t\tuser?.address?.city;\nИспользование с функциями\t\tuser.sayHi?.();\nФункция вызывается **только если существует**.\nИспользование с массивами \t\tusers?.\\[0\\]?.name;\nБезопасный доступ по индексу.\n\n**Сочетание с ??**\n\nconst name \\= user?.profile?.name ?? \"Guest\";\n\nОграничения\n\n* Работает **только с null и undefined**\n* Не ловит ошибки других типов\n* Нельзя использовать слева от присваивания\n\nuser?.name \\= \"Anna\"; // ❌ ошибка\n\n**Идеальная формулировка для собеседования**\n\nОператор опциональной цепочки ?. позволяет безопасно обращаться к свойствам, методам и элементам массивов, которые могут быть null или undefined. Он предотвращает runtime-ошибки и заменяет цепочки логических проверок, останавливая выполнение при первом null или undefined.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "dlya-chego-nuzhen-operator-kak-rabotaet-s-funktsiyami-i-massivami-kakuyu-problemu-reshaet"
    },
    {
        "id": 116,
        "title": "Зачем нужен? Сравнение символов. Глобальные символы. Получаем символы через Object.keys? Как получить символы объекта? (Symbol  )",
        "answer": "**Зачем нужен Symbol?**\n\nSymbol — это **примитивный уникальный идентификатор**, который используется для:\n\n* создания **уникальных ключей объектов**\n* предотвращения **конфликтов имён свойств**\n* создания **скрытых или приватных свойств**\n\nconst id \\= Symbol(\"id\");\nconst obj \\= {};\nobj\\[id\\] \\= 123;\n\nСравнение символов\n\n* Символы **всегда уникальны**, даже если имеют одинаковое описание:\n\nconst sym1 \\= Symbol(\"key\");\nconst sym2 \\= Symbol(\"key\");\nsym1 \\=== sym2; // false\n\n* Гарантирует уникальность ключей\n\nГлобальные символы\n\n* Создаются через Symbol.for(\"name\")\n* Если символ с таким ключом уже существует — возвращается **тот же символ**, иначе создаётся новый\n\nconst globalSym \\= Symbol.for(\"app.key\");\nconst sameSym \\= Symbol.for(\"app.key\");\nglobalSym \\=== sameSym; // true\n\n* Используются для **глобальных реестров и общих ключей**\n\nКак получить символы объекта?\n\n* **Object.keys(obj)** возвращает только **строковые ключи**, символы не включаются\n* Чтобы получить символы, используем:\n\nObject.getOwnPropertySymbols(obj);\n\n* Для получения **всех свойств** (строки \\+ символы):\n\nReflect.ownKeys(obj);\n\nПример\n\nconst sym \\= Symbol(\"secret\");\nconst obj \\= { name: \"Anna\", \\[sym\\]: 123 };\n\nObject.keys(obj);            // \\[\"name\"\\]\nObject.getOwnPropertySymbols(obj); // \\[Symbol(secret)\\]\nReflect.ownKeys(obj);        // \\[\"name\", Symbol(secret)\\]\n\n**Идеальная формулировка для собеседования**\n\nSymbol — это примитив, создающий уникальные идентификаторы для свойств объектов, предотвращая конфликты имён. Символы всегда уникальны, даже с одинаковым описанием. Для глобальных символов используется Symbol.for, который гарантирует одну и ту же ссылку на символ. Строковые ключи объекта получают через Object.keys, символы — через Object.getOwnPropertySymbols, а все ключи — через Reflect.ownKeys.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "zachem-nuzhen-sravnenie-simvolov-global-nye-simvoly-poluchaem-simvoly-cherez-object-keys-kak-poluchit-simvoly-ob-ekta"
    },
    {
        "id": 117,
        "title": "Когда используется? Какие варианты преобразований? Какие способы задания преобразующих функций? Какие ограничения по возвращаемым значениям? Какой приоритет выполнения методов преобразований при разных операциях? (Объекты в примитивы)",
        "answer": "**Преобразование объектов в примитивы**\n\nВ JavaScript объекты иногда автоматически приводятся к примитивным типам — **числу, строке или булеву значению**, например:\nconst obj \\= { value: 10 };\nconsole.log(obj \\+ 5); // ?\n\nЭто называется **ToPrimitive**.\n\n**Когда используется?**\n\n* Арифметические операции (+, \\-, \\*, /)\n* Конкатенация строк\n* Логические операции, условия (if(obj))\n* Сравнения (==, \\<, \\>)\n\n**Какие варианты преобразований?**\n\n1. **String** — объект преобразуется в строку\n2. **Number** — объект преобразуется в число\n3. **Default** — зависит от операции (+ строка/число)\n\nСпособы задания преобразующих функций\n\n1\\. Метод toString()\n\n* Должен возвращать строку\n\nconst obj \\= {\ntoString() { return \"10\"; }\n};\n\n2\\. Метод valueOf()\n\n* Должен возвращать число или объект\n\nconst obj \\= {\nvalueOf() { return 20; }\n};\n\n3\\. Метод \\[Symbol.toPrimitive\\](hint)\n\n* Универсальный способ\n* hint \\= \"string\" | \"number\" | \"default\"\n\nconst obj \\= {\n\\[Symbol.toPrimitive\\](hint) {\nif (hint \\=== \"number\") return 10;\nif (hint \\=== \"string\") return \"hello\";\nreturn true;\n}\n};\n\nОграничения по возвращаемым значениям\n\n* Должен возвращать **примитив** (string, number, boolean, symbol, null, undefined)\n* Возврат объекта вызовет **TypeError** при преобразовании в примитив\n\nconst obj \\= {\ntoString() { return {}; }\n};\nconsole.log(obj \\+ \"\"); // TypeError\nПриоритет выполнения методов\n\n| Операция | Метод преобразования |\n| ----- | ----- |\n| Арифметика (+, \\-, \\*, /) | valueOf → toString (default \\= number) |\n| Конкатенация (+ со строкой) | toString → valueOf (default \\= string) |\n| Явное приведение (String(obj)) | toString → valueOf |\n| Явное приведение (Number(obj)) | valueOf → toString |\n| \\[Symbol.toPrimitive\\] | Приоритет над toString/valueOf |\n\nПример работы\n\nconst obj \\= {\nvalueOf() { return 10; },\ntoString() { return \"20\"; },\n\\[Symbol.toPrimitive\\](hint) {\nif (hint \\=== \"number\") return 30;\nreturn \"hello\";\n}\n};\n\nconsole.log(+obj);        // 30\nconsole.log(\\`${obj}\\`);    // \"hello\"\nconsole.log(obj \\+ 5);     // \"hello5\" (default → string)\n\n**Идеальная формулировка для собеседования**\n\nОбъекты преобразуются в примитивы автоматически при арифметике, конкатенации, логике и сравнении. Преобразование можно задать через методы toString, valueOf или \\[Symbol.toPrimitive\\](hint). Методы должны возвращать **примитив**. Приоритет: \\[Symbol.toPrimitive\\] \\> valueOf \\> toString, с учётом типа операции (string, number, default). Это позволяет контролировать поведение объекта при автоматическом приведении типов.\n\n# Типы данных\n\n1. Почему у примитивов есть методы? В чём разница между number и new Number? (Методы примитивов)\n2. Какими способами можно записать число? Как можно округлисть число в различные стороны? Какой результат 0.1 \\+ 0.2? Как получить случайное число? Как получить число из строки? Как найти минимальное\\\\максимальное число между числами?(Числа)\n3. В чём разница между различными кавычками и зачем это надо? Какие спец.символы есть? Как получить доступ к символу? Как изменить регистр строки или только первой буквы? Как найти последее и первое вхождение? Методы как вырезать подстроку? Как происходит сравнение строк? Правильное сравнение. Теговые шаблоны. (Строки)\n4. Как объявить массив? Как получить доступ к № элементу? Как добавить и удалить элемент с начала и с конца? Как перебрать все элементы c помощью цикла? (Массивы)\n5. Как объединить два массива? Методы удаления элементов (по признаку, по индексу) и что они возвращают? Как перебрать массив (c возвращением нового массива или undefined)? (Методы массивов)\n6. Как найти элемент массива с начала и с конца и получить к нему доступ по индексу? Какие методы позволяют узнать что в массиве есть элемент и получить его (самого, индекс , или просто boolean о его наличии)? Как отсортировать массив? Как преобразовать массив к строке ? (Методы массивов(basicWeb))\n7. Как получить единое значение на основе всего массива? Как проверить что все или один элемент подходят по условию? Как сделать вложенный массив плоским? (Методы массивов(MDN))\n8. Как работает for of? Как добавить итератор, что должен возвращать? Как создать массив из итератора или псевдомассива? (Итераторы)\n9. Какие ключи могут быть? Как быстро сделать уникальную выборку? (Map и Set)\n10. Как достать все свойства объекта? Как достать все значения объекта? Как достать все свойства со значениями? Все ли свойства будут возвращены таким образом? Метода создания обьекта из массива свойств и значений ? Object в Map , Map в Object (keys, values, entries)\n11. Как с помощью деструктуризации работать с обьектами\\\\массивами ? Операции rest и spread. (Деструктуризация)\n12.  Как получить текущую дату? Как получить завтрашнюю дату? Как узнать какой сейчас день, месяц, год? Как считать дату из форматированной строки? Как получить смещение часового пояса ? (Дата и время)\n13. Как работать с JSON ? В каком случае stringify не работает? Какие типы данных не попадают в JSON? Как переопределить вывод JSON.stringify ? (JSON)",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kogda-ispol-zuetsya-kakie-varianty-preobrazovaniy-kakie-sposoby-zadaniya-preobrazuyuschih-funktsiy-kakie-ogranicheniya-po-vozvraschaemym-znacheniyam-kakoy-prioritet-vypolneniya-metodov-preobrazovaniy-pri-raznyh-operatsiyah"
    },
    {
        "id": 118,
        "title": "Почему у примитивов есть методы? В чём разница между number и new Number? (Методы примитивов)",
        "answer": "**Почему у примитивов есть методы?**\n\n* Примитивы (string, number, boolean, symbol, bigint) **не являются объектами**, но у них есть методы.\n* При обращении к методу JS **временно создаёт объект-обёртку** (wrapper object), вызывает метод и **удаляет объект**.\n\nconst str \\= \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n// Внутренне: new String(str).toUpperCase()\n\n* Это называется **автообёртка примитива** (autoboxing).\n\nРазница между number и new Number\n\nПримитив\nconst a \\= 5;\ntypeof a; // \"number\"\n\n* Лёгкий тип, хранит только значение\n* Методы работают через автообёртку\n* Сравнение с \\=== работает как ожидалось\n\nОбъект Number\nconst b \\= new Number(5);\ntypeof b; // \"object\"\n\n* Содержит **значение внутри объекта**\n* Любые методы работают напрямую\n* **Сравнение строго (===) с примитивом — false**\n\n5 \\=== new Number(5); // false\n\n* Обычно создавать объекты через new Number **не нужно**, используют только примитивы.\n\n**Идеальная формулировка для собеседования**\n\nПримитивы имеют методы благодаря автообёртке: JavaScript временно создаёт объект-обёртку, вызывает метод и удаляет объект. Примитив number — лёгкий тип для хранения значения, тогда как new Number создаёт объект с числовым значением, что влияет на сравнение и производительность. На практике используют примитивы.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "pochemu-u-primitivov-est-metody-v-chem-raznitsa-mezhdu-number-i-new-number"
    },
    {
        "id": 119,
        "title": "Какими способами можно записать число? Как можно округлисть число в различные стороны? Какой результат 0.1 \\+ 0.2? Как получить случайное число? Как получить число из строки? Как найти минимальное\\\\максимальное число между числами?(Числа)",
        "answer": "**1\\. Какими способами можно записать число?**\n\n* **Десятичная система** (обычно)\t\tlet a \\= 42;\n* **Шестнадцатеричная**\t\t\tlet a \\= 0x2A; // 42\n* **Восьмеричная (ES6)**\t\t\tlet a \\= 0o52; // 42\n* **Двоичная (ES6)**\t\t\t\tlet a \\= 0b101010; // 42\n* **Экспоненциальная запись**\t\t\tlet a \\= 1.23e2; // 123\n\n**2\\. Как можно округлить число?**\n\n| Метод | Описание | Пример |\n| ----- | ----- | ----- |\n| Math.floor(x) | округление вниз | Math.floor(4.9) → 4 |\n| Math.ceil(x) | округление вверх | Math.ceil(4.1) → 5 |\n| Math.round(x) | стандартное округление | Math.round(4.5) → 5 |\n| Math.trunc(x) | удаление дробной части | Math.trunc(4.9) → 4 |\n| Number.toFixed(n) | округление до n знаков и преобразование в строку | (4.567).toFixed(2) → \"4.57\" |\n\n**3\\. Результат 0.1 \\+ 0.2**\n\n0.1 \\+ 0.2; // 0.30000000000000004\n\n* Из-за **погрешности представления чисел с плавающей запятой**\n* Решения:\n\nMath.round((0.1 \\+ 0.2) \\* 10\\) / 10; // 0.3\n\n**4\\. Как получить случайное число?**\n\n* Math.random() — число от 0 (включительно) до 1 (не включительно)\n\nMath.random(); // 0 \\<= x \\< 1\n\n* Случайное целое число от min до max:\n\nfunction getRandomInt(min, max) {\nreturn Math.floor(Math.random() \\* (max \\- min \\+ 1)) \\+ min;\n}\n\n**5\\. Как получить число из строки?**\n\n| Способ | Пример |\n| ----- | ----- |\n| Number(\"42\") | 42 |\n| parseInt(\"42px\") | 42 |\n| parseFloat(\"3.14em\") | 3.14 |\n| \\+str | \\+\"42\" → 42 |\n| Math.floor/ceil/round(+\"3.5\") | 3 |\n\n**6\\. Как найти минимальное / максимальное число между числами?**\n\n* Math.min(...values) — минимальное\n\nMath.min(5, 2, 8); // 2\n\n* Math.max(...values) — максимальное\n\nMath.max(5, 2, 8); // 8\n\n* С массивом через spread:\n\nconst arr \\= \\[5,2,8\\];\nMath.min(...arr); // 2\n\n**Идеальная формулировка для собеседования**\n\nВ JavaScript числа можно записывать в десятичной, двоичной, восьмеричной, шестнадцатеричной и экспоненциальной формах. Для округления используют Math.floor, Math.ceil, Math.round, Math.trunc и toFixed. Сложение дробей, как 0.1 \\+ 0.2, может давать погрешность. Случайные числа получают через Math.random. Преобразование строки в число выполняется через Number, parseInt, parseFloat или унарный \\+. Минимальное и максимальное значение среди чисел определяется через Math.min и Math.max.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakimi-sposobami-mozhno-zapisat-chislo-kak-mozhno-okruglist-chislo-v-razlichnye-storony-kakoy-rezul-tat-0-1-0-2-kak-poluchit-sluchaynoe-chislo-kak-poluchit-chislo-iz-stroki-kak-nayti-minimal-noe-maksimal-noe-chislo-mezhdu-chislami"
    },
    {
        "id": 120,
        "title": "В чём разница между различными кавычками и зачем это надо? Какие спец.символы есть? Как получить доступ к символу? Как изменить регистр строки или только первой буквы? Как найти последее и первое вхождение? Методы как вырезать подстроку? Как происходит сравнение строк? Правильное сравнение. Теговые шаблоны. (Строки)",
        "answer": "**1\\. Различные кавычки и зачем они нужны**\n\nВ JS есть три типа кавычек для строк:\n\n| Тип | Пример | Особенности |\n| ----- | ----- | ----- |\n| \"double quotes\" | \"Hello\" | Поддержка обычных строк, можно экранировать ' без проблем |\n| 'single quotes' | 'Hello' | Аналогично двойным кавычкам, удобно для вложенных кавычек |\n| \\`backticks\\` | \\`Hello ${name}\\` | Шаблонные строки: интерполяция ${}, многострочные строки, вложенные выражения |\n\n**2\\. Специальные символы (escape sequences)**\n\n* \\\\n — новая строка\n* \\\\r — возврат каретки\n* \\\\t — табуляция\n* \\\\' — апостроф\n* \\\\\" — двойная кавычка\n* \\\\\\\\ — обратный слеш\n* \\\\uXXXX — Unicode символ\n* \\\\xXX — шестнадцатеричный код символа\n\nconsole.log(\"Line1\\\\nLine2\");\n\n**3\\. Как получить доступ к символу строки**\n\n* Через **индексацию**\n\nconst str \\= \"Hello\";\nconsole.log(str\\[0\\]); // \"H\"\n\n* Через метод charAt()\n\nstr.charAt(0); // \"H\"\n\n**4\\. Как изменить регистр строки**\n\n* **Всё в верхний или нижний регистр**\n\nstr.toUpperCase(); // \"HELLO\"\nstr.toLowerCase(); // \"hello\"\n\n* **Только первая буква**\n\nstr\\[0\\].toUpperCase() \\+ str.slice(1).toLowerCase();\n\n**5\\. Как найти первое и последнее вхождение**\n\n* str.indexOf(\"o\") — первое вхождение\n* str.lastIndexOf(\"l\") — последнее вхождение\n* str.includes(\"el\") — проверка наличия подстроки\n* str.startsWith(\"He\"), str.endsWith(\"lo\") — проверка начала/конца\n\n**6\\. Методы вырезания подстроки**\n\n| Метод | Синтаксис | Особенности |\n| ----- | ----- | ----- |\n| slice(start, end) | str.slice(1,4) | Поддерживает отрицательные индексы |\n| substring(start, end) | str.substring(1,4) | Отрицательные индексы интерпретируются как 0 |\n| substr(start, length) | str.substr(1,3) | Длина вместо конечного индекса (устаревший метод) |\n\n**7\\. Как происходит сравнение строк**\n\n* Строки сравниваются **лексикографически** (по Unicode)\n\n\"a\" \\< \"b\"; // true\n\"apple\" \\< \"banana\"; // true\n\n* Для правильного сравнения с учётом языка:\n\n\"a\".localeCompare(\"b\"); // \\-1\n\n**8\\. Теговые шаблонные строки (Tagged templates)**\n\nПозволяют **обрабатывать шаблонные строки через функцию**.\nfunction tag(strings, ...values) {\nconsole.log(strings); // \\[\"Hello \", \"\\!\"\\]\nconsole.log(values);  // \\[\"World\"\\]\nreturn strings\\[0\\] \\+ values\\[0\\] \\+ strings\\[1\\];\n}\n\nconst result \\= tag\\`Hello ${\"World\"}\\!\\`; // \"Hello World\\!\"\n\n* Используются для:\n* интернационализации\n* безопасного HTML (escape)\n* кастомной обработки строк\n\n**Идеальная формулировка для собеседования**\n\nВ JS строки можно задавать с помощью одинарных, двойных кавычек и шаблонных литералов. Специальные символы позволяют добавлять переносы, табуляции и Unicode-символы. Доступ к символу осуществляется через индекс или charAt(). Изменение регистра — через toUpperCase/toLowerCase, для первой буквы — комбинируем с slice. Поиск подстрок — через indexOf, lastIndexOf, includes, startsWith, endsWith. Вырезать подстроку можно через slice, substring или substr. Строки сравниваются лексикографически, а localeCompare учитывает язык. Теговые шаблоны позволяют кастомно обрабатывать шаблонные строки перед интерполяцией.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "v-chem-raznitsa-mezhdu-razlichnymi-kavychkami-i-zachem-eto-nado-kakie-spets-simvoly-est-kak-poluchit-dostup-k-simvolu-kak-izmenit-registr-stroki-ili-tol-ko-pervoy-bukvy-kak-nayti-posledee-i-pervoe-vhozhdenie-metody-kak-vyrezat-podstroku-kak-proishodit-sravnenie-strok-pravil-noe-sravnenie-tegovye-shablony"
    },
    {
        "id": 121,
        "title": "Как объявить массив? Как получить доступ к № элементу? Как добавить и удалить элемент с начала и с конца? Как перебрать все элементы c помощью цикла? (Массивы)",
        "answer": "**1\\. Как объявить массив**\n\n// Литерал массива\nconst arr1 \\= \\[1, 2, 3\\];\n// Конструктор\nconst arr2 \\= new Array(1, 2, 3);\n// Пустой массив фиксированной длины\nconst arr3 \\= new Array(5); // \\[empty × 5\\]\n\n**2\\. Как получить доступ к элементу по индексу**\n\n* Индексы начинаются с 0\n\nconst arr \\= \\[10, 20, 30\\];\nconsole.log(arr\\[0\\]); // 10\nconsole.log(arr\\[arr.length \\- 1\\]); // 30\n\n**3\\. Как добавить/удалить элемент**\n\nС конца\narr.push(40);    // добавить\narr.pop();       // удалить и вернуть\n\nС начала\narr.unshift(5);  // добавить\narr.shift();     // удалить и вернуть\n\n**4\\. Как перебрать элементы**\n\nЦикл for\nfor (let i \\= 0; i \\< arr.length; i++) {\nconsole.log(arr\\[i\\]);\n}\n\nЦикл for...of\nfor (const value of arr) {\nconsole.log(value);\n}\n\nМетод forEach\narr.forEach((value, index) \\=\\> {\nconsole.log(index, value);\n});\n\n**Идеальная формулировка для собеседования**\n\nМассивы объявляются через литерал \\[\\] или конструктор new Array(). Доступ к элементам осуществляется по индексу, начиная с 0\\. Добавление/удаление элементов производится с помощью push/pop (конец) и unshift/shift (начало). Перебор возможен через обычный цикл for, for...of или метод forEach.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kak-ob-yavit-massiv-kak-poluchit-dostup-k-elementu-kak-dobavit-i-udalit-element-s-nachala-i-s-kontsa-kak-perebrat-vse-elementy-c-pomosch-yu-tsikla"
    },
    {
        "id": 122,
        "title": "Как объединить два массива? Методы удаления элементов (по признаку, по индексу) и что они возвращают? Как перебрать массив (c возвращением нового массива или undefined)? (Методы массивов)",
        "answer": "**1\\. Как объединить два массива**\n\nЧерез concat\nconst arr1 \\= \\[1,2\\];\nconst arr2 \\= \\[3,4\\];\nconst result \\= arr1.concat(arr2); // \\[1,2,3,4\\]\n\nЧерез spread\nconst result \\= \\[...arr1, ...arr2\\]; // \\[1,2,3,4\\]\n\n**2\\. Методы удаления элементов**\n\nС конца\narr.pop(); // удаляет последний элемент, возвращает его\n\nС начала\narr.shift(); // удаляет первый элемент, возвращает его\n\nПо индексу\narr.splice(index, count); // удаляет count элементов, начиная с index, возвращает массив удалённых элементов\n\nПо признаку (условию)\narr \\= arr.filter(el \\=\\> el \\!== value); // возвращает новый массив без элементов, удовлетворяющих условию\n\n**3\\. Перебор массива**\n\nПеребор без возвращения нового массива\n\n* forEach — возвращает undefined\n\narr.forEach(el \\=\\> console.log(el));\n\nПеребор с возвращением нового массива\n\n* map — возвращает массив одинаковой длины с результатами функции\n\nconst newArr \\= arr.map(el \\=\\> el \\* 2);\n\n* filter — возвращает массив только с элементами, прошедшими проверку\n\nconst even \\= arr.filter(el \\=\\> el % 2 \\=== 0);\n\n* reduce — возвращает любое значение, аккумулируя результат\n\nconst sum \\= arr.reduce((acc, el) \\=\\> acc \\+ el, 0);\n\n**Идеальная формулировка для собеседования**\n\nДва массива можно объединить через concat или spread (\\[...\\]). Удаление элементов выполняется методами pop/shift (возвращают удалённый элемент) и splice (возвращает массив удалённых элементов), по условию — через filter (возвращает новый массив). Перебор без возврата нового массива делают через forEach (возвращает undefined), а с созданием нового массива — через map, filter или reduce.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-ob-edinit-dva-massiva-metody-udaleniya-elementov-i-chto-oni-vozvraschayut-kak-perebrat-massiv"
    },
    {
        "id": 123,
        "title": "Как найти элемент массива с начала и с конца и получить к нему доступ по индексу? Какие методы позволяют узнать что в массиве есть элемент и получить его (самого, индекс , или просто boolean о его наличии)? Как отсортировать массив? Как преобразовать массив к строке ? (Методы массивов(basicWeb))",
        "answer": "**1\\. Как найти элемент массива и получить индекс**\n\nС начала\n\n* indexOf(value) — возвращает индекс первого вхождения, или \\-1, если не найдено\n\nconst arr \\= \\[1,2,3,2\\];\narr.indexOf(2); // 1\n\n* findIndex(callback) — возвращает индекс первого элемента, удовлетворяющего условию\n\narr.findIndex(el \\=\\> el \\> 2); // 2\nС конца\n\n* lastIndexOf(value) — индекс последнего вхождения\n\narr.lastIndexOf(2); // 3\n\n**2\\. Методы для проверки наличия элемента и получения его**\n\n| Метод | Что возвращает | Пример |\n| ----- | ----- | ----- |\n| includes(value) | true / false | \\[1,2,3\\].includes(2) → true |\n| find(callback) | элемент или undefined | \\[1,2,3\\].find(el \\=\\> el \\> 2\\) → 3 |\n| findIndex(callback) | индекс или \\-1 | \\[1,2,3\\].findIndex(el \\=\\> el \\> 2\\) → 2 |\n\n**3\\. Как отсортировать массив**\n\nПростая сортировка (строки по умолчанию)\nconst arr \\= \\[3,1,2\\];\narr.sort(); // \\[1,2,3\\] (строковое сравнение)\nС числовым сравнением\narr.sort((a,b) \\=\\> a \\- b); // \\[1,2,3\\]\narr.sort((a,b) \\=\\> b \\- a); // \\[3,2,1\\]\n\n**4\\. Как преобразовать массив в строку**\n\n* toString() — элементы через ,\n\n\\[1,2,3\\].toString(); // \"1,2,3\"\n\n* join(separator) — указать разделитель\n\n\\[1,2,3\\].join(\"-\"); // \"1-2-3\"\n\n**Идеальная формулировка для собеседования**\n\nДля поиска элементов массива с начала используют indexOf или findIndex, с конца — lastIndexOf. Проверку наличия выполняет includes (boolean), а для получения элемента — find (возвращает элемент) или findIndex (индекс). Сортировка выполняется через sort; для чисел необходимо передать callback (a,b)=\\>a-b. Преобразовать массив в строку можно методами toString() (через запятую) или join(separator) для кастомного разделителя.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kak-nayti-element-massiva-s-nachala-i-s-kontsa-i-poluchit-k-nemu-dostup-po-indeksu-kakie-metody-pozvolyayut-uznat-chto-v-massive-est-element-i-poluchit-ego-kak-otsortirovat-massiv-kak-preobrazovat-massiv-k-stroke"
    },
    {
        "id": 124,
        "title": "Как получить единое значение на основе всего массива? Как проверить что все или один элемент подходят по условию? Как сделать вложенный массив плоским? (Методы массивов(MDN))",
        "answer": "**1\\. Получение единого значения из массива**\n\nМетод reduce\n\n* Применяет функцию ко всем элементам массива, аккумулируя результат в одно значение.\n\nconst arr \\= \\[1,2,3,4\\];\nconst sum \\= arr.reduce((acc, el) \\=\\> acc \\+ el, 0); // 10\n\n* Можно использовать для любых операций: сумма, умножение, конкатенация, объект из массива и т.д.\n\nconst arr \\= \\[\"a\",\"b\",\"c\"\\];\nconst str \\= arr.reduce((acc, el) \\=\\> acc \\+ el, \"\"); // \"abc\"\n\n**2\\. Проверка условий для всех или одного элемента**\n\nevery(callback)\n\n* Возвращает true, если **все элементы** удовлетворяют условию\n\n\\[2,4,6\\].every(n \\=\\> n % 2 \\=== 0); // true\n\nsome(callback)\n\n* Возвращает true, если **хотя бы один элемент** удовлетворяет условию\n\n\\[1,2,3\\].some(n \\=\\> n % 2 \\=== 0); // true\n\n**3\\. Превращение вложенного массива в плоский**\n\nМетод flat(depth)\n\n* Делает массив плоским на заданную глубину depth (по умолчанию 1\\)\n\nconst nested \\= \\[1,\\[2,3\\],\\[4,\\[5,6\\]\\]\\];\nnested.flat(); // \\[1,2,3,4,\\[5,6\\]\\]\nnested.flat(2); // \\[1,2,3,4,5,6\\]\n\n* Для **полного выравнивания**:\n\nnested.flat(Infinity);\n\n**Идеальная формулировка для собеседования**\n\nДля получения единого значения из массива используют reduce, который аккумулирует результат через функцию обратного вызова. Для проверки условий применяют every (все элементы соответствуют) и some (хотя бы один элемент соответствует). Вложенные массивы можно сделать плоскими с помощью метода flat(depth), где depth задаёт глубину рекурсии, или Infinity для полного выравнивания.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kak-poluchit-edinoe-znachenie-na-osnove-vsego-massiva-kak-proverit-chto-vse-ili-odin-element-podhodyat-po-usloviyu-kak-sdelat-vlozhennyy-massiv-ploskim"
    },
    {
        "id": 125,
        "title": "Как работает for of? Как добавить итератор, что должен возвращать? Как создать массив из итератора или псевдомассива? (Итераторы)",
        "answer": "**1\\. Как работает for...of**\n\n* Цикл for...of перебирает **итерируемые объекты** (arrays, strings, maps, sets и др.)\n* На каждой итерации возвращает **значение элемента** (не индекс)\n\nconst arr \\= \\[10, 20, 30\\];\nfor (const value of arr) {\nconsole.log(value); // 10, 20, 30\n}\n\n* Отличие от for...in: for...in перебирает **ключи/индексы**, for...of — **значения**\n\n**2\\. Как добавить итератор к объекту**\n\n* Любой объект можно сделать итерируемым, добавив метод \\[Symbol.iterator\\]\n\nconst obj \\= {\ndata: \\[1,2,3\\],\n\\[Symbol.iterator\\]() {\nlet index \\= 0;\nconst data \\= this.data;\nreturn {\nnext() {\nif(index \\< data.length){\nreturn { value: data\\[index++\\], done: false };\n} else {\nreturn { value: undefined, done: true };\n}\n}\n}\n}\n};\n\nfor(const val of obj){\nconsole.log(val); // 1,2,3\n}\nЧто должен возвращать итератор\n\n* Метод next() возвращает объект с двумя свойствами:\n* value — текущее значение\n* done — true, когда элементы закончились\n\n**3\\. Как создать массив из итератора или псевдомассива**\n\n* Через Array.from():\n\nconst arr \\= Array.from(\"hello\"); // \\[\"h\",\"e\",\"l\",\"l\",\"o\"\\]\nconst set \\= new Set(\\[1,2,3\\]);\nconst arr2 \\= Array.from(set); // \\[1,2,3\\]\n\n* Через spread-оператор:\n\nconst arr3 \\= \\[...set\\]; // \\[1,2,3\\]\n\n* Псевдомассивы (например arguments) также можно превратить:\n\nfunction f(){\nconst args \\= Array.from(arguments);\nconsole.log(args);\n}\nf(1,2,3); // \\[1,2,3\\]\n\n**Идеальная формулировка для собеседования**\n\nfor...of используется для перебора итерируемых объектов, возвращая их значения на каждой итерации. Чтобы объект стал итерируемым, нужно реализовать метод \\[Symbol.iterator\\], который возвращает итератор с методом next(), отдающим объект {value, done}. Из итераторов или псевдомассивов можно создать массив через Array.from() или spread-оператор \\[...iterable\\].",
        "category": "Arrays",
        "difficulty": "Medium",
        "slug": "kak-rabotaet-for-of-kak-dobavit-iterator-chto-dolzhen-vozvraschat-kak-sozdat-massiv-iz-iteratora-ili-psevdomassiva"
    },
    {
        "id": 126,
        "title": "Какие ключи могут быть? Как быстро сделать уникальную выборку? (Map и Set)",
        "answer": "**1\\. Map: ключи и значения**\n\n* **Map** — коллекция ключ-значение, где:\n* Ключи могут быть **любого типа**: примитивы, объекты, функции и т.д.\n* Значения могут быть любыми\n\nconst map \\= new Map();\nmap.set(\"key\", 123);\nmap.set(42, \"value\");\nmap.set({}, \"obj\");\nmap.set(()=\\>{}, \"func\");\nconsole.log(map.get(42)); // \"value\"\n\n* Отличие от обычного объекта:\n* Объект хранит только строки или символы как ключи\n* Map сохраняет порядок добавления\n* Map имеет методы size, set, get, has, delete, clear\n\n**2\\. Set: уникальные значения**\n\n* **Set** — коллекция уникальных значений любого типа\n* Быстро обеспечивает **уникальность элементов**\n\nconst set \\= new Set(\\[1,2,2,3,3,3\\]);\nconsole.log(set); // Set {1,2,3}\n\n* Методы:\n* add(value) — добавить\n* has(value) — проверить наличие\n* delete(value) — удалить\n* clear() — очистить\n* size — количество элементов\n\n**3\\. Как быстро сделать уникальную выборку из массива**\n\n* Через Set:\n\nconst arr \\= \\[1,2,2,3,3,3\\];\nconst unique \\= \\[...new Set(arr)\\]; // \\[1,2,3\\]\n\n* Работает для примитивов (числа, строки, символы) и обеспечивает **очень быструю проверку уникальности**\n\n**Идеальная формулировка для собеседования**\n\nВ Map ключи могут быть любого типа — примитивы, объекты, функции. Значения тоже любые. Map сохраняет порядок и имеет удобные методы get, set, has, delete. Для быстрого получения уникальных элементов используют Set, который хранит только уникальные значения. Чтобы сделать массив уникальным, создают new Set(array) и, при необходимости, превращают обратно в массив через spread: \\[...new Set(array)\\].",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-klyuchi-mogut-byt-kak-bystro-sdelat-unikal-nuyu-vyborku"
    },
    {
        "id": 127,
        "title": "Как достать все свойства объекта? Как достать все значения объекта? Как достать все свойства со значениями? Все ли свойства будут возвращены таким образом? Метода создания обьекта из массива свойств и значений ? Object в Map , Map в Object (keys, values, entries)",
        "answer": "**1\\. Как достать все свойства объекта (ключи)**\n\n* **Object.keys(obj)** — возвращает массив **собственных перечисляемых свойств (ключей)**\n\nconst obj \\= {a:1, b:2};\nconsole.log(Object.keys(obj)); // \\[\"a\",\"b\"\\]\n\n* Не возвращает:\n* свойства в цепочке прототипов\n* неперечисляемые свойства\n\n**2\\. Как достать все значения объекта**\n\n* **Object.values(obj)** — возвращает массив значений **только собственных перечисляемых свойств**\n\nconsole.log(Object.values(obj)); // \\[1,2\\]\n\n**3\\. Как достать все свойства со значениями**\n\n* **Object.entries(obj)** — возвращает массив пар \\[ключ, значение\\]\n\nconsole.log(Object.entries(obj)); // \\[\\[\"a\",1\\],\\[\"b\",2\\]\\]\n\n**4\\. Все ли свойства будут возвращены?**\n\n* Нет, возвращаются **только собственные перечисляемые свойства объекта**\n* Свойства из прототипа и неперечисляемые свойства **не попадут**\n\nObject.defineProperty(obj, \"hidden\", {value: 42, enumerable: false});\nObject.keys(obj); // \\[\"a\",\"b\"\\]\n\n**5\\. Методы создания объекта из массива свойств и значений**\n\n* **Object.fromEntries()** — превращает массив пар \\[ключ, значение\\] обратно в объект\n\nconst entries \\= \\[\\[\"a\",1\\],\\[\"b\",2\\]\\];\nconst obj2 \\= Object.fromEntries(entries);\nconsole.log(obj2); // {a:1, b:2}\n\n**6\\. Преобразование между Object и Map**\n\nObject → Map\nconst obj \\= {a:1, b:2};\nconst map \\= new Map(Object.entries(obj));\n\nMap → Object\nconst map \\= new Map(\\[\\[\"a\",1\\],\\[\"b\",2\\]\\]);\nconst obj \\= Object.fromEntries(map);\n\n* Полезно для случаев, когда нужна структура ключ-значение с ключами любого типа (Map), но иногда нужно работать с обычными объектами.\n\n**Идеальная формулировка для собеседования**\n\nВсе собственные перечисляемые свойства объекта можно получить через Object.keys (ключи), Object.values (значения) и Object.entries (пары ключ-значение). Свойства прототипа и неперечисляемые свойства не возвращаются. Создать объект из массива пар \\[ключ,значение\\] позволяет Object.fromEntries(). Для преобразования между объектом и Map используют Object.entries(obj) → new Map() и Object.fromEntries(map) → объект.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-dostat-vse-svoystva-ob-ekta-kak-dostat-vse-znacheniya-ob-ekta-kak-dostat-vse-svoystva-so-znacheniyami-vse-li-svoystva-budut-vozvrascheny-takim-obrazom-metoda-sozdaniya-ob-ekta-iz-massiva-svoystv-i-znacheniy-object-v-map-map-v-object"
    },
    {
        "id": 128,
        "title": "Как с помощью деструктуризации работать с обьектами\\\\массивами ? Операции rest и spread. (Деструктуризация)",
        "answer": "**1\\. Деструктуризация объектов**\n\nПозволяет извлекать свойства объекта в отдельные переменные.\nconst user \\= {name: \"Alice\", age: 25, city: \"Paris\"};\n\n// Простая деструктуризация\nconst {name, age} \\= user;\nconsole.log(name, age); // Alice 25\n\n// Можно задать новые имена переменным\nconst {name: userName, city: userCity} \\= user;\nconsole.log(userName, userCity); // Alice Paris\n\n// Значения по умолчанию\nconst {country \\= \"France\"} \\= user;\nconsole.log(country); // France\n\n// Остаточные свойства (rest)\nconst {name, ...rest} \\= user;\nconsole.log(rest); // {age:25, city:\"Paris\"}\n\n**2\\. Деструктуризация массивов**\n\nИзвлечение элементов массива в переменные по позиции.\nconst arr \\= \\[1,2,3,4\\];\n\n// Простая деструктуризация\nconst \\[a, b\\] \\= arr;\nconsole.log(a,b); // 1 2\n\n// Пропуск элементов\nconst \\[first,,third\\] \\= arr;\nconsole.log(first, third); // 1 3\n\n// Остаточные элементы (rest)\nconst \\[x, ...others\\] \\= arr;\nconsole.log(others); // \\[2,3,4\\]\n\n**3\\. Операции Spread (...)**\n\n* **Для массивов**\n\nconst arr1 \\= \\[1,2\\];\nconst arr2 \\= \\[3,4\\];\nconst merged \\= \\[...arr1, ...arr2\\]; // \\[1,2,3,4\\]\n\n* **Для объектов**\n\nconst obj1 \\= {a:1};\nconst obj2 \\= {b:2};\nconst mergedObj \\= {...obj1, ...obj2}; // {a:1,b:2}\n\n* Используется для **копирования** и объединения без изменения оригинала.\n\n**4\\. Операции Rest (...)**\n\n* Используется **при деструктуризации** для сбора остатка элементов в новый массив или объект\n\nconst \\[first, ...restArr\\] \\= \\[1,2,3,4\\];\nconsole.log(restArr); // \\[2,3,4\\]\n\nconst {a, ...restObj} \\= {a:1, b:2, c:3};\nconsole.log(restObj); // {b:2, c:3}\n\n**Идеальная формулировка для собеседования**\n\nДеструктуризация позволяет извлекать значения из объектов или массивов в отдельные переменные. Для объектов используется синтаксис {prop1, prop2}, для массивов — \\[el1, el2\\]. Операция rest (...rest) собирает оставшиеся элементы/свойства в новый массив или объект. Операция spread (...) используется для копирования и объединения массивов или объектов, позволяя работать с ними иммутабельно.",
        "category": "Arrays",
        "difficulty": "Medium",
        "slug": "kak-s-pomosch-yu-destrukturizatsii-rabotat-s-ob-ektami-massivami-operatsii-rest-i-spread"
    },
    {
        "id": 129,
        "title": "Как получить текущую дату? Как получить завтрашнюю дату? Как узнать какой сейчас день, месяц, год? Как считать дату из форматированной строки? Как получить смещение часового пояса ? (Дата и время)",
        "answer": "**1\\. Как получить текущую дату**\n\n* Через конструктор Date без аргументов\n\nconst now \\= new Date();\nconsole.log(now); // текущая дата и время\n\n* Текущая метка времени в миллисекундах с 1970-01-01\n\nDate.now(); // 1693228800000\n\n**2\\. Как получить завтрашнюю дату**\n\nconst tomorrow \\= new Date();\ntomorrow.setDate(tomorrow.getDate() \\+ 1);\nconsole.log(tomorrow);\n\n* setDate() автоматически учитывает переход на следующий месяц или год.\n\n**3\\. Как узнать день, месяц, год**\n\nconst date \\= new Date();\n\ndate.getDate();    // день месяца (1-31)\ndate.getMonth();   // месяц (0-11, январь \\= 0\\)\ndate.getFullYear(); // год (4 цифры)\ndate.getDay();     // день недели (0-6, воскресенье \\= 0\\)\n\n**4\\. Как считать дату из форматированной строки**\n\nconst d1 \\= new Date(\"2025-12-28\"); // ISO 8601\nconst d2 \\= new Date(\"12/28/2025\"); // локальный формат\n\n* Рекомендуется использовать **ISO формат YYYY-MM-DD**, чтобы избежать различий между браузерами.\n\n**5\\. Как получить смещение часового пояса**\n\n* getTimezoneOffset() возвращает разницу между UTC и локальным временем в **минутах**\n\nconst tzOffset \\= new Date().getTimezoneOffset();\nconsole.log(tzOffset); // например 180 (МСК \\+3:00)\n\n* Положительное значение — западнее UTC, отрицательное — восточнее.\n\n**Идеальная формулировка для собеседования**\n\nТекущую дату и время получают через new Date(), а метку времени — через Date.now(). Чтобы получить завтрашнюю дату, используют setDate(getDate()+1). День, месяц, год и день недели определяются методами getDate(), getMonth(), getFullYear() и getDay(). Дату из строки лучше создавать через ISO формат YYYY-MM-DD. Смещение часового пояса относительно UTC получают через getTimezoneOffset().",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-poluchit-tekuschuyu-datu-kak-poluchit-zavtrashnyuyu-datu-kak-uznat-kakoy-seychas-den-mesyats-god-kak-schitat-datu-iz-formatirovannoy-stroki-kak-poluchit-smeschenie-chasovogo-poyasa"
    },
    {
        "id": 130,
        "title": "Как работать с JSON ? В каком случае stringify не работает? Какие типы данных не попадают в JSON? Как переопределить вывод JSON.stringify ? (JSON)",
        "answer": "**1\\. Как работать с JSON**\n\n* **JSON (JavaScript Object Notation)** — текстовый формат для обмена данными между системами.\n\nПарсинг JSON в объект\nconst jsonString \\= '{\"name\":\"Alice\",\"age\":25}';\nconst obj \\= JSON.parse(jsonString);\nconsole.log(obj.name); // \"Alice\"\n\nПреобразование объекта в JSON\nconst obj \\= {name:\"Alice\", age:25};\nconst jsonString \\= JSON.stringify(obj);\nconsole.log(jsonString); // '{\"name\":\"Alice\",\"age\":25}'\n\n**2\\. В каких случаях JSON.stringify не работает**\n\n* Свойства, значения которых **undefined**, **функции**, или **символы**, **игнорируются**.\n\nJSON.stringify({a: undefined, b: () \\=\\> {}, c: Symbol()}); // \"{}\"\n\n* **Циклические ссылки** в объекте вызовут **ошибку**\n\nconst obj \\= {};\nobj.self \\= obj;\nJSON.stringify(obj); // TypeError: Converting circular structure to JSON\n\n**3\\. Типы данных, не попадающие в JSON**\n\n* undefined\n* function\n* Symbol\n* Символические свойства (Symbol('id'))\n* Циклические структуры без replacer\n\n**4\\. Как переопределить вывод JSON.stringify**\n\nС помощью метода toJSON у объекта\nconst obj \\= {\nname: \"Alice\",\nage: 25,\ntoJSON() {\nreturn {name: this.name}; // вернется только имя\n}\n};\nconsole.log(JSON.stringify(obj)); // '{\"name\":\"Alice\"}'\n\nС помощью replacer-функции\nconst obj \\= {name:\"Alice\", age:25};\nconst json \\= JSON.stringify(obj, (key, value) \\=\\> key \\=== \"age\" ? undefined : value);\nconsole.log(json); // '{\"name\":\"Alice\"}'\n\n**Идеальная формулировка для собеседования**\n\nJSON — это текстовый формат обмена данными. Для преобразования строки в объект используют JSON.parse(), а для объекта в строку — JSON.stringify(). stringify не учитывает свойства с undefined, функциями или символами, и выдаёт ошибку при циклических ссылках. Переопределить вывод можно через метод toJSON() объекта или через функцию replacer в JSON.stringify.\n\n# Продвинутая работа с функциями\n\n1. Максимальная глубина рекурсии. Что такое контекст выполнения функции ? Что такое стек контекстов выполнения ? (Рекурсия и стек)\n2. Сколько аргумемнтов может быть у функции? Как получить все аргументы не зная их названий? Что такое arguments и как работает в стрелочных функциях? Как можно объединить два массива? (Остаточные параметры и оператор расширения)\n3. Что такое замыкание? Что такое IIFE? Что такое лексическое окружение? Что будет если функция не найдет переменную в теле? Что происходит внутри циклов? (Замыкание)\n4. Что лежит внутри? Назовите несколько полезных свойств\\\\методов лежащих в глобальном обьекте (Глобальный объект)\n5. Какие свойства есть у объекта функции? Что такое именнованная функция исполнения NFE ? Для чего нужна? Можно ли задать свои свойства в обьект функции ? (Объект функции)\n6. Для чего нужна такая конструкция? В чём отличие? (New Function)\n7. Как сделать чтобы функция выполнилась только один раз через № времени? Как сделать чтобы выполнялась каждые № времени? Всегда ли функция сработает через № времени? Что происходит когда задаем timeout 0? (SetTimeout, setInterval)\n8. Что такое call и apply? Какую задачу решают? В чём отличие? Что такое декоратор? (Декораторы и переадресация вызова, call/apply)\n9. Что такое контекст? Как и зачем привязывать контекст? Как привязать контекст ко всем функциям объекта? (Привязка контекста к функции)",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "kak-rabotat-s-json-v-kakom-sluchae-stringify-ne-rabotaet-kakie-tipy-dannyh-ne-popadayut-v-json-kak-pereopredelit-vyvod-json-stringify"
    },
    {
        "id": 131,
        "title": "Максимальная глубина рекурсии. Что такое контекст выполнения функции ? Что такое стек контекстов выполнения ? (Рекурсия и стек)",
        "answer": "**1\\. Максимальная глубина рекурсии**\n\n* Это **ограничение на количество вложенных вызовов функции** в JavaScript, которое определяется движком (например, V8, SpiderMonkey).\n* Превышение этой глубины вызывает ошибку **RangeError: Maximum call stack size exceeded**.\n\nfunction f() {\nreturn f();\n}\nf(); // RangeError\n\n* Обычно в современных движках глубина рекурсии порядка **\\~10 000 — 100 000 вызовов**, зависит от памяти и оптимизации.\n\n**2\\. Контекст выполнения функции**\n\n* Контекст выполнения (**Execution Context**) — это **объект, который содержит информацию о том, как выполняется текущая функция**.\n\nСодержит:\n\n1. **Переменные** и константы, объявленные внутри функции\n2. **Аргументы функции**\n3. **Ссылку на внешнее окружение (scope chain)**\n4. **Значение this**\n* Каждый раз, когда вызывается функция, создается новый контекст выполнения.\n\n**3\\. Стек контекстов выполнения**\n\n* **Call stack** — стек, где хранятся контексты выполнения всех активных функций.\n* Механизм работы:\n1. При вызове функции контекст добавляется в **стек** (push)\n2. Функция выполняется\n3. После завершения контекст удаляется из стека (pop)\n\nglobalContext\n└─ functionA()\n└─ functionB()\n\n* Если стек переполнен (слишком много вложенных вызовов, рекурсия), возникает **RangeError**.\n\n**Идеальная формулировка для собеседования**\n\nМаксимальная глубина рекурсии — это ограничение количества вложенных вызовов функций в JavaScript, превышение которого приводит к ошибке RangeError. Контекст выполнения функции (Execution Context) содержит локальные переменные, аргументы, ссылку на внешнее окружение и значение this. Все контексты выполнения хранятся в стеке вызовов (Call Stack): при вызове функции контекст помещается в стек, а после завершения — удаляется.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "maksimal-naya-glubina-rekursii-chto-takoe-kontekst-vypolneniya-funktsii-chto-takoe-stek-kontekstov-vypolneniya"
    },
    {
        "id": 132,
        "title": "Сколько аргумемнтов может быть у функции? Как получить все аргументы не зная их названий? Что такое arguments и как работает в стрелочных функциях? Как можно объединить два массива? (Остаточные параметры и оператор расширения)",
        "answer": "**1\\. Сколько аргументов может быть у функции**\n\n* **Технически** — нет жёсткого ограничения, кроме ограничений памяти и движка.\n* В большинстве движков можно передавать сотни и тысячи аргументов, но обычно используют **небольшое количество для удобства**.\n\n**2\\. Как получить все аргументы, не зная их названий**\n\nЧерез объект arguments\n\n* Доступно в **обычных функциях**, но **не работает в стрелочных**.\n\nfunction f() {\nconsole.log(arguments);\n}\nf(1,2,3); // \\[1,2,3\\] (псевдомассив)\n\n* arguments — это **псевдомассив**, можно использовать индексы и length, но нельзя напрямую применять методы массива (map, filter) без приведения к массиву.\n\nЧерез остаточные параметры (rest)\n\n* Работает в **обычных функциях и стрелочных**.\n\nfunction f(...args) {\nconsole.log(args); // \\[1,2,3\\]\n}\nf(1,2,3);\n\n* ...args собирает все оставшиеся аргументы в **настоящий массив**, можно использовать любые методы массивов.\n\n**3\\. Как работает arguments в стрелочных функциях**\n\n* Стрелочные функции **не имеют собственного arguments**.\n* Они берут arguments из **внешнего (лексического) контекста**.\n\nfunction outer() {\nconst arrow \\= () \\=\\> console.log(arguments);\narrow();\n}\nouter(1,2); // \\[1,2\\]\n\n**4\\. Как объединить два массива**\n\nЧерез spread\nconst arr1 \\= \\[1,2\\];\nconst arr2 \\= \\[3,4\\];\nconst merged \\= \\[...arr1, ...arr2\\]; // \\[1,2,3,4\\]\n\nЧерез concat\n\nconst merged \\= arr1.concat(arr2); // \\[1,2,3,4\\]\n\n**Идеальная формулировка для собеседования**\n\nФункция может принимать произвольное количество аргументов, ограниченное только ресурсами движка. Чтобы получить все аргументы без знания их имён, используют arguments (в обычных функциях) или остаточные параметры ...args (работают и в стрелочных функциях, возвращая настоящий массив). Стрелочные функции не имеют собственного arguments, используют внешнее окружение. Для объединения массивов применяют оператор расширения (\\[...arr1, ...arr2\\]) или метод concat().",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "skol-ko-argumemntov-mozhet-byt-u-funktsii-kak-poluchit-vse-argumenty-ne-znaya-ih-nazvaniy-chto-takoe-arguments-i-kak-rabotaet-v-strelochnyh-funktsiyah-kak-mozhno-ob-edinit-dva-massiva"
    },
    {
        "id": 133,
        "title": "Что такое замыкание? Что такое IIFE? Что такое лексическое окружение? Что будет если функция не найдет переменную в теле? Что происходит внутри циклов? (Замыкание)",
        "answer": "**1\\. Что такое замыкание (Closure)**\n\n* Замыкание — это **функция вместе с окружением**, в котором она была создана.\n* Оно позволяет функции **доступ к переменным внешней функции**, даже после того как внешняя функция завершила выполнение.\n\nfunction outer() {\nconst secret \\= 42;\nreturn function inner() {\nconsole.log(secret);\n};\n}\n\nconst fn \\= outer();\nfn(); // 42\n\n* Применение:\n* Инкапсуляция данных\n* Создание приватных переменных\n* Фабрики функций\n\n**2\\. Что такое IIFE (Immediately Invoked Function Expression)**\n\n* **Функция, которая вызывается сразу после объявления**\n\n(function() {\nconsole.log(\"IIFE выполнено\");\n})();\n\n* Часто используется для:\n* Создания **локального скоупа** и предотвращения загрязнения глобального пространства\n* Инициализации кода\n\n**3\\. Что такое лексическое окружение (Lexical Environment)**\n\n* Лексическое окружение — это **структура, которая хранит привязку идентификаторов к значениям в момент объявления функции или блока**.\n* Включает:\n* Локальные переменные\n* Ссылку на внешнее окружение (parent scope)\n* Именно благодаря лексическому окружению замыкания **“помнят” внешние переменные**.\n\nfunction a() {\nlet x \\= 10;\nreturn function b() {\nconsole.log(x); // доступ к переменной x из лексического окружения функции a\n};\n}\n\n**4\\. Что будет, если функция не найдет переменную в теле**\n\n* JS ищет переменную **по цепочке областей видимости (scope chain)**:\n1. Локальная область функции\n2. Внешние области, по цепочке\n3. Глобальная область\n* Если переменная не найдена, **будет ошибка ReferenceError**.\n\n**5\\. Что происходит внутри циклов и замыканий**\n\n* Если внутри цикла создаются функции с использованием var, они **будут ссылаться на одну переменную**:\n\nfor(var i=0; i\\<3; i++){\nsetTimeout(()=\\>console.log(i), 0);\n}\n// 3,3,3\n\n* Использование let создает **новую переменную для каждой итерации**, замыкание сохраняет правильное значение:\n\nfor(let i=0; i\\<3; i++){\nsetTimeout(()=\\>console.log(i), 0);\n}\n// 0,1,2\n\n**Идеальная формулировка для собеседования**\n\nЗамыкание — это функция вместе с лексическим окружением, которое позволяет ей хранить доступ к внешним переменным даже после завершения внешней функции. IIFE — это немедленно вызываемая функция, используемая для создания локального скоупа. Лексическое окружение хранит идентификаторы и ссылки на внешние области видимости. Если функция не найдет переменную в теле и во внешних областях, будет ReferenceError. В циклах замыкания ведут себя по-разному для var (одна переменная на все итерации) и let (новая переменная для каждой итерации).",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "chto-takoe-zamykanie-chto-takoe-iife-chto-takoe-leksicheskoe-okruzhenie-chto-budet-esli-funktsiya-ne-naydet-peremennuyu-v-tele-chto-proishodit-vnutri-tsiklov"
    },
    {
        "id": 134,
        "title": "Что лежит внутри? Назовите несколько полезных свойств\\\\методов лежащих в глобальном обьекте (Глобальный объект)",
        "answer": "**1\\. Что такое глобальный объект**\n\n* В JavaScript глобальный объект — это **объект, который существует в любой среде выполнения и содержит глобальные переменные, функции и объекты**.\n* В браузере это window, в Node.js — global. В современных стандартах можно использовать globalThis, которое универсально для всех сред.\n\nconsole.log(globalThis); // глобальный объект\n\n* Все глобальные переменные, объявленные через var или function, становятся свойствами глобального объекта.\n\nvar x \\= 10;\nconsole.log(window.x); // 10 (в браузере)\n\n**2\\. Что лежит внутри глобального объекта**\n\n* **Глобальные функции**: setTimeout, setInterval, clearTimeout, parseInt, parseFloat, isNaN\n* **Глобальные объекты**: Math, Date, JSON, Array, Object, Promise\n* **Свойства среды**: navigator, location, document (в браузере)\n* **Конструкторы и классы**: RegExp, Error, Map, Set\n\n**3\\. Полезные методы и свойства глобального объекта**\n\n* globalThis.setTimeout(fn, delay) — вызов функции с задержкой\n* globalThis.clearTimeout(id) — отмена таймера\n* globalThis.parseInt(str, radix) — преобразование строки в целое число\n* globalThis.isNaN(value) — проверка на NaN\n* globalThis.console — вывод в консоль (console.log, console.error)\n* В Node.js:\n* global.process — информация о процессе\n* global.Buffer — работа с бинарными данными\n\n**Идеальная формулировка для собеседования**\n\nГлобальный объект — это объект, который существует в любой среде и содержит глобальные переменные, функции и встроенные объекты. В браузере это window, в Node.js — global, универсально — globalThis. Внутри него лежат глобальные функции (setTimeout, parseInt), встроенные объекты (Math, Date, JSON), конструкторы (Map, Set) и свойства среды (navigator, document). Полезные методы: setTimeout, clearTimeout, parseInt, isNaN, console.log.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "chto-lezhit-vnutri-nazovite-neskol-ko-poleznyh-svoystv-metodov-lezhaschih-v-global-nom-ob-ekte"
    },
    {
        "id": 135,
        "title": "Какие свойства есть у объекта функции? Что такое именнованная функция исполнения NFE ? Для чего нужна? Можно ли задать свои свойства в обьект функции ? (Объект функции)",
        "answer": "**1\\. Свойства объекта функции**\n\n* В JavaScript функции — это **объекты**, поэтому у них есть свойства и методы.\n* Основные стандартные свойства:\n\n| Свойство | Описание |\n| ----- | ----- |\n| name | Имя функции |\n| length | Количество ожидаемых аргументов (параметров) |\n| prototype | Объект прототипа для создания экземпляров (только для обычных функций) |\n| caller | Ссылка на функцию, которая вызвала текущую (не рекомендуется) |\n| arguments | Доступ к аргументам вызывающей функции (устарело) |\n\n* Функции также наследуют методы объекта Function (call, apply, bind).\n\n**2\\. Что такое именованная функция исполнения (NFE — Named Function Expression)**\n\n* **NFE** — это функция, объявленная как выражение с именем:\n\nconst factorial \\= function fact(n) {\nif(n\\<=1) return 1;\nreturn n \\* fact(n-1); // можно использовать имя внутри самой функции\n};\nconsole.log(factorial(5)); // 120\n\n* Особенности:\n* Имя доступно **только внутри функции** (fact)\n* Внешне функция доступна через переменную (factorial)\n* Удобно для рекурсии и отладки (имя отображается в стеке вызовов)\n\n**3\\. Для чего нужна NFE**\n\n* **Рекурсия внутри функции**, когда переменная может быть переопределена снаружи\n* **Отладка** — имя функции видно в стек-трейсе\n* **Изоляция имени** — не засоряет внешнее пространство\n\n**4\\. Можно ли задать свои свойства в объект функции**\n\n* Да, функция — объект, и ей можно добавлять свои свойства:\n\nfunction sayHi() {}\nsayHi.description \\= \"Функция для приветствия\";\nconsole.log(sayHi.description); // \"Функция для приветствия\"\n\n* Применение:\n* Кэширование результатов\n* Хранение настроек\n* Метаданные функции\n\n**Идеальная формулировка для собеседования**\n\nФункция в JavaScript — это объект с собственными свойствами name, length, prototype, а также методами call, apply, bind. Named Function Expression (NFE) — именованное функциональное выражение, имя доступно внутри функции и удобно для рекурсии и отладки. Внешне функция доступна через переменную, а внутри можно использовать имя для вызова самой себя. Функциям можно задавать собственные свойства для хранения метаданных, кэша или конфигураций.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kakie-svoystva-est-u-ob-ekta-funktsii-chto-takoe-imennovannaya-funktsiya-ispolneniya-nfe-dlya-chego-nuzhna-mozhno-li-zadat-svoi-svoystva-v-ob-ekt-funktsii"
    },
    {
        "id": 136,
        "title": "Для чего нужна такая конструкция? В чём отличие? (New Function)",
        "answer": "**1\\. Что такое new Function**\n\n* Конструктор Function позволяет **создавать функции динамически из строки**:\n\nconst sum \\= new Function('a', 'b', 'return a \\+ b');\nconsole.log(sum(2,3)); // 5\n\n* Синтаксис:\n\nnew Function (\\[arg1\\[, arg2\\[, ...argN\\]\\],\\] functionBody)\n\n* Последний аргумент — тело функции в виде строки, предыдущие — имена аргументов.\n\n**2\\. Для чего нужна**\n\n* Динамическое создание функций на основе данных, например:\n* Генерация кода во время выполнения\n* Сценарии с конфигурируемыми функциями\n* Аналог eval, но создаёт **новый контекст выполнения**, без доступа к локальным переменным текущей области.\n\nlet x \\= 10;\nconst f \\= new Function('return typeof x');\nconsole.log(f()); // \"undefined\" — не видит локальные переменные\n\n**3\\. Отличие от обычной функции**\n\n| Особенность | Function Declaration / Expression | new Function |\n| :---- | :---- | :---- |\n| Контекст | Лексическое окружение создается при объявлении | Всегда глобальный контекст, локальные переменные вызывающей функции недоступны |\n| Синтаксис | function foo(a,b){} | new Function('a','b','return a+b') |\n| Использование | Статически | Динамически (строка кода) |\n| Оптимизация | Движки оптимизируют обычные функции | Менее оптимизировано, slower |\n\n* new Function работает аналогично eval, **опасен для безопасности**, если использовать строки из внешних источников.\n\n**Идеальная формулировка для собеседования**\n\nКонструктор new Function создаёт функцию из строки с аргументами и телом функции. Отличие от обычной функции в том, что создаётся **новый глобальный контекст**, локальные переменные вызывающей области недоступны. Применяется для динамического создания функций, но менее безопасен и менее оптимизирован, чем обычные Function Declaration или Expression.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "dlya-chego-nuzhna-takaya-konstruktsiya-v-chem-otlichie"
    },
    {
        "id": 137,
        "title": "Как сделать чтобы функция выполнилась только один раз через № времени? Как сделать чтобы выполнялась каждые № времени? Всегда ли функция сработает через № времени? Что происходит когда задаем timeout 0? (SetTimeout, setInterval)",
        "answer": "**1\\. Выполнить функцию только один раз через заданное время**\n\n* Используется **setTimeout**:\n\nfunction sayHi() {\nconsole.log(\"Привет\\!\");\n}\n\n// Выполнить через 2 секунды\nsetTimeout(sayHi, 2000);\n\n* Аргументы:\n* callback — функция\n* delay — задержка в миллисекундах\n\n**2\\. Выполнять функцию каждые N миллисекунд**\n\n* Используется **setInterval**:\n\nsetInterval(() \\=\\> console.log(\"Привет\\!\"), 1000); // каждые 1 секунду\n\n* Для остановки интервала:\n\nconst id \\= setInterval(() \\=\\> console.log(\"Привет\\!\"), 1000);\nclearInterval(id);\n\n**3\\. Всегда ли функция сработает через N времени?**\n\n* **Нет**, setTimeout и setInterval гарантируют **минимальную задержку**, но:\n* JavaScript работает в **однопоточном Event Loop**\n* Если стек вызовов занят, выполнение задерживается\n* Задержка может быть **дольше**, но не короче указанной\n\nsetTimeout(() \\=\\> console.log(\"Hi\"), 0);\nconsole.log(\"Done\"); // \"Done\" выведется первым\n\n**4\\. Что происходит при setTimeout(fn, 0\\)**\n\n* Функция помещается в **очередь задач (task queue)**, выполнится **после текущего стека вызовов**\n* Используется для **отложенного выполнения**, но не мгновенно\n\nconsole.log(\"Start\");\nsetTimeout(() \\=\\> console.log(\"Timeout 0\"), 0);\nconsole.log(\"End\");\n// Вывод: Start \\-\\> End \\-\\> Timeout 0\n\n**Идеальная формулировка для собеседования**\n\nЧтобы функция выполнилась один раз через N миллисекунд, используют setTimeout(callback, delay). Чтобы выполнялась каждые N миллисекунд — setInterval(callback, interval) с возможностью остановки через clearInterval(id). Функции через таймер **не гарантируют точное время выполнения**, задержка может быть больше указанной из\\-за занятости стека и Event Loop. setTimeout(fn, 0\\) помещает функцию в очередь задач и выполняет её после завершения текущего кода.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "kak-sdelat-chtoby-funktsiya-vypolnilas-tol-ko-odin-raz-cherez-vremeni-kak-sdelat-chtoby-vypolnyalas-kazhdye-vremeni-vsegda-li-funktsiya-srabotaet-cherez-vremeni-chto-proishodit-kogda-zadaem-timeout-0"
    },
    {
        "id": 138,
        "title": "Что такое call и apply? Какую задачу решают? В чём отличие? Что такое декоратор? (Декораторы и переадресация вызова, call/apply)",
        "answer": "**1\\. Что такое call и apply**\n\n* **call** и **apply** — методы функции, позволяющие **вызывать функцию с явным указанием контекста (this)** и аргументов.\n\nfunction greet(greeting, punctuation) {\nconsole.log(\\`${greeting}, ${this.name}${punctuation}\\`);\n}\nconst user \\= {name: \"Alice\"};\ngreet.call(user, \"Hello\", \"\\!\");  // Hello, Alice\\!\ngreet.apply(user, \\[\"Hi\", \"\\!\\!\"\\]); // Hi, Alice\\!\\!\n\n**2\\. Задача, которую решают**\n\n* Позволяют **задавать контекст (this) вручную**, что важно:\n* при работе с методами объектов\n* при переиспользовании функций\n* для декораторов и функционального программирования\n\n**3\\. Отличие call от apply**\n\n| Метод | Аргументы |\n| ----- | ----- |\n| call | Передаём контекст и **список аргументов через запятую** |\n| apply | Передаём контекст и **массив аргументов** |\n\n* Пример:\n\ngreet.call(user, \"Hello\", \"\\!\");   // каждый аргумент отдельно\ngreet.apply(user, \\[\"Hello\", \"\\!\"\\]); // массив аргументов\n\n**4\\. Что такое декоратор**\n\n* **Декоратор** — функция, которая **оборачивает другую функцию**, добавляя поведение до или после её выполнения.\n\nfunction logDecorator(fn) {\nreturn function(...args) {\nconsole.log(\"Вызов функции с аргументами:\", args);\nreturn fn.apply(this, args);\n}\n}\n\nfunction sum(a,b){ return a+b; }\nconst decoratedSum \\= logDecorator(sum);\nconsole.log(decoratedSum(2,3));\n// Вызов функции с аргументами: \\[2,3\\]\n// 5\n\n* Часто используется для:\n* Логирования\n* Кэширования\n* Валидации аргументов\n* Измерения времени выполнения\n\n**Идеальная формулировка для собеседования**\n\nМетоды call и apply позволяют вызвать функцию с явным контекстом this. Разница в том, что call принимает аргументы по одному через запятую, а apply — массив аргументов. Эти методы часто используются при переадресации вызова, повторном использовании функций и в декораторах. Декоратор — это функция, которая оборачивает другую функцию для расширения её поведения, например, логирование, кэширование или проверка аргументов.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "chto-takoe-call-i-apply-kakuyu-zadachu-reshayut-v-chem-otlichie-chto-takoe-dekorator"
    },
    {
        "id": 139,
        "title": "Что такое контекст? Как и зачем привязывать контекст? Как привязать контекст ко всем функциям объекта? (Привязка контекста к функции)",
        "answer": "**1\\. Что такое контекст (this)**\n\n* Контекст — это **значение this внутри функции**, которое определяет, к каким данным функция имеет доступ.\n* В JavaScript this зависит **от способа вызова функции**, а не от её места объявления.\n\nconst obj \\= {name: \"Alice\"};\nfunction greet() {\nconsole.log(this.name);\n}\ngreet();          // undefined или ошибка в strict mode\nobj.greet \\= greet;\nobj.greet();       // \"Alice\" — this ссылается на obj\n\n**2\\. Зачем привязывать контекст**\n\n* Чтобы функция **всегда использовала нужный объект как this**, независимо от того, где она вызвана.\n* Полезно:\n* при передаче метода как callback\n* при асинхронном коде\n* для обработки событий\n\n**3\\. Как привязать контекст к функции**\n\na) Через bind\n\n* Создаёт **новую функцию с фиксированным this**:\n\nconst obj \\= {name: \"Alice\"};\nfunction greet() { console.log(this.name); }\nconst boundGreet \\= greet.bind(obj);\nboundGreet(); // \"Alice\"\nb) Через call или apply\n\n* Немедленно вызывают функцию с нужным контекстом:\n\ngreet.call(obj);  // \"Alice\"\ngreet.apply(obj); // \"Alice\"\n\n**4\\. Как привязать контекст ко всем функциям объекта**\n\n* Используем bind при инициализации методов:\n\nconst obj \\= {\nname: \"Alice\",\ngreet() { console.log(this.name); },\nbye() { console.log(\"Bye \" \\+ this.name); }\n};\n\n// привязка всех методов к obj\nfor (const key of Object.keys(obj)) {\nif (typeof obj\\[key\\] \\=== \"function\") {\nobj\\[key\\] \\= obj\\[key\\].bind(obj);\n}\n}\n\n* Теперь методы **сохраняют правильный this**, даже если их передать как колбэк.\n\n**Идеальная формулировка для собеседования**\n\nКонтекст (this) — это объект, на который ссылается функция во время выполнения. Привязывают контекст, чтобы функция всегда работала с правильным объектом, независимо от места вызова. Контекст можно привязать через bind (создаёт новую функцию), через call/apply (немедленно вызывает с контекстом). Чтобы привязать this ко всем методам объекта, можно пройтись по его методам и использовать bind.\n\n# Работа с DOM API\n\n1. Как происходит навигация по элементам DOM : 1\\. к родителю 2\\. к сестринским элементам 3\\. к первому\\\\последнему дочернему 4\\. получение списка дочерних (Навигация по DOM-элементам)\n2. Как происходит поиск элементов : 1\\. по названию тэга 2\\. по аттрибуту name 3\\. по имени класса 4\\. по id 5\\. по селектору CSS ? Что возвращают эти методы? (Поиск: getElement\\*, querySelector\\*)\n3. Какие свойства есть у элемента DOM ? (Свойства узлов: тип, тег и содержимое)\n4. Какие способы вставки элемента есть : 1.перед элементов 2\\. после элемента 3\\. внутри дочерних вначале 4.внутри дочерних в конце ? Как удалить элемент из DOM дерева? (Изменение документа)",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "chto-takoe-kontekst-kak-i-zachem-privyazyvat-kontekst-kak-privyazat-kontekst-ko-vsem-funktsiyam-ob-ekta"
    },
    {
        "id": 140,
        "title": "Как происходит навигация по элементам DOM : 1\\. к родителю 2\\. к сестринским элементам 3\\. к первому\\\\последнему дочернему 4\\. получение списка дочерних (Навигация по DOM-элементам)",
        "answer": "Общий принцип\n\nDOM — это **дерево узлов**. Навигация по DOM — это перемещение между узлами: родитель → дети → соседи.\n\nВажно различать:\n\n* **Element-узлы** (только HTML-элементы)\n* **Node-узлы** (элементы \\+ текст \\+ комментарии)\n\n1\\. Навигация к родителю\n\nК родительскому элементу\nelement.parentElement\n\n* Возвращает **родительский HTML-элемент**\n* Если родителя нет — null\n\nК родительскому узлу (любой тип)\nelement.parentNode\nИспользуют редко, так как может вернуть Document.\n2\\. Навигация к сестринским элементам\n\nСледующий элемент\nelement.nextElementSibling\nПредыдущий элемент\nelement.previousElementSibling\n\n* Игнорируют текстовые узлы\n* Если элемента нет — null\n\n⚠️ nextSibling / previousSibling — возвращают **любой узел**, включая текст\n3\\. Первый и последний дочерний элемент\n\nПервый дочерний элемент\nelement.firstElementChild\nПоследний дочерний элемент\nelement.lastElementChild\n⚠️ firstChild / lastChild — могут вернуть текст\n4\\. Получение списка дочерних элементов\n\nТолько элементы\nelement.children\n\n* HTMLCollection (живой)\n* Только HTML-элементы\n\nВсе узлы (включая текст)\nelement.childNodes\n\n* NodeList\n* Включает \\#text, комментарии\n\nКраткая таблица (идеально для собеседования)\n\n| Задача | Свойство |\n| ----- | ----- |\n| Родитель | parentElement |\n| Следующий сосед | nextElementSibling |\n| Предыдущий сосед | previousElementSibling |\n| Первый ребёнок | firstElementChild |\n| Последний ребёнок | lastElementChild |\n| Все дети (элементы) | children |\n| Все узлы | childNodes |\n\n**Идеальная формулировка для собеседования**\n\nНавигация по DOM происходит через свойства элементов. Для перехода к родителю используют parentElement, к соседним элементам — nextElementSibling и previousElementSibling. Первый и последний дочерний элемент получаем через firstElementChild и lastElementChild. Список всех дочерних элементов — children.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kak-proishodit-navigatsiya-po-elementam-dom-1-k-roditelyu-2-k-sestrinskim-elementam-3-k-pervomu-poslednemu-dochernemu-4-poluchenie-spiska-dochernih"
    },
    {
        "id": 141,
        "title": "Как происходит поиск элементов : 1\\. по названию тэга 2\\. по аттрибуту name 3\\. по имени класса 4\\. по id 5\\. по селектору CSS ? Что возвращают эти методы? (Поиск: getElement\\*, querySelector\\*)",
        "answer": "Общий принцип поиска в DOM\n\nПоиск элементов выполняется **от документа или от конкретного элемента**.\nМетоды делятся на две группы:\n\n1. **Старые методы getElement\\***\n2. **Современные методы querySelector\\* (CSS-селекторы)**\n\n1\\. Поиск по названию тега\n\ndocument.getElementsByTagName('div');\n\n* Возвращает **HTMLCollection**\n* Коллекция **живая** (обновляется при изменении DOM)\n* Можно вызывать от document и от любого элемента\n\nparent.getElementsByTagName('p');\n\n2\\. Поиск по атрибуту name\n\ndocument.getElementsByName('username');\n\n* Возвращает **NodeList**\n* Используется в основном для форм\n* Можно вызывать **только от document**\n\n3\\. Поиск по имени класса\n\ndocument.getElementsByClassName('item');\n\n* Возвращает **HTMLCollection**\n* Коллекция **живая**\n* Можно вызывать от document и от элемента\n\n4\\. Поиск по id\n\ndocument.getElementById('header');\n\n* Возвращает **один элемент** или null\n* id уникален\n* Вызывается **только от document**\n\n5\\. Поиск по CSS-селектору\n\nОдин элемент\ndocument.querySelector('.item');\n\nВсе элементы\n\ndocument.querySelectorAll('.item');\n\n* Используют **любой CSS-селектор**\n* querySelector → первый найденный элемент или null\n* querySelectorAll → **NodeList (статический)**\n\nЧто возвращают методы (ключевое отличие)\n\n| Метод | Что возвращает | Живой |\n| ----- | ----- | ----- |\n| getElementById | Element / null | ❌ |\n| getElementsByTagName | HTMLCollection | ✅ |\n| getElementsByClassName | HTMLCollection | ✅ |\n| getElementsByName | NodeList | ❌ |\n| querySelector | Element / null | ❌ |\n| querySelectorAll | NodeList | ❌ |\n\nHTMLCollection vs NodeList (частый вопрос)\n\n* **HTMLCollection**\n* Живой\n* Только элементы\n* Нет forEach\n* **NodeList**\n* Статический (в querySelectorAll)\n* Может содержать любые узлы\n* Есть forEach\n\n**Идеальная формулировка для собеседования**\n\nПоиск элементов в DOM можно выполнять через методы getElement\\* и querySelector\\*. По тегу используется getElementsByTagName, по атрибуту name — getElementsByName, по классу — getElementsByClassName, по id — getElementById. Универсальный способ — querySelector и querySelectorAll, которые принимают CSS-селекторы. getElement\\* возвращают живые коллекции, а querySelectorAll — статический NodeList.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kak-proishodit-poisk-elementov-1-po-nazvaniyu-tega-2-po-attributu-name-3-po-imeni-klassa-4-po-id-5-po-selektoru-css-chto-vozvraschayut-eti-metody"
    },
    {
        "id": 142,
        "title": "Какие свойства есть у элемента DOM ? (Свойства узлов: тип, тег и содержимое)",
        "answer": "Общая идея\n\nКаждый элемент DOM — это **узел (Node)**.\nУ узлов есть свойства, описывающие:\n\n1. **Тип узла**\n2. **Название тега**\n3. **Содержимое**\n\nТип узла (nodeType)\n\nnode.nodeType\nВозвращает **числовой код типа узла**.\nОсновные значения:\n\n| Значение | Тип узла |\n| ----- | ----- |\n| 1 | Element node (\\<div\\>) |\n| 3 | Text node |\n| 8 | Comment node |\n| 9 | Document node |\n\nНа практике чаще всего проверяют:\nnode.nodeType \\=== 1 // HTML-элемент\n\nНазвание тега (tagName, nodeName)\n\ntagName\nelement.tagName\n\n* Возвращает **имя HTML-тега в верхнем регистре**\n* Работает **только для элементов**\n\ndiv.tagName; // \"DIV\"\n\nnodeName\n\nnode.nodeName\n\n* Работает **для любых узлов**\n* Для элементов совпадает с tagName\n* Для текста возвращает \\#text\n\nСодержимое узла\n\ninnerHTML\nelement.innerHTML\n\n* Возвращает или устанавливает **HTML-содержимое**\n* Может менять структуру DOM\n* Менее безопасен (XSS)\n\ntextContent\n\nelement.textContent\n\n* Возвращает **только текст**\n* Игнорирует HTML-теги\n* Работает быстрее и безопаснее\n\ninnerText\n\nelement.innerText\n\n* Возвращает **видимый текст**\n* Учитывает CSS (display: none)\n* Медленнее, чем textContent\n\nКраткое сравнение содержимого\n\n| Свойство | HTML | CSS влияет | Безопасность |\n| ----- | ----- | ----- | ----- |\n| innerHTML | ✅ | ❌ | ❌ |\n| textContent | ❌ | ❌ | ✅ |\n| innerText | ❌ | ✅ | ✅ |\n\n**Идеальная формулировка для собеседования**\n\nDOM-элемент является узлом и имеет свойства nodeType для определения типа узла, tagName и nodeName для имени тега. Для работы с содержимым используются innerHTML — для HTML, textContent — для чистого текста и innerText — для видимого текста с учётом стилей. В большинстве случаев предпочтителен textContent как более безопасный и быстрый",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kakie-svoystva-est-u-elementa-dom"
    },
    {
        "id": 143,
        "title": "Какие способы вставки элемента есть : 1.перед элементов 2\\. после элемента 3\\. внутри дочерних вначале 4.внутри дочерних в конце ? Как удалить элемент из DOM дерева? (Изменение документа)",
        "answer": "###\n\nОбщий принцип\n\nDOM — **мутабельное дерево**.\nЭлемент можно:\n\n* вставить **относительно другого элемента**\n* вставить **внутрь контейнера**\n* удалить из DOM\n\nСовременный стандарт — **методы before / after / prepend / append / remove**.\n\nВставка элемента перед элементом\n\nelement.before(newElement);\n\n* Вставляет newElement **перед** element\n* Работает и с элементами, и со строками\n\nitem.before(div);\n\nВставка элемента после элемента\n\nelement.after(newElement);\n\n* Вставляет newElement **после** element\n\nitem.after(div);\n\nВставка внутрь дочерних — в начале\n\nparent.prepend(newElement);\n\n* Добавляет элемент **первым ребёнком**\n\nlist.prepend(li);\n\nВставка внутрь дочерних — в конце\n\nparent.append(newElement);\n\n* Добавляет элемент **последним ребёнком**\n\nlist.append(li);\n\nАльтернативный универсальный способ (insertAdjacentHTML)\n\nelement.insertAdjacentHTML(position, html);\n\n| Position | Куда вставляет |\n| ----- | ----- |\n| beforebegin | Перед элементом |\n| afterbegin | Внутрь, в начало |\n| beforeend | Внутрь, в конец |\n| afterend | После элемента |\n\nИспользуется для **вставки HTML-строк без пересоздания DOM**.\n\nКак удалить элемент из DOM\n\nСовременный способ\n\nelement.remove();\n\n* Полностью удаляет элемент из DOM\n* Ссылка в JS остаётся\n\nСтарый способ (редко)\n\nelement.parentElement.removeChild(element);\n\n**Идеальная формулировка для собеседования**\n\nДля изменения DOM используют методы before и after — для вставки элемента перед или после другого элемента, prepend и append — для вставки внутрь контейнера в начало или конец. Для удаления элемента применяется remove(). Также существует метод insertAdjacentHTML, который позволяет вставлять HTML-строку в конкретное место без пересоздания DOM.\n\n###\n\n# Работа с событиями JS\n\n1. Какие свойства есть в обьекте события (элемент на котором висит обработчик, элемент который инициировал событие) ? Как повесить\\\\отменить событие ? Как повесить сразу несколько обработчиков на одно событие? Какой нюанс нужно учитывать при удалении обработчика события (подсказка: затрагивает ссылочный тип). Какие 3 стадии есть у события ? Как отменить всплытие сопытия ? Обьект события и его свойства. (Основы работы с событиями, стадии всплытия и погружения)\n2. Как отменить действие браузера по умолчанию ? (Действия браузера по умолчанию)",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kakie-sposoby-vstavki-elementa-est-1-pered-elementov-2-posle-elementa-3-vnutri-dochernih-vnachale-4-vnutri-dochernih-v-kontse-kak-udalit-element-iz-dom-dereva"
    },
    {
        "id": 144,
        "title": "Какие свойства есть в обьекте события (элемент на котором висит обработчик, элемент который инициировал событие) ? Как повесить\\\\отменить событие ? Как повесить сразу несколько обработчиков на одно событие? Какой нюанс нужно учитывать при удалении обработчика события (подсказка: затрагивает ссылочный тип). Какие 3 стадии есть у события ? Как отменить всплытие сопытия ? Обьект события и его свойства. (Основы работы с событиями, стадии всплытия и погружения)",
        "answer": "Объект события (Event)\n\nКогда происходит событие, браузер создаёт **объект события** и передаёт его в обработчик.\nbutton.addEventListener('click', (event) \\=\\> {\nconsole.log(event);\n});\n\nКлючевые свойства объекта события\n\n🔹 Элемент, на котором висит обработчик\nevent.currentTarget\n\n* Элемент, **на котором зарегистрирован обработчик**\n* Всегда один и тот же внутри обработчика\n\n🔹 Элемент, который инициировал событие\nevent.target\n\n* Реальный элемент, **где произошло событие**\n* Используется в делегировании событий\n\nЧасто используемые свойства\n\n| Свойство | Назначение |\n| ----- | ----- |\n| type | Тип события (click, input) |\n| target | Источник события |\n| currentTarget | Элемент с обработчиком |\n| eventPhase | Текущая фаза события |\n| timeStamp | Время события |\n\nКак повесить событие\n\nСовременный способ\nelement.addEventListener('click', handler);\n\n* Можно повесить **несколько обработчиков**\n* Не перезаписывает существующие\n\nКак отменить событие\n\nelement.removeEventListener('click', handler);\n\n⚠️ **Нюанс:**\n\n* Функция должна быть **той же самой ссылкой**, что и при добавлении\n\n❌ Не сработает:\n\nelement.addEventListener('click', () \\=\\> {});\nelement.removeEventListener('click', () \\=\\> {});\n\n✅ Правильно:\n\nfunction handler() {}\nelement.addEventListener('click', handler);\nelement.removeEventListener('click', handler);\n\nКак повесить несколько обработчиков на одно событие\n\nelement.addEventListener('click', handler1);\nelement.addEventListener('click', handler2);\n\n* Все обработчики выполнятся по порядку добавления\n\nТри стадии события\n\n1. **Погружение (capturing)**\nСобытие идёт от document к целевому элементу\n2. **Целевая фаза (target)**\nСобытие достигает event.target\n3. **Всплытие (bubbling)**\nСобытие поднимается вверх по DOM\n\nelement.addEventListener('click', handler, true); // capturing\n\nКак отменить всплытие события\n\nevent.stopPropagation();\n\n* Останавливает дальнейшее всплытие\n\nevent.stopImmediatePropagation();\n\n* Останавливает всплытие **и другие обработчики на этом элементе**\n\nКак отменить стандартное поведение\n\nevent.preventDefault();\n\n* Например: отмена перехода по ссылке или отправки формы\n\n**Идеальная формулировка для собеседования**\n\nПри возникновении события браузер создаёт объект Event, который содержит информацию о событии. event.target — элемент, который инициировал событие, а event.currentTarget — элемент, на котором висит обработчик. События навешиваются через addEventListener и удаляются через removeEventListener, при этом важно передавать одну и ту же ссылку на функцию. Событие проходит три стадии: погружение, целевую и всплытие. Всплытие можно остановить через stopPropagation, а стандартное поведение — через preventDefault.",
        "category": "DOM API",
        "difficulty": "Medium",
        "slug": "kakie-svoystva-est-v-ob-ekte-sobytiya-kak-povesit-otmenit-sobytie-kak-povesit-srazu-neskol-ko-obrabotchikov-na-odno-sobytie-kakoy-nyuans-nuzhno-uchityvat-pri-udalenii-obrabotchika-sobytiya-kakie-3-stadii-est-u-sobytiya-kak-otmenit-vsplytie-sopytiya-ob-ekt-sobytiya-i-ego-svoystva"
    },
    {
        "id": 145,
        "title": "Как отменить действие браузера по умолчанию ? (Действия браузера по умолчанию)",
        "answer": "Основной способ — event.preventDefault()\n\n* Используется для **отмены стандартного поведения браузера**, связанного с событием.\n\nlink.addEventListener('click', (event) \\=\\> {\nevent.preventDefault();\n});\n\nЧто считается действием браузера по умолчанию\n\nПримеры:\n\n* Переход по ссылке \\<a\\>\n* Отправка формы \\<form\\>\n* Фокус по клику\n* Прокрутка страницы (wheel, touchmove)\n* Контекстное меню (right click)\n* Перетаскивание элементов\n\nЧастые примеры\n\nОтмена отправки формы\n\nform.addEventListener('submit', (e) \\=\\> {\ne.preventDefault();\n});\n\nОтмена перехода по ссылке\n\n\\<a href=\"/profile\" id=\"link\"\\>Profile\\</a\\>\n\ndocument.getElementById('link')\n.addEventListener('click', e \\=\\> e.preventDefault());\n\nОтмена контекстного меню\n\ndocument.addEventListener('contextmenu', e \\=\\> e.preventDefault());\n\nВажный нюанс — passive listeners\n\n* Для некоторых событий (wheel, touchmove) обработчики по умолчанию **passive**\n* В passive-обработчиках **нельзя вызвать preventDefault()**\n\nelement.addEventListener('touchmove', handler, { passive: false });\n\nНе путать с stopPropagation\n\n| Метод | Что делает |\n| ----- | ----- |\n| preventDefault() | Отменяет стандартное поведение |\n| stopPropagation() | Останавливает всплытие события |\n\n**Идеальная формулировка для собеседования**\n\nЧтобы отменить действие браузера по умолчанию, используют метод event.preventDefault(). Он блокирует стандартное поведение, например, переход по ссылке или отправку формы. При этом важно учитывать passive-обработчики, в которых preventDefault недоступен, и не путать его с stopPropagation, который управляет только всплытием события.\n\n## Свойства объекта, их конфигурация\n\n1. Какие есть флаги? Способы их установки? Методы глобального запечатывания объекта. (Флаги и дескрипторы свойств)\n2. Что такое? Какие дескрипторы? (Свойства \\- геттеры и сеттеры)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-otmenit-deystvie-brauzera-po-umolchaniyu"
    },
    {
        "id": 146,
        "title": "Какие есть флаги? Способы их установки? Методы глобального запечатывания объекта. (Флаги и дескрипторы свойств)",
        "answer": "Что такое флаги (дескрипторы) свойств\n\nКаждое свойство объекта в JavaScript имеет **дескриптор** — набор флагов, определяющих его поведение.\nconst user \\= { name: \"Alice\" };\nObject.getOwnPropertyDescriptor(user, 'name');\n\nОсновные флаги (для data-свойств)\n\n| Флаг | Значение |\n| ----- | ----- |\n| value | Значение свойства |\n| writable | Можно ли изменять значение |\n| enumerable | Участвует ли в for...in, Object.keys |\n| configurable | Можно ли удалять и менять дескриптор |\n\nФлаги для accessor-свойств\n\n| Флаг | Назначение |\n| ----- | ----- |\n| get | Функция-геттер |\n| set | Функция-сеттер |\n| enumerable | Перечисляемость |\n| configurable | Переконфигурация |\n\n⚠️ Accessor-свойство **не может** иметь value и writable.\n\n4\\. Способы установки флагов\n\nObject.defineProperty\n\nObject.defineProperty(user, 'age', {\nvalue: 30,\nwritable: false,\nenumerable: true,\nconfigurable: false\n});\n\n* Если флаг не указан → false по умолчанию\n\nObject.defineProperties\n\nObject.defineProperties(user, {\nname: { writable: false },\nage: { enumerable: false }\n});\n\nМетоды глобального «запечатывания» объекта\n\n🔒 Object.preventExtensions(obj)\n\n* Запрещает добавление новых свойств\n* Существующие можно менять и удалять\n\n🔐 Object.seal(obj)\n\n* Запрещает добавление и удаление свойств\n* Делает configurable: false\n* Значения менять можно\n\n❄️ Object.freeze(obj)\n\n* Полностью «замораживает» объект\n* Запрещает:\n* добавление\n* удаление\n* изменение значений\n* Устанавливает writable: false, configurable: false\n\n⚠️ Поверхностная заморозка (shallow)\n\nПроверка состояния объекта\n\n| Метод | Проверка |\n| ----- | ----- |\n| Object.isExtensible(obj) | Можно ли добавлять свойства |\n| Object.isSealed(obj) | Запечатан ли |\n| Object.isFrozen(obj) | Заморожен ли |\n\n**Идеальная формулировка для собеседования**\n\nСвойства объектов имеют дескрипторы с флагами writable, enumerable и configurable. Они определяют, можно ли изменять значение, участвует ли свойство в перечислении и можно ли его удалять или переконфигурировать. Флаги задаются через Object.defineProperty. Для глобального ограничения объекта используются preventExtensions, seal и freeze, которые поэтапно ограничивают добавление, удаление и изменение свойств.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kakie-est-flagi-sposoby-ih-ustanovki-metody-global-nogo-zapechatyvaniya-ob-ekta"
    },
    {
        "id": 147,
        "title": "Что такое? Какие дескрипторы? (Свойства \\- геттеры и сеттеры)",
        "answer": "Что такое геттеры и сеттеры\n\n**Геттеры и сеттеры** — это свойства объекта, значение которых определяется **функциями доступа**, а не хранимым значением.\n\n* get — вызывается при чтении свойства\n* set — вызывается при записи свойства\n\nconst user \\= {\nname: 'Alex',\nget fullName() {\nreturn this.name \\+ ' Smith';\n},\nset fullName(value) {\nthis.name \\= value.split(' ')\\[0\\];\n}\n};\n\n📌 Внешне используются **как обычные свойства**, а не как функции.\n\nКакие дескрипторы есть у accessor-свойств\n\nAccessor-свойства имеют **другой набор дескрипторов**, чем data-свойства.\nДескрипторы accessor-свойства\n\n| Дескриптор | Назначение |\n| ----- | ----- |\n| get | Функция-геттер |\n| set | Функция-сеттер |\n| enumerable | Перечисляемость |\n| configurable | Возможность изменения/удаления |\n\n❌ У accessor-свойств **нет**:\n\n* value\n* writable\n\nПолучение дескриптора\n\nObject.getOwnPropertyDescriptor(user, 'fullName');\n\nРезультат:\n{\nget: ƒ,\nset: ƒ,\nenumerable: true,\nconfigurable: true\n}\nСоздание геттеров и сеттеров через defineProperty\n\nObject.defineProperty(user, 'age', {\nget() {\nreturn this.\\_age;\n},\nset(value) {\nif (value \\< 0\\) throw new Error('Invalid age');\nthis.\\_age \\= value;\n},\nenumerable: true,\nconfigurable: true\n});\n\nОтличие accessor-свойств от data-свойств\n\n| Data property | Accessor property |\n| ----- | ----- |\n| value, writable | get, set |\n| Хранит значение | Вычисляет значение |\n| Можно напрямую изменить | Можно валидировать |\n\nЗачем нужны геттеры и сеттеры\n\nОсновные задачи:\n\n1. **Инкапсуляция**\n2. **Валидация данных**\n3. **Ленивая и вычисляемая логика**\n4. **Обратная совместимость API**\n5. **Реакция на изменение значения**\n\nset price(value) {\nthis.\\_price \\= value;\nthis.recalculateTotal();\n}\n\nВажные нюансы (часто спрашивают)\n\nГеттер вызывается при:\n\nobj.prop;\n\nСеттер вызывается при:\n\nobj.prop \\= value;\n\nЕсли сеттера нет\n\nobj.prop \\= value; // silently ignored или TypeError в strict mode\n\nthis в геттере/сеттере\n\n* this — объект, к которому обращаются\n\n**Формулировка для собеседования**\n\nГеттеры и сеттеры — это accessor-свойства, которые позволяют перехватывать чтение и запись значения. Они не имеют value и writable, а вместо этого используют функции get и set. Управляются через дескрипторы свойств и позволяют реализовать инкапсуляцию, валидацию и вычисляемые свойства, оставаясь прозрачными для пользователя API.\n\n# Прототипы, наследование\n\n1. Что такое наследование? Где лежит прототип? Куда происходит запись? Какое значение this? Как получить только неунаследованные ключи?( Прототипное наследование)\n2. Как добавить прототип в функцию конструктор? Как экземпляр связывается с функционалом функции-конструктора ? (F.prototype Middle+ Какие встроеные прототипы есть? Как изменить встроеный прототип? Встроенные прототипы Middle- Как создать объект без прототипа? Зачем такое нужно? (Методы прототипов)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "chto-takoe-kakie-deskriptory"
    },
    {
        "id": 148,
        "title": "Что такое наследование? Где лежит прототип? Куда происходит запись? Какое значение this? Как получить только неунаследованные ключи?( Прототипное наследование)",
        "answer": "Что такое наследование в JavaScript\n\n**Наследование** — это механизм, при котором объект получает доступ к свойствам и методам другого объекта через **цепочку прототипов**.\n\nВ JS наследование **прототипное**, а не классовое.\nconst animal \\= {  eats: true};\nconst dog \\= {  barks: true};\n\nObject.setPrototypeOf(dog, animal);\n\nТеперь:\ndog.eats // true (унаследовано)\n\nГде лежит прототип\n\nФактически:\n\n* Прототип хранится во **внутреннем слоте** объекта — \\[\\[Prototype\\]\\]\n\nДоступ к нему:\n\n* obj.\\_\\_proto\\_\\_ (не рекомендуется)\n* Object.getPrototypeOf(obj) — корректно\n* Object.setPrototypeOf(obj, proto) — установка\n\nObject.getPrototypeOf(dog) \\=== animal; // true\n\nКак работает поиск свойства\n\n1. Сначала ищется **в самом объекте**\n2. Если не найдено — поиск идёт в \\[\\[Prototype\\]\\]\n3. Далее — вверх по цепочке\n4. До null\n\ndog.barks  // найдено в dog\ndog.eats   // найдено в animal\n\nКуда происходит запись свойства\n\n❗ **Запись всегда происходит в сам объект**, а не в прототип.\ndog.eats \\= false;\n\nТеперь:\ndog.eats      // false (собственное)\nanimal.eats  // true (не изменился)\n\n📌 Исключение:\n\n* если в прототипе есть **setter**, он будет вызван\n\nКакое значение this\n\nthis всегда указывает на **объект слева от точки**, а не на прототип.\nconst animal \\= {\nsay() {\nconsole.log(this.type);\n}\n};\nconst dog \\= {  type: 'dog'};\nObject.setPrototypeOf(dog, animal);\ndog.say(); // this \\=== dog\n📌 Даже если метод лежит в прототипе — this это **вызывающий объект**.\n\nНаследование и функции-конструкторы\n\nfunction Animal(name) {\nthis.name \\= name;\n}\n\nAnimal.prototype.eat \\= function () {\nreturn this.name \\+ ' eats';\n};\n\nfunction Dog(name) {\nAnimal.call(this, name);\n}\n\nDog.prototype \\= Object.create(Animal.prototype);\nDog.prototype.constructor \\= Dog;\n\nЦепочка:\ndog → Dog.prototype → Animal.prototype → Object.prototype → null\n\nКак получить только НЕунаследованные ключи\n\n✅ Собственные enumerable-свойства\nObject.keys(obj);\n\n✅ Все собственные (включая non-enumerable)\n\nObject.getOwnPropertyNames(obj);\n\n✅ Собственные \\+ Symbol\n\nObject.getOwnPropertySymbols(obj);\n\n✅ Абсолютно все собственные\n\nReflect.ownKeys(obj);\n\n❌ for...in\n\nfor (const key in obj) {\n// включает унаследованные enumerable\n}\n\nПроверка: собственное или унаследованное\n\nobj.hasOwnProperty('key');          // true / false\nObject.hasOwn(obj, 'key');          // современный вариант\n\nЧастые вопросы с подвохом\n\nМожно ли менять прототип?\n\n* Да, но **дорого по производительности**\n* Лучше задавать при создании (Object.create)\n\nЧто у вершины цепочки?\n\nObject.getPrototypeOf(Object.prototype) \\=== null;\n\n**Краткая формулировка для собеседования**\n\nВ JavaScript наследование реализовано через цепочку прототипов. Каждый объект имеет скрытое свойство \\[\\[Prototype\\]\\], по которому происходит поиск свойств. Чтение идёт вверх по цепочке, а запись всегда происходит в сам объект. Значение this определяется объектом вызова, а не местом объявления метода. Для получения только собственных свойств используются Object.keys, Object.getOwnPropertyNames и Reflect.ownKeys.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "chto-takoe-nasledovanie-gde-lezhit-prototip-kuda-proishodit-zapis-kakoe-znachenie-this-kak-poluchit-tol-ko-neunasledovannye-klyuchi"
    },
    {
        "id": 149,
        "title": "Как добавить прототип в функцию конструктор? Как экземпляр связывается с функционалом функции-конструктора ? (F.prototype Middle+ Какие встроеные прототипы есть? Как изменить встроеный прототип? Встроенные прототипы Middle- Как создать объект без прототипа? Зачем такое нужно? (Методы прототипов)",
        "answer": "Как добавить прототип в функцию-конструктор (F.prototype)\n\nУ **каждой функции** в JS есть свойство prototype (используется **только при вызове через new**).\nfunction User(name) {\nthis.name \\= name;\n}\nUser.prototype.sayHi \\= function () {\nreturn \\`Hi, ${this.name}\\`;\n};\n\n* User.prototype — объект, который станет прототипом экземпляров\n* В него добавляют **методы и общие свойства**\n\nКак экземпляр связывается с функционалом конструктора\n\nПри вызове new User() происходит **4 шага**:\n\n1. Создаётся пустой объект\n2. Его \\[\\[Prototype\\]\\] указывает на User.prototype\n3. this внутри User ссылается на этот объект\n4. Возвращается объект (если return не вернул объект явно)\n\nconst user \\= new User('Alex');\nObject.getPrototypeOf(user) \\=== User.prototype; // true\n\n📌 Связь:\nuser → \\[\\[Prototype\\]\\] → User.prototype\nГде правильно хранить методы\n\n❌ Плохо (дублирование):\nfunction User() {\nthis.sayHi \\= function () {};\n}\n✅ Правильно:\nUser.prototype.sayHi \\= function () {};\n\nКакие встроенные прототипы есть (Middle-)\n\nКаждый тип имеет свой прототип:\n\n| Тип | Прототип |\n| ----- | ----- |\n| Object | Object.prototype |\n| Array | Array.prototype |\n| Function | Function.prototype |\n| Number | Number.prototype |\n| String | String.prototype |\n| Boolean | Boolean.prototype |\n| Date | Date.prototype |\n| RegExp | RegExp.prototype |\n| Map | Map.prototype |\n| Set | Set.prototype |\n| Promise | Promise.prototype |\n| Error | Error.prototype |\n\nПример цепочки:\n\\[\\] → Array.prototype → Object.prototype → null\n\nКак изменить встроенный прототип\n\n⚠ **Технически возможно, но крайне не рекомендуется**\nArray.prototype.last \\= function () {\nreturn this\\[this.length \\- 1\\];\n};\n\nРиски:\n\n* конфликты имён\n* ломает сторонние библиотеки\n* неожиданные баги\n* проблемы при обновлениях JS\n\n📌 Допустимо:\n\n* **полифилы стандартов**\n* методы с проверкой существования\n\nif (\\!Array.prototype.last) {\nArray.prototype.last \\= function () {};\n}\n\nКак создать объект без прототипа\n\nconst dict \\= Object.create(null);\n\nРезультат:\ndict.\\_\\_proto\\_\\_ \\=== undefined;\n\nЗачем нужен объект без прототипа\n\nОсновные причины:\n\n1. **Чистый словарь**\n* нет toString, constructor, \\_\\_proto\\_\\_\n2. Безопасная работа с ключами\ndict\\['\\_\\_proto\\_\\_'\\] \\= 'test'; // не ломает объект\n3. Быстрее и предсказуемее для map-подобных структур\n\n📌 Часто используется для:\n\n* словарей\n* конфигураций\n* lookup-таблиц\n\nМетоды работы с прототипами\n\nПолучить прототип\nObject.getPrototypeOf(obj);\n\nУстановить прототип\n\nObject.setPrototypeOf(obj, proto); // дорого\n\nСоздать объект с прототипом\n\nObject.create(proto);\n\nПроверка принадлежности прототипу\n\nobj instanceof Constructor;\nConstructor.prototype.isPrototypeOf(obj);\n\nЧастые вопросы на собеседовании\n\nПочему нельзя менять prototype после создания экземпляров?\n\nUser.prototype \\= {};\n\n→ старые объекты останутся привязанными к старому прототипу\n\nЧем отличается prototype и \\_\\_proto\\_\\_?\n\n* prototype — свойство **функции**\n* \\_\\_proto\\_\\_ — ссылка **объекта** на его прототип\n\n**Краткая формулировка для собеседования**\n\nПри вызове функции-конструктора через new объект связывается с F.prototype через \\[\\[Prototype\\]\\]. Методы конструктора следует размещать в prototype, чтобы избежать дублирования. Встроенные типы имеют собственные прототипы, образующие цепочку до Object.prototype. Изменять встроенные прототипы не рекомендуется, за исключением полифилов. Объекты без прототипа создаются через Object.create(null) и используются как безопасные словари.\n\n# Классы\n\n1. Что такое класс? Что такое конструктор класса и когда он создается? Как можно заменить класс , функцией конструктором ? (Класс)\n2. Как переопределить методы класса? Как переорпеделить конструктор? Что такое super? Как в этом участвуют прототипы? (Наследование классо)\n3. Что такое static? Могут ли быть класс, константа, функция статическими? Для чего это надо? (Статические свойства и методы)\n4. Как указать что поле приватное/защищённое? Какие выгоды это даёт? (Приватные и защищённые методы и свойства)\n5. Как происходит наследование статических методов? Middle Как расширить встроенный класс? Какое отличие наследования встроенных классов? (Расширение встроенных классов)\n6. Как проверить к какому классу принадлежит объект? Почему нельзя использовать typeOf? Как работает instanceOf ?( instanceOf)\n7. Как вынести общую логику между классами?(Примеси)",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-dobavit-prototip-v-funktsiyu-konstruktor-kak-ekzemplyar-svyazyvaetsya-s-funktsionalom-funktsii-konstruktora"
    },
    {
        "id": 150,
        "title": "Что такое класс? Что такое конструктор класса и когда он создается? Как можно заменить класс , функцией конструктором ? (Класс)",
        "answer": "Что такое класс\n\n**Класс** в JavaScript — это **синтаксический сахар** над **функциями-конструкторами и прототипным наследованием**.\n\n* Позволяет создавать объекты с общими методами и свойствами\n* Внутри класса можно объявлять методы, геттеры/сеттеры, статические методы\n\nclass User {\nconstructor(name) {    this.name \\= name; // свойство экземпляра  }\nsayHi() {    console.log(\\`Hi, ${this.name}\\`);  }\nstatic info() {    console.log(\"I am a User class\");  }\n}\n\nКонструктор класса\n\n* Метод constructor вызывается **при создании нового экземпляра через new**\n* Используется для **инициализации свойств объекта**\n* В классе может быть **только один constructor**\n\nconst user \\= new User('Alex');\nuser.sayHi(); // Hi, Alex\n\n* Если constructor не объявлен, создается **пустой конструктор по умолчанию**.\n\n⚠ Особенности\n\n1. constructor **не может быть вызван без new**\n\nUser(); // TypeError\n\n2. Внутри конструктора this указывает на создаваемый экземпляр\n3. Методы класса автоматически попадают в prototype, а не в сам объект\n\nUser.prototype.sayHi \\=== user.sayHi; // true\n\nКак можно заменить класс функцией-конструктором\n\nКласс эквивалентен функции-конструктору с прототипными методами:\nfunction User(name) {  this.name \\= name; // аналог constructor}\n\n// методы в prototype\nUser.prototype.sayHi \\= function () {  console.log(\\`Hi, ${this.name}\\`);};\n\nUser.info \\= function () {  console.log(\"I am a User class\");};\n\nИспользование:\nconst user \\= new User('Alex');\nuser.sayHi(); // Hi, Alex\nUser.info(); // I am a User class\n\nСравнение класса и функции-конструктора\n\n| Характеристика | Класс | Функция-конструктор |\n| ----- | ----- | ----- |\n| Синтаксис | class | function |\n| Методы | prototype | prototype |\n| Статические методы | static | Присвоение функции |\n| constructor | Обязательный метод | Тело функции |\n| Вызов без new | ❌ TypeError | Можно, но this будет window (или undefined в strict) |\n| Наследование | extends | F.prototype \\= Object.create(P.prototype) |\n\nИдеальная формулировка для собеседования\n\nКласс в JavaScript — это синтаксический сахар над функцией-конструктором и прототипным наследованием. Метод constructor создаётся автоматически или объявляется вручную для инициализации экземпляра. Методы класса попадают в prototype, статические — в саму функцию. Любой класс можно заменить функцией-конструктором с прототипными методами и статическими свойствами, функционально поведение будет идентичным.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "chto-takoe-klass-chto-takoe-konstruktor-klassa-i-kogda-on-sozdaetsya-kak-mozhno-zamenit-klass-funktsiey-konstruktorom"
    },
    {
        "id": 151,
        "title": "Как переопределить методы класса? Как переорпеделить конструктор? Что такое super? Как в этом участвуют прототипы? (Наследование классов)",
        "answer": "Как переопределить методы класса\n\nПри наследовании подкласс может **переопределить метод родителя**:\nclass Animal {  speak() {    console.log(\"Animal speaks\");  }}\nclass Dog extends Animal {\nspeak() { // переопределение\nconsole.log(\"Dog barks\");\n}\n}\n\nconst dog \\= new Dog();\ndog.speak(); // Dog barks\n\n* Метод с тем же именем в подклассе **замещает** метод родителя\n* Вызов через super позволяет обратиться к родительскому методу\n\nclass Dog extends Animal {\nspeak() {\nsuper.speak(); // вызов родительского метода\nconsole.log(\"Dog barks\");\n}\n}\n\nКак переопределить конструктор\n\n* Подкласс может объявить свой constructor\n* **Обязательно вызвать super()** перед использованием this\n\nclass Animal {\nconstructor(name) {\nthis.name \\= name;\n}\n}\n\nclass Dog extends Animal {\nconstructor(name, breed) {\nsuper(name); // вызов конструктора родителя\nthis.breed \\= breed;\n}\n}\n\nconst dog \\= new Dog(\"Max\", \"Bulldog\");\nconsole.log(dog.name, dog.breed); // Max Bulldog\n\n* Если constructor в подклассе отсутствует — создаётся автоматически и вызывает super(...) с аргументами.\n\nЧто такое super\n\nsuper выполняет **две функции**:\n\n1. В конструкторе — вызывает **конструктор родителя** и инициализирует this\n2. В методах — позволяет обратиться к **методу родителя**\n\nclass A {  hello() { console.log(\"A\"); }}\nclass B extends A {\nhello() {\nsuper.hello(); // вызывает A.hello\nconsole.log(\"B\");\n}\n}\nКак в этом участвуют прототипы\n\nЦепочка наследования классов реализована через **прототипы**:\ninstance.\\_\\_proto\\_\\_ → SubClass.prototype → SuperClass.prototype → Object.prototype → null\n\nПример:\nDog.prototype.\\_\\_proto\\_\\_ \\=== Animal.prototype; // true\n\n* Методы родителя доступны через прототипную цепочку\n* Переопределение метода в подклассе просто добавляет метод в SubClass.prototype, скрывая метод родителя в цепочке\n\nПроверка цепочки\n\nconst dog \\= new Dog(\"Max\", \"Bulldog\");\n\ndog instanceof Dog;     // true\ndog instanceof Animal;  // true\n\nObject.getPrototypeOf(Dog.prototype) \\=== Animal.prototype; // true\n\n**Идеальная формулировка для собеседования**\n\nНаследование классов в JavaScript реализовано через цепочку прототипов. Подкласс может переопределить методы и конструктор родителя. Конструктор подкласса должен вызывать super(...) для инициализации родительской части. В методах super.method() позволяет вызвать метод родителя. Все методы хранятся в prototype, а цепочка instance.\\_\\_proto\\_\\_ → SubClass.prototype → SuperClass.prototype → Object.prototype → null обеспечивает поиск свойств и методов.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-pereopredelit-metody-klassa-kak-pereorpedelit-konstruktor-chto-takoe-super-kak-v-etom-uchastvuyut-prototipy"
    },
    {
        "id": 152,
        "title": "Что такое static? Могут ли быть класс, константа, функция статическими? Для чего это надо? (Статические свойства и методы)",
        "answer": "Что такое static\n\n* static — ключевое слово для объявления **методов или свойств**, которые **принадлежат классу**, а не экземпляру.\n* Такие методы/свойства **не доступны через this экземпляра**, только через сам класс.\n\nclass User {\nstatic description \\= \"This is a User class\";\nstatic greet() {\nconsole.log(\"Hello from User\");\n}\n}\n\nconsole.log(User.description); // \"This is a User class\"\nUser.greet();                 // \"Hello from User\"\n\nconst user \\= new User();\n// user.greet(); // Error: greet is not a function\n\nМогут ли быть класс, константа, функция статическими?\n\n* **Класс**: нет, нельзя объявить \"статический класс\" в JS — класс и так декларация.\n* **Константа внутри класса**: да, можно через static\n* **Метод функции**: да, метод класса можно сделать static\n\nПример с константой:\n\nclass MathHelper {\nstatic PI \\= 3.1415;\nstatic area(radius) {\nreturn MathHelper.PI \\* radius \\*\\* 2;\n}\n}\nconsole.log(MathHelper.area(2)); // 12.566\n\nДля чего нужны статические методы и свойства\n\nОсновные задачи:\n\n1. **Хелперы и утилиты**\n* Методы, которые не зависят от состояния экземпляра\n\nMath.max(1,2,3);\n\n2. **Константы класса**\n* Общие данные для всех экземпляров\n3. **Фабричные методы**\n* Создание экземпляров с определёнными настройками\n\nclass User {\nconstructor(name) { this.name \\= name; }\nstatic createAdmin(name) { return new User(name \\+ ' (admin)'); }\n}\n\nОсобенности\n\n* static метод **не наследует this экземпляра**, но может использовать super для обращения к статическим методам родителя:\nclass Parent {\nstatic greet() { console.log(\"Hi from Parent\"); }\n}\n\nclass Child extends Parent {\nstatic greet() {\nsuper.greet();\nconsole.log(\"Hi from Child\");\n}\n}\n\nChild.greet();\n// Hi from Parent\n// Hi from Child\n* Статические методы **часто используются как вспомогательные** и не требуют создания экземпляра.\n\nСравнение с методами экземпляра\n\n| Метод | Где хранится | Доступ через |\n| ----- | ----- | ----- |\n| Экземплярный | Class.prototype | instance.method() |\n| Статический | Class | Class.method() |\n\n**Идеальная формулировка для собеседования**\n\nСтатические методы и свойства объявляются с помощью ключевого слова static и принадлежат классу, а не экземплярам. Они используются для утилитарных функций, констант и фабричных методов. Экземпляр не имеет доступа к статическим методам через this. Статические методы могут наследоваться и использовать super для вызова методов родителя.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "chto-takoe-static-mogut-li-byt-klass-konstanta-funktsiya-staticheskimi-dlya-chego-eto-nado"
    },
    {
        "id": 153,
        "title": "Как указать что поле приватное/защищённое? Какие выгоды это даёт? (Приватные и защищённые методы и свойства)",
        "answer": "Как указать приватное поле или метод\n\nВ **современном JavaScript (ES2022+)** приватные поля и методы объявляются с **\\#**:\nclass User {\n\\#password; // приватное поле\nconstructor(name, password) {\nthis.name \\= name;   // публичное поле\nthis.\\#password \\= password;\n}\n\\#showPassword() {     // приватный метод\nconsole.log(this.\\#password);\n}\ncheckPassword(pass) {\nreturn this.\\#password \\=== pass;\n}\nrevealPassword() {\nthis.\\#showPassword();\n}\n}\n\nconst user \\= new User(\"Alex\", \"12345\");\nconsole.log(user.name); // Alex\n// console.log(user.\\#password); // Error\nuser.revealPassword(); // 12345\n\nОсобенности:\n\n1. Приватное поле **не доступно за пределами класса**\n2. Приватные методы могут вызываться только внутри класса\n3. Нельзя обращаться через this\\[\"\\#field\"\\] или user.\\#field извне\n\nЗащищённые поля (protected)\n\n* В чистом JS **нет полноценного protected**, как в других языках\n* **Конвенция**: использовать \\_ перед именем:\n\nclass User {\n\\_role \\= \"user\"; // условно защищённое\n}\n\nclass Admin extends User {\npromote() {\nconsole.log(this.\\_role); // доступно в наследнике\n}\n}\n\n* \\_field доступно извне, но считается **соглашением**, что его использовать напрямую не нужно.\n\nВыгоды приватных и защищённых полей\n\n1. **Инкапсуляция**\n* Скрываем внутреннее состояние объекта\n* Контролируем доступ к данным\n2. **Безопасность**\n* Исключаем случайное изменение важных свойств извне\n3. **Поддерживаемый API**\n* Публичные методы управляют доступом к внутренним данным\n4. **Читаемость и соглашения**\n* \\_field и \\#field показывают другим разработчикам, что поле внутреннее\n\nИспользование в наследовании\n\nclass User {\n\\#password \\= \"123\";\ngetPassword() { return this.\\#password; }\n}\n\nclass Admin extends User {\nshowPassword() {\n// console.log(this.\\#password); // Error, приватное не наследуется\nconsole.log(this.getPassword()); // можно через публичный метод\n}\n}\n\n* Приватные поля **не наследуются**, защищённые (\\_) доступны в подклассах\n\n**Идеальная формулировка для собеседования**\n\nПриватные поля и методы в JavaScript обозначаются символом \\# и доступны только внутри класса, что обеспечивает строгую инкапсуляцию и безопасность данных. Защищённые поля можно имитировать через соглашение \\_field, которое позволяет использовать их в подклассах. Преимущества: контроль доступа к данным, предотвращение случайного изменения, поддерживаемый API и читаемость кода.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-ukazat-chto-pole-privatnoe-zaschischennoe-kakie-vygody-eto-daet"
    },
    {
        "id": 154,
        "title": "Как происходит наследование статических методов? Middle Как расширить встроенный класс? Какое отличие наследования встроенных классов? (Расширение встроенных классов)",
        "answer": "Наследование статических методов\n\n* **Статические методы наследуются от родителя**, как и обычные методы, но через сам класс, а не через экземпляр.\n\nclass Parent {\nstatic greet() { console.log(\"Hello from Parent\"); }\n}\nclass Child extends Parent {}\nChild.greet(); // Hello from Parent\n\n* Можно **переопределить статический метод** в подклассе:\n\nclass Child extends Parent {\nstatic greet() {\nconsole.log(\"Hello from Child\");\n}\n}\n\nChild.greet(); // Hello from Child\nParent.greet(); // Hello from Parent\n\n* Цепочка статических методов работает через \\[\\[Prototype\\]\\] функции:\n\nObject.getPrototypeOf(Child) \\=== Parent; // true\n\nКак расширить встроенный класс\n\nВстроенные классы (Array, Map, Error, Date) **можно расширять через extends**:\nclass MyArray extends Array {\nfirst() {\nreturn this\\[0\\];\n}\n}\n\nconst arr \\= new MyArray(1, 2, 3);\nconsole.log(arr.first()); // 1\nconsole.log(arr instanceof MyArray); // true\nconsole.log(arr instanceof Array);   // true\n\n* Конструктор встроенного класса **нужно вызвать через super()**, иначе объект не создастся корректно:\n\nclass MyDate extends Date {\ngetYearMonth() {\nreturn \\`${this.getFullYear()}-${this.getMonth() \\+ 1}\\`;\n}\n}\nconst d \\= new MyDate(\"2026-01-03\");\nconsole.log(d.getYearMonth()); // 2026-1\n\nОсобенности наследования встроенных классов\n\n1. **Собственный внутренний объект**\n* Например, массив имеет внутренние свойства length и методы (push, pop)\n* Если наследовать через Object.create(Array.prototype) — нельзя, нужно extends Array \\+ super()\n2. **Методы встроенного класса работают корректно только через super()**\nclass MyArray extends Array {\nconstructor(...args) {\nsuper(...args); // иначе this не проинициализирован\n}\n}\n3. **Статические методы встроенных классов наследуются**\nclass MyDate extends Date {}\n\nconsole.log(MyDate.now() \\=== Date.now()); // true\n\n4. **Прототипы встроенных классов**\narr.\\_\\_proto\\_\\_ → MyArray.prototype → Array.prototype → Object.prototype → null\n\nMyArray.\\_\\_proto\\_\\_ → Array\n\nОтличие от обычного наследования\n\n| Параметр | Обычные классы | Встроенные классы |\n| ----- | ----- | ----- |\n| Вызов конструктора | super() в подклассе | super() обязателен для корректной инициализации внутреннего объекта |\n| Методы | Через прототип | Методы встроенного объекта работают на внутренних слотах (length, элементы массива) |\n| Статические методы | Наследуются через цепочку функции | Наследуются через цепочку функций, включая встроенные |\n| Инстансы | Простые объекты | Экземпляры встроенных классов имеют внутренние оптимизированные слоты и поведение |\n\n**Идеальная формулировка для собеседования**\n\nСтатические методы класса наследуются от родителя через цепочку \\[\\[Prototype\\]\\] функций и могут быть переопределены в подклассе. Встроенные классы (Array, Map, Date и т.д.) можно расширять через extends, но важно вызывать super() в конструкторе, чтобы корректно инициализировать внутренние слоты. Отличие от обычного наследования — встроенные объекты имеют внутренние свойства, специфические методы и оптимизации, поэтому наследование без extends не работает корректно.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-proishodit-nasledovanie-staticheskih-metodov-middle-kak-rasshirit-vstroennyy-klass-kakoe-otlichie-nasledovaniya-vstroennyh-klassov"
    },
    {
        "id": 155,
        "title": "Как проверить к какому классу принадлежит объект? Почему нельзя использовать typeOf? Как работает instanceOf ?( instanceOf)",
        "answer": "Как проверить, к какому классу принадлежит объект\n\n* Для проверки наследования и принадлежности к классу в JS используют **instanceof**:\n\nclass User {}\nclass Admin extends User {}\n\nconst admin \\= new Admin();\n\nconsole.log(admin instanceof Admin); // true\nconsole.log(admin instanceof User);  // true\nconsole.log(admin instanceof Object); // true\n\n* instanceof проверяет, **есть ли в цепочке прототипов объекта prototype функции-конструктора**.\n\nПочему нельзя использовать typeof для классов/объектов\n\n* typeof возвращает **тип данных**, а не класс или конструктор:\n\nconst obj \\= {};\nconsole.log(typeof obj); // \"object\"\n\nconst arr \\= \\[\\];\nconsole.log(typeof arr); // \"object\" — нельзя отличить массив от объекта\n\n* То есть typeof не подходит для проверки принадлежности к конкретному классу, только для примитивов:\n\n| Значение | typeof |\n| ----- | ----- |\n| 42 | \"number\" |\n| \"abc\" | \"string\" |\n| true | \"boolean\" |\n| null | \"object\" (особенность JS) |\n| undefined | \"undefined\" |\n| {} | \"object\" |\n| \\[\\] | \"object\" |\n| function | \"function\" |\n\nКак работает instanceof\n\nСинтаксис:\nobject instanceof Constructor\n\nМеханизм:\n\n1. Берём Constructor.prototype\n2. Идём по цепочке прототипов объекта (\\_\\_proto\\_\\_ / \\[\\[Prototype\\]\\])\n3. Если находим Constructor.prototype в цепочке → возвращаем true\n4. Если дошли до null — false\n\nconsole.log(Object.getPrototypeOf(admin) \\=== Admin.prototype); // true\nconsole.log(Object.getPrototypeOf(Object.getPrototypeOf(admin)) \\=== User.prototype); // true\n\nИменно поэтому:\n\nconst arr \\= \\[\\];\nconsole.log(arr instanceof Array);  // true\nconsole.log(arr instanceof Object); // true\n\n* instanceof учитывает **прототипное наследование**, не только прямое создание экземпляра.\n\nОсобенности и нюансы\n\n1. **Работает только для объектов**, не для примитивов напрямую\nconsole.log(42 instanceof Number); // false\nconsole.log(new Number(42) instanceof Number); // true\n2. **Можно переопределить поведение через Symbol.hasInstance**\nclass EvenNumber {\nstatic \\[Symbol.hasInstance\\](obj) {\nreturn typeof obj \\=== 'number' && obj % 2 \\=== 0;\n}\n}\nconsole.log(2 instanceof EvenNumber); // true\nconsole.log(3 instanceof EvenNumber); // false\n\n**Идеальная формулировка для собеседования**\n\nЧтобы проверить принадлежность объекта к классу, используют instanceof, который проверяет наличие Constructor.prototype в цепочке прототипов объекта. typeof нельзя использовать для этого, так как он возвращает только тип данных (object, function, string и т.д.) и не различает конкретные классы. instanceof учитывает наследование: если объект был создан через подкласс, instanceof вернёт true для родительского класса.",
        "category": "Objects & Classes",
        "difficulty": "Medium",
        "slug": "kak-proverit-k-kakomu-klassu-prinadlezhit-ob-ekt-pochemu-nel-zya-ispol-zovat-typeof-kak-rabotaet-instanceof"
    },
    {
        "id": 156,
        "title": "Как вынести общую логику между классами?(Примеси)",
        "answer": "Что такое примесь (mixin)\n\n**Примесь** — это способ **переиспользовать общую функциональность между классами**, без использования наследования.\n\n* Идея: берём **объект или функцию**, содержащую методы, и «подмешиваем» их в класс.\n* Применяется, когда **классы должны делить поведение**, но **не находятся в иерархии**.\n\nПростейший пример примеси\n\nconst CanEat \\= {\neat() {\nconsole.log(\\`${this.name} is eating\\`);\n}\n};\nconst CanWalk \\= {\nwalk() {\nconsole.log(\\`${this.name} is walking\\`);\n}\n};\nclass Person {\nconstructor(name) {\nthis.name \\= name;\n}\n}\n\n// Подмешиваем методы\nObject.assign(Person.prototype, CanEat, CanWalk);\n\nconst john \\= new Person(\"John\");\njohn.eat();  // John is eating\njohn.walk(); // John is walking\n\n* Object.assign копирует методы из объекта в prototype класса\n* Методы становятся доступными экземплярам\n\nПримеси через функции\n\nМожно сделать **фабрику примеси**, которая принимает класс и возвращает расширенный класс:\nconst CanFly \\= (Base) \\=\\> class extends Base {\nfly() {\nconsole.log(\\`${this.name} is flying\\`);\n}\n};\nclass Animal {\nconstructor(name) { this.name \\= name; }\n}\nclass Bird extends CanFly(Animal) {}\nconst eagle \\= new Bird(\"Eagle\");\neagle.fly(); // Eagle is flying\n\n* Такой подход **поддерживает цепочку наследования**, одновременно добавляя функциональность\n\nПочему примеси полезны\n\n1. **Переиспользование кода** без дублирования\n2. **Композиция вместо наследования**\n* Можно комбинировать функциональность из нескольких источников\n3. **Гибкость**\n* Не нужно строить сложную иерархию классов\n\nОграничения и нюансы\n\n* Конфликты имен методов — последний в Object.assign перекрывает предыдущий\n* Сложно отследить, откуда пришёл метод при больших примесях\n* Статические методы тоже можно миксовать, но через Object.assign(Class, mixin)\n\n**Идеальная формулировка для собеседования**\n\nПримесь (mixin) — это способ вынести общую логику между классами без наследования. Обычно реализуется через объект или функцию, содержащую методы, которые затем «подмешиваются» в prototype класса с помощью Object.assign или через расширение класса через фабричную функцию. Примеси позволяют переиспользовать функциональность, комбинировать поведение нескольких источников и избегать жёсткой иерархии наследования.\n\n# Обработка ошибок\n\n1. Как обрабатывать ошибки? Как создать свою собственную ошибку? Как выполнить код после try и catch? Какие данные об ошибке мы можем получить? Какие есть глобальные обработчики ошибок ? (try catch)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-vynesti-obschuyu-logiku-mezhdu-klassami"
    },
    {
        "id": 157,
        "title": "Как обрабатывать ошибки? Как создать свою собственную ошибку? Как выполнить код после try и catch? Какие данные об ошибке мы можем получить? Какие есть глобальные обработчики ошибок ? (try catch)",
        "answer": "Как обрабатывать ошибки\n\nВ JavaScript для обработки ошибок используется конструкция **try...catch...finally**:\ntry {\n// Код, который может вызвать ошибку\nconst result \\= riskyOperation();\nconsole.log(result);\n} catch (error) {\n// Блок обработки ошибок\nconsole.error(\"Произошла ошибка:\", error.message);\n} finally {\n// Код, который выполнится в любом случае\nconsole.log(\"Блок finally выполнен\");\n}\n\n* **try** — выполняется код, который может выбросить исключение\n* **catch** — ловит ошибку и предоставляет объект ошибки\n* **finally** — выполняется всегда, независимо от того, была ошибка или нет\n\nКак создать собственную ошибку\n\nМожно создать **пользовательскую ошибку**, наследуя стандартный класс Error:\nclass ValidationError extends Error {\nconstructor(message) {\nsuper(message);  // устанавливает message\nthis.name \\= \"ValidationError\"; // имя ошибки\n}\n}\nfunction validateAge(age) {\nif (age \\< 0\\) throw new ValidationError(\"Возраст не может быть отрицательным\");\n}\ntry {\nvalidateAge(-5);\n} catch (err) {\nconsole.error(err.name, \"-\", err.message); // ValidationError \\- Возраст не может быть отрицательным\n}\n\nКакие данные об ошибке доступны\n\nВ объекте ошибки (Error) есть несколько полезных свойств:\n\n| Свойство | Описание |\n| ----- | ----- |\n| message | Сообщение об ошибке |\n| name | Имя ошибки (Error, TypeError, ReferenceError, пользовательское) |\n| stack | Стек вызовов (где произошла ошибка) |\n\nПример:\ntry {\nthrow new Error(\"Что-то пошло не так\");\n} catch (err) {\nconsole.log(err.message); // Что-то пошло не так\nconsole.log(err.name);    // Error\nconsole.log(err.stack);   // Стек вызовов\n}\n\nГлобальные обработчики ошибок\n\n1.  Для браузера\n* window.onerror — ловит необработанные ошибки\n\nwindow.onerror \\= function(message, source, lineno, colno, error) {\n\nconsole.log(\"Глобальная ошибка:\", message);\n\n};\n\n* window.onunhandledrejection — ловит необработанные промисы\n\nwindow.onunhandledrejection \\= function(event) {\n\nconsole.log(\"Необработанный промис:\", event.reason);\n\n};\n\n2.  Для Node.js\n* process.on(\"uncaughtException\", handler) — необработанные ошибки\n* process.on(\"unhandledRejection\", handler) — необработанные промисы\n\n**Идеальная формулировка для собеседования**\n\nВ JavaScript ошибки обрабатываются через try...catch...finally. try выполняет потенциально опасный код, catch ловит исключение и предоставляет объект ошибки с полями message, name, stack. finally выполняется всегда. Можно создавать собственные ошибки через наследование Error. Для глобальной обработки ошибок существуют window.onerror и window.onunhandledrejection в браузере, а в Node.js — события uncaughtException и unhandledRejection. Это позволяет централизованно логировать и управлять ошибками в приложении.\n\n#\n\n# Промисы\n\n1. Что такое callback? Как обрабатывать ошибки? Как вызвать callback внутри callback? Есть ли недостатки?( Callback)\n2. Что такое Promise? Какие два состояния могут быть? Могут ли сработать оба состояния одновременно? Что делают resolve и reject? Как работать с результатом работы промиса? (Promise, Цепочка промисов)\n3. Как обрабатываются ошибки внутри промисов? Что будет если поставить then после catch? Что будет если не поставить catch? Второй аргуметр у then. (Промисы: обработка ошибок)\n4. all, allSettled, any, race, resolve, reject (Promise API)\n5. Что такое async/await? В каких функциях можно использовать await? Можно использовать await глобально? Как работает await с успешным\\\\отклоненым промисом? (async/await)\n\n1\\. Что такое callback? Как обрабатывать ошибки? Как вызвать callback внутри callback? Есть ли недостатки?( Callback)\n\nЧто такое callback\n\n**Callback** — это функция, которая передаётся другой функции **для выполнения после завершения какой-либо операции**.\n\nПример:\nfunction fetchData(callback) {\nsetTimeout(() \\=\\> {\nconst data \\= { id: 1, name: \"John\" };\ncallback(data);\n}, 1000);\n}\nfetchData((result) \\=\\> {\nconsole.log(\"Полученные данные:\", result);\n});\n\n* Часто используются для асинхронных операций: чтение файла, HTTP-запросы, таймеры\n\nКак обрабатывать ошибки в callback\nВ классическом стиле Node.js используется **первый аргумент callback — ошибка**:\nfunction fetchData(callback) {\nsetTimeout(() \\=\\> {\nconst error \\= false;\nif (error) {\ncallback(new Error(\"Произошла ошибка\"));\n} else {\ncallback(null, { id: 1, name: \"John\" });\n}\n}, 1000);\n}\nfetchData((err, data) \\=\\> {\nif (err) {\nconsole.error(\"Ошибка:\", err.message);\n} else {\nconsole.log(\"Данные:\", data);\n}\n});\n\n* Принцип: callback(error, result)\n* Если ошибка есть — обрабатываем, иначе используем результат\n\nВызов callback внутри callback (Callback Hell)\n\nКогда нужно выполнить несколько последовательных асинхронных операций:\ngetData((err, data) \\=\\> {\nif (err) return console.error(err);\nprocessData(data, (err, processed) \\=\\> {\nif (err) return console.error(err);\nsaveData(processed, (err, saved) \\=\\> {\nif (err) return console.error(err);\nconsole.log(\"Готово:\", saved);\n});\n});\n});\n\n* Это приводит к **«пирамиде судьбы» (Callback Hell)**:\n* Код становится сложно читаемым\n* Трудно обрабатывать ошибки глобально\n* Сложно отлаживать\n\nНедостатки callback\n\n1. **Трудночитаемый код при сложных цепочках**\n2. **Сложность обработки ошибок** — нужно проверять каждый callback\n3. **Нет гарантии последовательного выполнения без вложенности**\n4. **Легко забыть вызвать callback** → «висящие» операции\n\n**Итоговая формулировка для собеседования**\n\nCallback — это функция, передаваемая другой функции для выполнения после завершения операции. Ошибки обрабатываются через первый аргумент callback (callback(err, result)). Несколько последовательных callback-ов вызывают «Callback Hell», который снижает читаемость и усложняет обработку ошибок. Основные недостатки: трудно читать, сложно обрабатывать ошибки и управлять последовательностью выполнения.\n\n2\\. Что такое Promise? Какие два состояния могут быть? Могут ли сработать оба состояния одновременно? Что делают resolve и reject? Как работать с результатом работы промиса? (Promise, Цепочка промисов)\n\nЧто такое Promise\n\n**Promise** — это объект, который представляет **результат асинхронной операции, который может быть доступен в будущем**.\n\n* Позволяет избежать «callback hell»\n* Упрощает чтение и обработку ошибок\n\nСинтаксис создания:\n\nconst promise \\= new Promise((resolve, reject) \\=\\> {\n// Асинхронная операция\nconst success \\= true;\nif (success) {\nresolve(\"Данные получены\");\n} else {\nreject(\"Произошла ошибка\");\n}\n});\n\nСостояния Promise\n\nPromise может быть в одном из **трёх состояний**:\n\n1. **Pending (ожидание)** — операция ещё не завершена\n2. **Fulfilled (выполнен)** — успешно завершена, вызывается resolve\n3. **Rejected (отклонён)** — завершена с ошибкой, вызывается reject\n* **Нельзя находиться сразу в двух состояниях**\n* Как только промис завершён (fulfilled или rejected), состояние становится **финальным** и не меняется\n\nresolve и reject\n\n* **resolve(value)** — сообщает, что промис успешно завершён, и передаёт результат\n* **reject(reason)** — сообщает, что промис завершён с ошибкой, и передаёт причину ошибки\n\nПример:\nconst promise \\= new Promise((resolve, reject) \\=\\> {\nsetTimeout(() \\=\\> {\nconst success \\= Math.random() \\> 0.5;\nsuccess ? resolve(\"OK\") : reject(\"Ошибка\");\n}, 1000);\n});\n\nРабота с результатом промиса\n\nИспользуются методы:\n\n1. **.then()** — для обработки успешного результата (resolve)\n2. **.catch()** — для обработки ошибки (reject)\n3. **.finally()** — выполняется в любом случае\n\npromise\n.then((data) \\=\\> {\nconsole.log(\"Результат:\", data);\nreturn data \\+ \" обработано\";\n})\n.then((newData) \\=\\> {\nconsole.log(\"Новый результат:\", newData);\n})\n.catch((err) \\=\\> {\nconsole.error(\"Ошибка:\", err);\n})\n.finally(() \\=\\> {\nconsole.log(\"Промис завершён\");\n});\n\n* Можно строить **цепочку промисов**: результат одного .then() передаётся следующему\n* Ошибки, выброшенные в любом .then(), попадут в .catch()\n\n**Идеальная формулировка для собеседования**\n\n**Promise** — это объект, который представляет результат асинхронной операции в будущем. Он может находиться в состоянии **pending, fulfilled или rejected**. После перехода в fulfilled или rejected состояние становится финальным. resolve сообщает об успешном завершении промиса, reject — о завершении с ошибкой. Для работы с результатом используют .then() (успех), .catch() (ошибка) и .finally() (выполняется всегда). Цепочка .then() позволяет последовательно обрабатывать результаты нескольких асинхронных операций, улучшая читаемость и управляемость кода по сравнению с callback.\n\n3\\. Как обрабатываются ошибки внутри промисов? Что будет если поставить then после catch? Что будет если не поставить catch? Второй аргуметр у then. (Промисы: обработка ошибок)\n\nОбработка ошибок в промисах (Promise Error Handling)\n\n1.  Ошибки внутри промисов\n\nОшибки могут возникать:\n**1.1. Явно через reject()**:\nconst promise \\= new Promise((resolve, reject) \\=\\> {\nreject(\"Ошибка произошла\");\n});\n**1.2. Неявно через throw внутри executor или .then()**:\nconst promise \\= new Promise((resolve) \\=\\> {\nthrow new Error(\"Ошибка внутри промиса\");\n});\n\n* Любая ошибка переводит промис в состояние **rejected**\n* Можно обработать через **.catch()** или второй аргумент .then()\n2.  Обработка ошибок\n\n2.1. Через .catch()\npromise\n.then((data) \\=\\> console.log(\"Success:\", data))\n.catch((err) \\=\\> console.error(\"Ошибка:\", err.message));\n\n* .catch() ловит:\n* reject()\n* Исключения, выброшенные внутри промисов или .then()\n* После .catch() промис считается **успешно завершённым**, можно продолжать цепочку .then():\n\nPromise.reject(\"Ошибка\")\n\n.catch(err \\=\\> {\n\nconsole.log(err); // \"Ошибка\"\n\nreturn \"Исправлено\";\n\n})\n\n.then(res \\=\\> console.log(res)); // \"Исправлено\"\n\n2.2 Второй аргумент у .then()\n\npromise.then(\ndata \\=\\> console.log(\"Success\", data),\nerr \\=\\> console.error(\"Ошибка:\", err)\n);\n\n* Второй аргумент .then() **ловит reject**, но **не ловит ошибки, выброшенные внутри первого колбэка**:\n\nPromise.resolve()\n\n.then(() \\=\\> { throw new Error(\"Ошибка\"); }, err \\=\\> console.log(\"Не сработает\"))\n\n.catch(err \\=\\> console.log(\"Поймали:\", err.message)); // Поймали: Ошибка\n\n* Поэтому обычно рекомендуют использовать .catch() вместо второго аргумента .then()\n2.3 Что будет, если не поставить .catch()\n* Ошибка в промисе **станет необработанной**\n* В браузере: вызовется unhandledrejection событие\n* В Node.js: вызовется process.on('unhandledRejection')\n* Это считается плохой практикой — ошибки могут «теряться»\n\nPromise.reject(\"Ошибка без catch\");\n\n3\\. Принцип работы цепочки промисов\n\n* Если ошибка произошла в .then(), она **передаётся вниз по цепочке**, пока не встретит .catch()\n* После .catch() промис считается **разрешённым**, цепочка продолжается с результатом .catch()\n\nPromise.resolve()\n.then(() \\=\\> { throw new Error(\"Ошибка 1\"); })\n.catch(err \\=\\> {\nconsole.log(err.message); // \"Ошибка 1\"\nreturn \"Исправлено\";\n})\n.then(res \\=\\> console.log(res)); // \"Исправлено\"\n\n**Идеальная формулировка для собеседования**\n\nОшибки в промисах обрабатываются через .catch() или второй аргумент .then(). Любая ошибка (reject или throw) переводит промис в состояние **rejected**. Если .catch() отсутствует, ошибка считается необработанной и может вызвать глобальные события unhandledRejection. После .catch() промис считается успешным, и цепочка .then() продолжается. Второй аргумент у .then() ловит только reject, но не ошибки внутри колбэка .then(). Рекомендуется использовать .catch() для надёжной обработки ошибок.\n\n4\\. all, allSettled, any, race, resolve, reject (Promise API)\n\nPromise API\nJavaScript предоставляет несколько встроенных методов для работы с множеством промисов:\n\n1\\. Promise.all(iterable)\n\n* Принимает **массив промисов**\n* Возвращает новый промис, который:\n* **resolved**, когда **все промисы успешно завершились**, с массивом результатов\n* **rejected**, если хотя бы один промис завершился с ошибкой, с первым reject\n* Используется для **параллельного выполнения нескольких операций**\n\nconst p1 \\= Promise.resolve(1);\nconst p2 \\= Promise.resolve(2);\nconst p3 \\= Promise.resolve(3);\n\nPromise.all(\\[p1, p2, p3\\])\n.then(results \\=\\> console.log(results)) // \\[1, 2, 3\\]\n.catch(err \\=\\> console.error(err));\n2\\. Promise.allSettled(iterable)\n\n* Возвращает новый промис, который **всегда выполняется**, когда все промисы завершены, **независимо от результата**\n* Результат — массив объектов {status: 'fulfilled' | 'rejected', value?, reason?}\n\nconst p1 \\= Promise.resolve(1);\nconst p2 \\= Promise.reject(\"Ошибка\");\nPromise.allSettled(\\[p1, p2\\])\n.then(results \\=\\> console.log(results));\n/\\* \\[\n{ status: \"fulfilled\", value: 1 },\n{ status: \"rejected\", reason: \"Ошибка\" }\n\\]\\*/\n\n* Полезно, если нужны результаты всех операций, даже если некоторые упали\n\n3\\. Promise.race(iterable)\n\n* Возвращает **промис, который выполнится или отклонится первым из переданных**\n* Используется для **таймаутов** или выбора самого быстрого промиса\n\nconst p1 \\= new Promise(res \\=\\> setTimeout(() \\=\\> res(1), 1000));\nconst p2 \\= new Promise(res \\=\\> setTimeout(() \\=\\> res(2), 500));\nPromise.race(\\[p1, p2\\]).then(console.log); // 2\n4\\. Promise.any(iterable)\n\n* Возвращает промис, который **resolved при первом успешном промисе**\n* Если **все промисы завершились с reject**, возвращает AggregateError\n\nconst p1 \\= Promise.reject(\"Ошибка1\");\nconst p2 \\= Promise.resolve(2);\nconst p3 \\= Promise.resolve(3);\nPromise.any(\\[p1, p2, p3\\]).then(console.log); // 2\n\n* Полезно, если нужен **любой успешный результат**, не обязательно первый\n\n5\\. Promise.resolve(value)\n\n* Создаёт **уже выполненный промис** с переданным значением\n* Если аргумент уже промис, возвращает его без изменений\n\nPromise.resolve(5).then(console.log); // 5\n6\\. Promise.reject(reason)\n\n* Создаёт **уже отклонённый промис** с указанной причиной\n\nPromise.reject(\"Ошибка\").catch(console.log); // \"Ошибка\"\n\n**Идеальная формулировка для собеседования**\n\n**Promise API** предоставляет методы для работы с множеством промисов.\n\n* Promise.all ждёт завершения всех промисов, но отклоняется при любой ошибке.\n* Promise.allSettled ждёт всех промисов и возвращает массив статусов независимо от успеха или ошибки.\n* Promise.race возвращает результат **первого завершившегося промиса**.\n* Promise.any возвращает результат **первого успешно завершившегося промиса**, и выбрасывает AggregateError, если все промисы отклонены.\n* Promise.resolve создаёт уже выполненный промис, Promise.reject — отклонённый.\nЭти методы позволяют управлять параллельными и конкурентными асинхронными операциями, обрабатывать ошибки централизованно и строить гибкие цепочки промисов.\n\n5\\. Что такое async/await? В каких функциях можно использовать await? Можно использовать await глобально? Как работает await с успешным\\\\отклоненым промисом? (async/await)\n\nЧто такое async/await\n\n* **async** — ключевое слово перед функцией, которое **делает её асинхронной**\n* Функция всегда возвращает **промис**\n* Если функция возвращает значение — промис **fulfilled** с этим значением\n* Если функция выбрасывает ошибку — промис **rejected** с этой ошибкой\n* **await** — ключевое слово для **ожидания выполнения промиса**\n* Позволяет писать асинхронный код в **синхронном стиле**\n* Работает только внутри **async-функций**\n\nПример:\nasync function fetchData() {\nconst data \\= await getDataFromAPI(); // ждем промис\nconsole.log(data);\n}\n\n* Внутри await можно использовать **любой объект, который реализует промисоподобный интерфейс (then)**\n\nГде можно использовать await\n\n* **Только внутри async функции**:\n\nasync function example() {\nconst result \\= await Promise.resolve(42);\nconsole.log(result);\n}\n\n* **Нельзя использовать глобально** (в старых версиях JS, кроме модулей ES)\n* В ES-модулях Node.js и современных браузерах глобальный await разрешён\n\nКак работает await с промисом\n\n1.  Успешный промис (fulfilled)\nasync function test() {\nconst result \\= await Promise.resolve(10);\nconsole.log(result); // 10\n}\n* await **«разворачивает» промис**, возвращая значение, которое он resolved\n2.  Отклонённый промис (rejected)\nasync function test() {\ntry {\nconst result \\= await Promise.reject(new Error(\"Ошибка\\!\"));\n} catch (err) {\nconsole.error(err.message); // Ошибка\\!\n}\n}\n* Если промис rejected — await **генерирует исключение**, которое можно поймать через try/catch\n\nОсобенности и рекомендации\n\n1. await **останавливает выполнение текущей async-функции**, но **не блокирует весь поток** (не замораживает Event Loop)\n2. Можно использовать несколько await последовательно:\nasync function getAllData() {\nconst a \\= await fetchA();\nconst b \\= await fetchB();\nreturn a \\+ b;\n}\n* Если нужно **параллельное выполнение** — лучше использовать Promise.all:\nconst \\[a, b\\] \\= await Promise.all(\\[fetchA(), fetchB()\\]);\n3. Все ошибки в async-функции можно ловить через один try/catch:\nasync function example() {\ntry {\nconst data \\= await fetchData();\nconsole.log(data);\n} catch (err) {\nconsole.error(\"Ошибка:\", err);\n}\n}\n\n**Идеальная формулировка для собеседования**\n\nasync/await — синтаксический сахар над промисами, позволяющий писать асинхронный код в **синхронном стиле**. async делает функцию возвращающей промис, await приостанавливает выполнение функции до завершения промиса. await работает только внутри async функций, глобальный await разрешён в ES-модулях. При успешном промисе await возвращает значение, при отклонённом — выбрасывает исключение, которое можно обработать через try/catch. Рекомендуется использовать Promise.all для параллельного выполнения нескольких промисов.\n\n# Генераторы\n\n1. Зачем нужны генераторы? Какие методы генераторов? Где они используются? (Генераторы)\n2. Какие отличия от обычных? (Асинхронные итераторы и генераторы)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-obrabatyvat-oshibki-kak-sozdat-svoyu-sobstvennuyu-oshibku-kak-vypolnit-kod-posle-try-i-catch-kakie-dannye-ob-oshibke-my-mozhem-poluchit-kakie-est-global-nye-obrabotchiki-oshibok"
    },
    {
        "id": 158,
        "title": "Зачем нужны генераторы? Какие методы генераторов? Где они используются? (Генераторы)",
        "answer": "Что такое генератор\n\n* Генератор — это **специальная функция**, выполнение которой можно **приостанавливать и возобновлять**.\n* Объявляется с помощью function\\* и использует yield для выдачи значений.\n* При вызове генератор **не выполняется полностью**, а возвращает **итератор**.\n\nПример:\nfunction\\* numbers() {\nyield 1;\nyield 2;\nyield 3;\n}\n\nconst gen \\= numbers();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\nЗачем нужны генераторы\n\nГенераторы позволяют:\n\n1. **Создавать ленивые последовательности (lazy evaluation)**\n* Не нужно заранее генерировать весь массив, можно выдавать элементы по мере необходимости\n2. **Обрабатывать большие или бесконечные потоки данных**\n3. **Реализовывать итераторы вручную**\n4. **Упрощать асинхронный код** (раньше генераторы с yield использовали для асинхронного программирования до появления async/await)\n\nПример ленивого диапазона:\n\nfunction\\* range(start, end) {\nfor (let i \\= start; i \\<= end; i++) {\nyield i;\n}\n}\nfor (const n of range(1, 5)) {\nconsole.log(n); // 1 2 3 4 5\n}\nМетоды генераторов\n\nГенератор возвращает **итератор**, у которого есть методы:\n\n1. **next(value?)**\n* Продвигает генератор до следующего yield\n* Можно передавать значение, которое возвращается внутри генератора\n2. **throw(error)**\n* Позволяет **вбросить исключение внутрь генератора** в месте последнего yield\n3. **return(value?)**\n* Преждевременно завершает генератор\n* Возвращает объект { value, done: true }\n\nПример:\nfunction\\* gen() {\ntry {\nyield 1;\nyield 2;\n} catch (e) {\nconsole.log(\"Поймана ошибка:\", e);\n}\n}\nconst g \\= gen();\nconsole.log(g.next());         // { value: 1, done: false }\nconsole.log(g.throw(\"Ошибка\")); // Поймана ошибка: Ошибка\nconsole.log(g.next());         // { value: undefined, done: true }\n\nГде используются генераторы\n\n1. **Ленивые коллекции и последовательности**\n* Генерация диапазонов, потоков данных, бесконечных последовательностей\n2. **Итераторы и кастомные объекты с Symbol.iterator**\n3. **Асинхронное программирование** (раньше, до async/await)\n4. **Обработка больших данных**, когда не хочется хранить всё в памяти\n\nПример бесконечного генератора:\nfunction\\* idGenerator() {\nlet id \\= 1;\nwhile (true) {    yield id++;  }\n}\nconst ids \\= idGenerator();\nconsole.log(ids.next().value); // 1\nconsole.log(ids.next().value); // 2\n\n* Здесь память не расходуется на хранение всех значений, генератор выдаёт их по требованию.\n\n**Идеальная формулировка для собеседования**\n\nГенератор — это функция, выполнение которой можно приостанавливать и возобновлять с помощью yield. Возвращает итератор с методами next(), throw() и return(). Генераторы полезны для ленивой генерации последовательностей, создания бесконечных потоков данных, реализации кастомных итераторов и упрощения асинхронного кода. Они позволяют экономить память и управлять вычислениями по мере необходимости.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "zachem-nuzhny-generatory-kakie-metody-generatorov-gde-oni-ispol-zuyutsya"
    },
    {
        "id": 159,
        "title": "Какие отличия от обычных? (Асинхронные итераторы и генераторы)",
        "answer": "",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-otlichiya-ot-obychnyh"
    },
    {
        "id": 160,
        "title": "Асинхронные генераторы и итераторы (Async Generators / Async Iterators)",
        "answer": "Отличие от обычных генераторов\n\n| Характеристика | Обычные генераторы (function\\*) | Асинхронные генераторы (async function\\*) |\n| ----- | ----- | ----- |\n| Тип возвращаемого значения | Синхронный итератор (Iterator) | Асинхронный итератор (AsyncIterator) |\n| Метод next() | Возвращает { value, done } | Возвращает промис { value, done } |\n| Поддержка await внутри | Нет | Да — можно await асинхронные операции |\n| Использование в цикле | for...of | for await...of |\n| Применение | Синхронные последовательности | Асинхронные потоки данных (API, таймеры, БД) |\n\nСинтаксис\n\nasync function\\* asyncGen() {\nconst urls \\= \\[\"url1\", \"url2\"\\];\nfor (const url of urls) {\nconst data \\= await fetch(url).then(res \\=\\> res.json()); // await внутри генератора\nyield data;\n}\n}\n(async () \\=\\> {\nfor await (const item of asyncGen()) {\nconsole.log(item);\n}\n})();\n\n* async function\\* — ключевое слово для **асинхронного генератора**\n* yield — выдаёт значения **асинхронно**, возвращая **промис**\n* Цикл for await...of **ждёт завершения промиса**, прежде чем перейти к следующему значению\n\nПрименение\n\n1. **Постепенная обработка больших потоков данных с асинхронными операциями**\n* API-запросы, чтение файлов, WebSocket-сообщения\n2. **Комбинация с асинхронными итераторами** для ленивой загрузки\n3. **Экономия памяти**: не нужно хранить весь массив результатов\n\nПример с API:\nasync function\\* fetchPages(pages) {\nfor (let i \\= 1; i \\<= pages; i++) {\nconst data \\= await fetch(\\`https://api.example.com/page/${i}\\`).then(r \\=\\> r.json());\nyield data;\n}\n}\n(async () \\=\\> {\nfor await (const page of fetchPages(5)) {\nconsole.log(page);\n}\n})();\n\nМетоды асинхронных генераторов\n\n* **next()** → возвращает **промис** { value, done }\n* **return(value?)** → завершает генератор, возвращая промис\n* **throw(error)** → выбрасывает ошибку внутрь генератора, возвращает промис\n\nconst ag \\= asyncGen();\nag.next().then(console.log); // { value: {...}, done: false }\n\nОтличие в обработке ошибок\n\n* Ошибки внутри асинхронного генератора **оборачиваются в rejected промис**, их можно ловить через .catch() или try/catch внутри for await...of\n\n(async () \\=\\> {\ntry {\nfor await (const item of asyncGen()) {\nconsole.log(item);\n}\n} catch (err) {\nconsole.error(\"Ошибка генератора:\", err);\n}\n})();\n\nИдеальная формулировка для собеседования\n\nАсинхронный генератор (async function\\*) — это генератор, который может выполнять асинхронные операции внутри и выдавать значения через yield в виде промисов. В отличие от обычных генераторов, методы next(), return(), throw() возвращают **промисы**, а для итерации используется for await...of. Асинхронные генераторы применяются для ленивой загрузки данных, обработки больших или бесконечных потоков с асинхронными операциями, экономя память и улучшая читаемость кода.\n\n#\n\n# Общее (память\\\\событийный цикл)\n\n1. Как JavaScript понимает, что пора очищать память? Принцип достижимости (Сборка мусора)\n2. В чем отличие от обычных Map и Set ? Для чего нужны ? (WeakMap и WeakSet)\n3. Что такое микрозадачи? Как работает очередь микрозадач? (Микрозадачи)\n4. В каком порядке выполняются задачи? Какие отличия микрозадач от макрозадач? (Событийный цикл)",
        "category": "Async",
        "difficulty": "Medium",
        "slug": "asinhronnye-generatory-i-iteratory"
    },
    {
        "id": 161,
        "title": "Как JavaScript понимает, что пора очищать память? Принцип достижимости (Сборка мусора)",
        "answer": "Как JavaScript понимает, что пора очищать память\n\nJavaScript использует **автоматическую сборку мусора (Garbage Collection)**.\nРазработчик **не управляет памятью вручную** — движок (V8, SpiderMonkey и др.) сам решает, когда объект можно удалить.\nОсновной принцип — **достижимость (reachability)**.\n\nПринцип достижимости (Reachability)\n\n**Значение считается достижимым, если к нему можно получить доступ из “корней” (roots).**\nКорни (roots):\n\n* Глобальные переменные\n* Локальные переменные текущих функций\n* Параметры функций\n* Переменные, находящиеся в замыканиях\n* Объекты, на которые есть ссылки из других достижимых объектов\n\nПример:\n\nlet user \\= {\nname: \"Alex\"\n};\n\n* user достижим → объект в памяти\n\nuser \\= null;\n\n* Ссылка удалена\n* Объект \"Alex\" **становится недостижимым**\n* Сборщик мусора может удалить его\n\nКак работает сборщик мусора (упрощённо)\n\nАлгоритм Mark-and-Sweep (используется в современных движках):\n\n1. Движок помечает все **достижимые объекты**\n2. Все непомеченные считаются **мусором**\n3. Память освобождается\n\nКорни → достижимые объекты → помечены\nНедостижимые → удалены\n\nСвязь с событиями и асинхронностью\n\nОбъекты **не удаляются**, пока:\n\n* на них есть ссылка\n* они участвуют в замыкании\n* на них ссылается callback таймера / события\n\nПример утечки памяти:\n\nlet hugeData \\= new Array(1e6);\nsetTimeout(() \\=\\> {\nconsole.log(hugeData);\n}, 10000);\n\n* hugeData **не будет удалён**, пока таймер не выполнится\n* потому что callback удерживает ссылку\n\nЧастые причины утечек памяти\n\n1. **Глобальные переменные**\n\ndata \\= { big: true }; // без let/const\n\n2. **Замыкания**\nfunction createHandler() {\nconst big \\= new Array(1e6);\nreturn () \\=\\> console.log(big);\n\n}\n\n3. **Неочищенные таймеры и подписки**\n\nsetInterval(() \\=\\> {}, 1000); // без clearInterval\n\n4. **DOM-ссылки**\n\nlet el \\= document.getElementById(\"app\");\n// если элемент удалён из DOM, но ссылка осталась → утечка\n\nЧто НЕ удаляется сборщиком мусора\n\n* Объекты, на которые есть хотя бы **одна активная ссылка**\n* Данные, используемые в текущем стеке выполнения\n* Данные, захваченные замыканиями\n\n**Идеальная формулировка для собеседования**\n\nJavaScript использует автоматическую сборку мусора на основе принципа достижимости. Значение считается достижимым, если к нему можно получить доступ из корней — глобальных переменных, локальных переменных функций или замыканий. Современные движки используют алгоритм mark-and-sweep: сначала помечают все достижимые объекты, затем удаляют недостижимые. Объекты не очищаются, пока на них есть ссылки, например из замыканий, таймеров или обработчиков событий, что может приводить к утечкам памяти.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-javascript-ponimaet-chto-pora-ochischat-pamyat-printsip-dostizhimosti"
    },
    {
        "id": 162,
        "title": "В чем отличие от обычных Map и Set ? Для чего нужны ? (WeakMap и WeakSet)",
        "answer": "Что такое WeakMap и WeakSet\n\n**WeakMap** и **WeakSet** — это специальные коллекции, которые хранят **слабые ссылки** на объекты.\n\n* Они **не мешают сборщику мусора** удалять объекты\n* Используются для хранения **вспомогательных, “привязанных” к объекту данных**\n\nОтличие от обычных Map и Set\n\n1 Map vs WeakMap\n\n| Характеристика | Map | WeakMap |\n| ----- | ----- | ----- |\n| Тип ключей | Любые (примитивы и объекты) | **Только объекты** |\n| Удерживает объект в памяти | Да | **Нет (слабая ссылка)** |\n| Итерация (keys, values) | Да | ❌ Нет |\n| size | Есть | ❌ Нет |\n| Использование GC | Ключи мешают GC | **GC может удалить ключи** |\n\nlet obj \\= {};\nconst map \\= new Map();\nmap.set(obj, \"data\");\n\nobj \\= null;\n// объект НЕ удалится, пока есть map\n\nlet obj \\= {};\nconst wmap \\= new WeakMap();\nwmap.set(obj, \"data\");\n\nobj \\= null;\n// объект может быть удалён сборщиком мусора\n\n2 Set vs WeakSet\n\n| Характеристика | Set | WeakSet |\n| ----- | ----- | ----- |\n| Тип значений | Любые | **Только объекты** |\n| Итерация | Да | ❌ Нет |\n| Хранит сильную ссылку | Да | **Слабая ссылка** |\n\nПочему WeakMap / WeakSet нельзя перебирать\n\n* Ключ или значение **может быть удалено GC в любой момент**\n* Итерация была бы **недетерминированной**\n* Поэтому:\n* нет forEach\n* нет keys(), values()\n* нет size\n\nДля чего нужны WeakMap и WeakSet\n\n1 Хранение приватных данных\n\nconst privateData \\= new WeakMap();\n\nclass User {\nconstructor(name, password) {\nprivateData.set(this, { password });\n}\n\ncheckPassword(pass) {\nreturn privateData.get(this).password \\=== pass;\n}\n}\n\n* Данные автоматически удалятся, когда объект уничтожен\n\n2 Кеширование, связанное с объектом\n\nconst cache \\= new WeakMap();\n\nfunction process(obj) {\nif (cache.has(obj)) return cache.get(obj);\nconst result \\= heavyCalculation(obj);\ncache.set(obj, result);\nreturn result;\n}\n\n3 Отметка объектов (WeakSet)\n\nconst visited \\= new WeakSet();\n\nfunction visit(obj) {\nif (visited.has(obj)) return;\nvisited.add(obj);\n}\n\nКогда НЕ стоит использовать\n\n* Когда нужно:\n* перебирать элементы\n* хранить примитивы\n* знать количество элементов\n* Для обычных коллекций → **Map / Set**\n\n**Идеальная формулировка для собеседования**\n\nWeakMap и WeakSet — это коллекции со слабыми ссылками на объекты. В отличие от Map и Set, они не препятствуют сборке мусора и автоматически очищаются, когда объект становится недостижимым. WeakMap хранит пары ключ–значение, где ключом может быть только объект, WeakSet хранит только объекты. Эти структуры используются для приватных данных, кешей и вспомогательных меток, привязанных к жизненному циклу объектов.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "v-chem-otlichie-ot-obychnyh-map-i-set-dlya-chego-nuzhny"
    },
    {
        "id": 163,
        "title": "Что такое микрозадачи? Как работает очередь микрозадач? (Микрозадачи)",
        "answer": "Что такое микрозадачи (Microtasks)\n\n**Микрозадачи** — это задачи с **высоким приоритетом**, которые выполняются:\n\n* **сразу после завершения текущего синхронного кода**\n* **до рендера**\n* **до обработки макрозадач**\n\nОсновная цель — **гарантированно выполнить критичный асинхронный код как можно раньше**.\nОчередь микрозадач (Microtask Queue)\n\nВ JavaScript существует **отдельная очередь микрозадач**, отличная от очереди макрозадач.\nАлгоритм работы:\n\n1. Выполняется текущий синхронный код (call stack)\n2. **Полностью очищается очередь микрозадач**\n3. Происходит рендер (если требуется)\n4. Берётся **одна** макрозадача\n5. Повтор цикла\n\nКлючевой момент:\n**очередь микрозадач очищается полностью за один тик event loop**\n\nИсточники микрозадач\n\nК микрозадачам относятся:\n\n* Promise.then / catch / finally\n* queueMicrotask()\n* MutationObserver\n* await (внутри async-функций)\n\nPromise.resolve().then(() \\=\\> console.log('microtask'));\n\nОтличие от макрозадач\n\n| Критерий | Микрозадачи | Макрозадачи |\n| ----- | ----- | ----- |\n| Очередь | Microtask Queue | Task Queue |\n| Приоритет | Высокий | Ниже |\n| Выполнение | После sync-кода, **до рендера** | После микрозадач |\n| Примеры | Promise.then | setTimeout, setInterval, events |\n\nПример порядка выполнения\n\nconsole.log(1);\nsetTimeout(() \\=\\> console.log(2), 0);\nPromise.resolve().then(() \\=\\> console.log(3));\nconsole.log(4);\n\n**Результат:**\n1\n4\n3\n2\n\nПочему:\n\n* 1, 4 — синхронно\n* 3 — микрозадача\n* 2 — макрозадача\n\nМикрозадачи и async / await\n\nasync function test() {\nconsole.log(1);\nawait Promise.resolve();\nconsole.log(2);\n}\nconsole.log(3);\ntest();\nconsole.log(4);\n\n**Результат:**\n3\n1\n4\n2\n\nПояснение:\n\n* await ставит продолжение функции в очередь микрозадач\n\nВажный нюанс (часто спрашивают)\n\nМожет ли микрозадача заблокировать рендер?\n**Да.**\nfunction loop() {\nPromise.resolve().then(loop);\n}\nloop();\n\n* Очередь микрозадач **никогда не опустеет**\n* Браузер не сможет выполнить рендер\n* UI будет зависшим\n\nqueueMicrotask\n\nqueueMicrotask(() \\=\\> {\nconsole.log('micro');\n});\n\n* Явное добавление микрозадачи\n* Без создания Promise\n* Используется внутри библиотек\n\n**Идеальный ответ на собеседовании (кратко)**\n\nМикрозадачи — это асинхронные задачи с более высоким приоритетом, чем макрозадачи. После завершения текущего синхронного кода JavaScript полностью очищает очередь микрозадач, и только потом берёт следующую макрозадачу и выполняет рендер. К микрозадачам относятся Promise.then, async/await, queueMicrotask и MutationObserver.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "chto-takoe-mikrozadachi-kak-rabotaet-ochered-mikrozadach"
    },
    {
        "id": 164,
        "title": "В каком порядке выполняются задачи? Какие отличия микрозадач от макрозадач? (Событийный цикл)",
        "answer": "Общий порядок выполнения задач в Event Loop\nJavaScript выполняет код в **одном потоке**, используя **событийный цикл (Event Loop)**.\nОдин тик Event Loop выглядит так:\n\n1. **Call Stack** — выполняется весь синхронный код\n2. **Microtask Queue** — полностью очищается очередь микрозадач\n3. **Render** — браузер выполняет перерисовку (если требуется)\n4. **Macrotask Queue** — берётся **одна** макрозадача\n5. Повтор цикла\n\nКлючевой момент:\n**Микрозадачи выполняются раньше макрозадач и очищаются полностью**\n\nМикрозадачи (Microtasks)\n\nЧто это\nМикрозадачи — это задачи с **высшим приоритетом**, предназначенные для немедленного продолжения асинхронной логики.\nИсточники микрозадач\n\n* Promise.then / catch / finally\n* async / await (после await)\n* queueMicrotask\n* MutationObserver\n\nХарактеристики\n\n* Выполняются **сразу после синхронного кода**\n* Выполняются **до рендера**\n* Очередь очищается **полностью за один тик**\n* Могут блокировать UI при зацикливании\n\nМакрозадачи (Macrotasks / Tasks)\n\nЧто это\nМакрозадачи — это задачи общего назначения, которые выполняются **по одной за тик**.\nИсточники макрозадач\n\n* setTimeout\n* setInterval\n* setImmediate (Node.js)\n* DOM-события (click, scroll)\n* I/O операции\n* requestAnimationFrame (особый случай — перед рендером)\n\nХарактеристики\n\n* Выполняются **после микрозадач**\n* Между задачами браузер может выполнять рендер\n* Не блокируют интерфейс так агрессивно\n\nКлючевые отличия микрозадач и макрозадач\n\n| Критерий | Микрозадачи | Макрозадачи |\n| ----- | ----- | ----- |\n| Очередь | Microtask Queue | Task Queue |\n| Приоритет | Высокий | Ниже |\n| Очистка очереди | Полностью | По одной |\n| Выполнение | До рендера | После рендера |\n| Примеры | Promise.then | setTimeout, events |\n\nКлассический пример\n\nconsole.log(1);\nsetTimeout(() \\=\\> console.log(2), 0);\nPromise.resolve().then(() \\=\\> console.log(3));\nconsole.log(4);\n\n**Результат:**\n1\n4\n3\n2\n\nПример с async / await\n\nasync function f() {\nconsole.log(1);\nawait null;\nconsole.log(2);\n}\nconsole.log(3);\nf();\nconsole.log(4);\n\n**Результат:**\n3\n1\n4\n2\n\nawait ставит продолжение функции в очередь микрозадач.\n\nВажный нюанс (часто спрашивают)\n\nПочему setTimeout(fn, 0\\) не выполняется сразу?\n\n* 0 — это **минимальная задержка**\n* Колбэк попадает в очередь макрозадач\n* Он выполнится **после синхронного кода и микрозадач**\n\nМожет ли Promise выполниться раньше события?\n\n**Да.**\nbutton.addEventListener('click', () \\=\\> {\nPromise.resolve().then(() \\=\\> console.log('promise'));\nconsole.log('handler');\n});\n\nРезультат:\n\nhandler\npromise\n\n**Итоговый ответ на собеседовании (коротко)**\n\nJavaScript сначала выполняет весь синхронный код, затем полностью очищает очередь микрозадач. После этого браузер может выполнить рендер, и только затем берётся одна макрозадача. Микрозадачи имеют более высокий приоритет и используются для немедленного продолжения асинхронного кода, тогда как макрозадачи выполняются по одной за цикл.\n\n# Общее (доп.)\n\n1. Как импортировать всё из модуля? Почему так делать не правильно? Как импортировать и экспортировать с другим названием? Что такое экспорт по умолчанию? Чем отличается и какие проблемы есть? (Экспорт и импорт)\n2. Как вывести текст в консоль? Как вывести предупреждение, ошибку? Как отобразить данные в виде таблицы? Как с помощью консоли засечь таймер ? (Console)\n3. Работа с модулем URL. Работа с модулем URLSearchParams. Какие методы для работы с модулями ? Для чего нужны ? (URL API)\n4. Как работает ? File и FileReader Middle Какие методы предоставляет и зачем? Как работать с датой , числами , строками ? Какие методы могут работать с параметрами как в Intl? (Intl)",
        "category": "Events",
        "difficulty": "Medium",
        "slug": "v-kakom-poryadke-vypolnyayutsya-zadachi-kakie-otlichiya-mikrozadach-ot-makrozadach"
    },
    {
        "id": 165,
        "title": "Как импортировать всё из модуля? Почему так делать не правильно? Как импортировать и экспортировать с другим названием? Что такое экспорт по умолчанию? Чем отличается и какие проблемы есть? (Экспорт и импорт)",
        "answer": "Как импортировать всё из модуля\n\nimport \\* as utils from './utils.js';\n\nИспользование:\nutils.sum();\nutils.formatDate();\n\nЧто происходит\n\n* Все **именованные экспорты** собираются в **один объект**\n* default экспорт доступен как utils.default\n\nПочему import \\* as — плохая практика\n\nОсновные проблемы\n\n1\\. Потеря явных зависимостей\nimport \\* as api from './api';\n\nНевозможно быстро понять:\n\n* какие функции реально используются\n* что именно влияет на файл\n\nПлохо для:\n\n* поддержки\n* code review\n* анализа зависимостей\n\n2\\. Tree Shaking работает хуже\n\nБандлеру сложнее удалить неиспользуемый код, потому что:\napi.someDynamicCall()\n\nможет использовать что угодно внутри объекта.\n\n3\\. Конфликты имён и неявный API\n\n* Увеличивается поверхность API\n* Легко использовать лишнее\n* Трудно контролировать изменения модуля\n\n4\\. Производительность и масштабируемость\n\n* При росте модуля подход становится неуправляемым\n* Нарушает принцип явных зависимостей\n\nКогда допустимо\n\n* Генераторы\n* Утилитарные namespace-модули\n* Тесты\n* Миграционный код\n\nИмпорт и экспорт с другим названием (алиасы)\n\nЭкспорт с алиасом\nexport { fetchData as loadData };\nИмпорт с алиасом\nimport { fetchData as loadData } from './api.js';\nЗачем нужно\n\n* Избежать конфликтов имён\n* Повысить читаемость\n* Подстроить API под контекст файла\n\nЧто такое экспорт по умолчанию (default export)\n\nexport default function sum(a, b) {\nreturn a \\+ b;\n}\n\nИмпорт:\nimport sum from './sum.js';\n\nКлючевая особенность\n\n* **Имя не фиксировано**\n* Импортёр сам выбирает название\n\nОтличие default export от именованных\n\n| Критерий | Named export | Default export |\n| ----- | ----- | ----- |\n| Количество | Много | Только один |\n| Имя | Обязательно | Произвольное |\n| Tree shaking | Отличный | Хуже |\n| Автодополнение | Лучше | Хуже |\n| Рефакторинг | Безопаснее | Опаснее |\n\nОсновные проблемы default export\n\n1\\. Потеря единого имени\n\nimport a from './service';\nimport b from './service';\n\n* Один и тот же модуль под разными именами\n* Сложнее искать использование\n\n2\\. Сложнее рефакторить\n\n* Переименование функции не отражается в импортах\n* IDE хуже отслеживает связи\n\n3\\. Плохая масштабируемость\n\nПри добавлении второго экспорта:\nexport default class User {}\nexport function validate() {}\n\nИмпорт становится смешанным и неочевидным:\nimport User, { validate } from './user';\n\nКогда default export оправдан\n\n* React-компоненты (один компонент — один файл)\n* Entry-point модули\n* Обёртки / фасады\n* Конфигурации\n\nПереэкспорт (re-export)\n\nexport { fetchData } from './api.js';\nexport \\* from './utils.js';\n\nИли с алиасом:\nexport { fetchData as loadData } from './api.js';\n\nИспользуется для:\n\n* barrel-файлов (index.js)\n* публичного API пакета\n\nЧастая ошибка на собеседовании\n\n❌ Так нельзя:\nexport default const a \\= 1;\n\n✔ Правильно:\nconst a \\= 1;\nexport default a;\n\n**Краткий ответ для интервью**\n\nimport \\* as собирает все именованные экспорты в объект, но ухудшает читаемость, tree shaking и контроль зависимостей. Алиасы позволяют избегать конфликтов имён. Default export — это один экспорт без фиксированного имени, удобный для простых модулей, но он усложняет масштабирование, рефакторинг и анализ зависимостей.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-importirovat-vse-iz-modulya-pochemu-tak-delat-ne-pravil-no-kak-importirovat-i-eksportirovat-s-drugim-nazvaniem-chto-takoe-eksport-po-umolchaniyu-chem-otlichaetsya-i-kakie-problemy-est"
    },
    {
        "id": 166,
        "title": "Как вывести текст в консоль? Как вывести предупреждение, ошибку? Как отобразить данные в виде таблицы? Как с помощью консоли засечь таймер ? (Console)",
        "answer": "Как вывести текст в консоль\n\nconsole.log('Hello');\n\n* Основной метод логирования\n* Может принимать несколько аргументов\n* Поддерживает форматирование\n\nconsole.log('User:', user);\n\nКак вывести предупреждение\nconsole.warn('Deprecated API');\n\n* Отображается как предупреждение\n* Используется для потенциальных проблем\n* Не прерывает выполнение кода\n\nКак вывести ошибку\nconsole.error('Something went wrong');\n\n* Логирует ошибку\n* В DevTools подсвечивается красным\n* Стек вызовов выводится автоматически для Error\n\nconsole.error(new Error('Fail'));\n\nКак отобразить данные в виде таблицы\n\nconsole.table(users);\n\n* Удобно для массивов объектов\n* Ключи объекта → колонки\n* Значения → строки\n\nconsole.table(users, \\['id', 'name'\\]);\n(вывод только выбранных полей)\n\nКак засечь время выполнения кода\n\nЧерез console.time / console.timeEnd\nconsole.time('load');\n// код\nconsole.timeEnd('load');\n\n* Метка должна совпадать\n* Выводит время выполнения\n\nДополнительно: промежуточные замеры\n\nconsole.time('process');\nstep1();\nconsole.timeLog('process');\nstep2();\nconsole.timeEnd('process');\n\nПолезные методы консоли (часто спрашивают)\n\nconsole.clear();   // очистить консоль\nconsole.dir(obj); // показать структуру объекта\nconsole.group('Title');\nconsole.groupEnd();\nconsole.assert(condition, 'Message');\n\n**Краткий ответ для собеседования**\n\nДля логирования используется console.log, для предупреждений — console.warn, для ошибок — console.error. Для визуализации структурированных данных есть console.table. Замер времени выполнения осуществляется через console.time и console.timeEnd, что удобно для профилирования кода.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-vyvesti-tekst-v-konsol-kak-vyvesti-preduprezhdenie-oshibku-kak-otobrazit-dannye-v-vide-tablitsy-kak-s-pomosch-yu-konsoli-zasech-taymer"
    },
    {
        "id": 167,
        "title": "Работа с модулем URL. Работа с модулем URLSearchParams. Какие методы для работы с модулями ? Для чего нужны ? (URL API)",
        "answer": "URL API (URL, URLSearchParams)\nДля чего нужен URL API\n\nURL API предоставляет **стандартизированный способ**:\n\n* парсить URL\n* безопасно работать с его частями\n* изменять query-параметры\n* корректно кодировать/декодировать данные\n\nРаботает одинаково в **браузере и Node.js**.\n\nКласс URL\nСоздание URL\nconst url \\= new URL('https://example.com:8080/path?x=1\\#hash');\nили с базовым URL:\nnew URL('/users', 'https://api.site.com');\n\nОсновные свойства URL\n\nurl.href      // полный URL\nurl.protocol  // 'https:'\nurl.host      // 'example.com:8080'\nurl.hostname  // 'example.com'\nurl.port      // '8080'\nurl.pathname  // '/path'\nurl.search    // '?x=1'\nurl.hash      // '\\#hash'\nurl.origin    // 'https://example.com:8080'\n\nИзменение URL\n\nurl.pathname \\= '/profile';\nurl.hash \\= '\\#top';\n\nВсе изменения **автоматически отражаются в href**.\n\nURLSearchParams\nURLSearchParams предназначен для **работы с query-параметрами** (?key=value).\nconst params \\= new URLSearchParams('?page=2\\&sort=asc');\nИли из URL:\nurl.searchParams\n\nОсновные методы URLSearchParams\nПолучение значений\nparams.get('page');        // '2'\nparams.getAll('filter');  // \\['a', 'b'\\]\nparams.has('sort');       // true\n\nУстановка и изменение\nparams.set('page', 3);\nparams.append('filter', 'new');\n\nУдаление\nparams.delete('sort');\n\nИтерация\nparams.forEach((value, key) \\=\\> {});\nparams.keys();\nparams.values();\nparams.entries();\nПоддерживает for...of.\n\nПреобразование в строку\nparams.toString(); // 'page=3\\&filter=new'\n\nСвязь URL и URLSearchParams\nurl.searchParams.set('q', 'js');\nurl.toString();\nИзменения searchParams **сразу обновляют URL**.\n\nКодирование\nURL API **автоматически кодирует** спецсимволы:\nparams.set('q', 'hello world');\n→ q=hello+world\n\nКогда использовать URL API\n\n* Работа с query-параметрами\n* Формирование API-запросов\n* Избежание ручного парсинга строк\n* Корректное кодирование данных\n\nЧего не стоит делать\n\n❌ Ручной парсинг строк:\n\nlocation.search.split('&')\n\n**Краткий ответ для собеседования**\n\nURL API используется для парсинга и безопасного изменения URL. Класс URL позволяет работать со всеми частями адреса, а URLSearchParams — удобно управлять query-параметрами. API автоматически кодирует значения, поддерживает итерацию и работает одинаково в браузере и Node.js.\n\n###",
        "category": "Network",
        "difficulty": "Medium",
        "slug": "rabota-s-modulem-url-rabota-s-modulem-urlsearchparams-kakie-metody-dlya-raboty-s-modulyami-dlya-chego-nuzhny"
    },
    {
        "id": 168,
        "title": "Как работает ? File и FileReader Middle Какие методы предоставляет и зачем? Как работать с датой , числами , строками ? Какие методы могут работать с параметрами как в Intl? (Intl)",
        "answer": "File и FileReader / Intl API\nFile и FileReader\n\nЧто такое File\nFile — это объект, представляющий **файл на стороне клиента**.\nЯвляется наследником Blob.\n\nИспользуется при:\n\n* загрузке файлов через \\<input type=\"file\"\\>\n* drag & drop\n* работе с локальными файлами в браузере\n\ninput.files\\[0\\] instanceof File // true\n\nОсновные свойства File\n\nfile.name      // имя файла\nfile.size      // размер в байтах\nfile.type      // MIME-тип\nfile.lastModified\n\nFileReader\n\nFileReader позволяет **асинхронно читать содержимое файла** в браузере.\nРаботает **только в браузере**.\n\nОсновные методы FileReader\nreader.readAsText(file)       // текст\nreader.readAsDataURL(file)    // base64 (img, preview)\nreader.readAsArrayBuffer(file)\nreader.readAsBinaryString()  // устаревший\n\nСобытия FileReader\nreader.onload\nreader.onerror\nreader.onprogress\nreader.onloadend\n\nЧтение **асинхронное** → всегда через события или Promise-обёртку.\n\nПример\n\nconst reader \\= new FileReader();\nreader.onload \\= () \\=\\> console.log(reader.result);\nreader.readAsText(file);\n\nЗачем использовать File / FileReader\n\n* предпросмотр изображений\n* валидация файлов до отправки\n* чтение CSV / JSON\n* загрузка документов без сервера\n\nIntl API\nЧто такое Intl\n\nIntl — это **API интернационализации**, которое позволяет:\n\n* форматировать даты\n* числа\n* валюты\n* строки\nв зависимости от **локали и правил страны**.\n\nРаботает в браузере и Node.js.\n\nIntl для дат\n\nIntl.DateTimeFormat\nnew Intl.DateTimeFormat('ru-RU', {\ndateStyle: 'full',\ntimeStyle: 'short'\n}).format(new Date());\n\nIntl для чисел\n\nIntl.NumberFormat\nnew Intl.NumberFormat('de-DE').format(123456.78);\n// 123.456,78\n\nВалюта\n\nnew Intl.NumberFormat('en-US', {\nstyle: 'currency',\ncurrency: 'USD'\n}).format(1000);\n\nIntl для строк\n\nIntl.Collator\nКорректное сравнение строк:\nnew Intl.Collator('ru').compare('ё', 'е');\nИспользуется для **правильной сортировки**.\n\nМетоды Intl с параметрами\n\n| API | Для чего |\n| ----- | ----- |\n| Intl.DateTimeFormat | даты и время |\n| Intl.NumberFormat | числа, валюта |\n| Intl.Collator | сравнение строк |\n| Intl.PluralRules | множественные формы |\n| Intl.RelativeTimeFormat | \"2 дня назад\" |\n| Intl.ListFormat | списки |\n| Intl.DisplayNames | названия стран, языков |\n\nПример RelativeTimeFormat\n\nnew Intl.RelativeTimeFormat('ru').format(-1, 'day');\n// \"вчера\"\n\nПочему не писать вручную\n\n* разные форматы дат\n* разные правила валют\n* языковые нюансы\n* ошибки локализации\n\n**Краткий ответ для собеседования**\n\nFile представляет файл на стороне клиента, а FileReader позволяет асинхронно читать его содержимое. Intl API используется для форматирования дат, чисел и строк с учётом локали. Оно предоставляет классы DateTimeFormat, NumberFormat, Collator и другие, что позволяет корректно работать с интернационализацией без ручной логики.\n\n#\n\n# Запросы и хранение данных\n\n1. Для чего используется? Какие могут быть методы запросов? Какие могут быть статусы ответа? Возможные форматы body и ответа. Как работать с заголовками ? Как понять в какой тип парсить содержимое ответа ? (Fetch)\n2. Как устроен ? Для чего нужен? (CORS)\n3. Почему файлы отправляются этим форматом? Предоставляемые методы.(FormData)\n4. Как прервать зарос? Прерывание запроса Junior+ Как работать с localStorage, sessionStorage ? В чем между ними разница?( localStorage, sessionStorage)\n5. Как работать с куками ? Как удалить куку? (Куки)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-rabotaet-file-i-filereader-middle-kakie-metody-predostavlyaet-i-zachem-kak-rabotat-s-datoy-chislami-strokami-kakie-metody-mogut-rabotat-s-parametrami-kak-v-intl"
    },
    {
        "id": 169,
        "title": "Для чего используется? Какие могут быть методы запросов? Какие могут быть статусы ответа? Возможные форматы body и ответа. Как работать с заголовками ? Как понять в какой тип парсить содержимое ответа ? (Fetch)",
        "answer": "Fetch API\nДля чего используется fetch\n\nfetch — это **стандартный Web API** для выполнения **HTTP-запросов** из браузера (и Node.js).\nИспользуется для:\n\n* получения данных с сервера\n* отправки форм\n* работы с REST / GraphQL API\n* загрузки и отправки файлов\n\nВозвращает **Promise**, который резолвится в объект Response.\n\nМетоды HTTP-запросов\nНаиболее используемые:\n\n| Метод | Назначение |\n| ----- | ----- |\n| GET | Получение данных |\n| POST | Создание ресурса |\n| PUT | Полное обновление |\n| PATCH | Частичное обновление |\n| DELETE | Удаление |\n| HEAD | Заголовки без тела |\n| OPTIONS | Проверка возможностей (CORS) |\n\nПример:\nfetch('/api/users', { method: 'POST' });\nСтатусы ответа (HTTP Status)\n\nОсновные группы:\n\n| Диапазон | Значение |\n| ----- | ----- |\n| 2xx | Успех |\n| 3xx | Редиректы |\n| 4xx | Ошибка клиента |\n| 5xx | Ошибка сервера |\n\nЧасто спрашиваемые:\n\n* 200 OK\n* 201 Created\n* 204 No Content\n* 400 Bad Request\n* 401 Unauthorized\n* 403 Forbidden\n* 404 Not Found\n* 500 Internal Server Error\n\n⚠️ **fetch не кидает ошибку на 4xx/5xx**, нужно проверять вручную:\n\nif (\\!response.ok) throw new Error(response.status);\n\nФорматы body запроса\n\nОсновные варианты:\n\n| Тип | Как передать |\n| ----- | ----- |\n| JSON | JSON.stringify() |\n| FormData | new FormData() |\n| Text | строка |\n| Blob / File | файлы |\n| URLSearchParams | query-подобный формат |\n\nПример JSON:\n\nfetch('/api', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json'\n},\nbody: JSON.stringify({ name: 'John' })\n});\n\nФорматы ответа\n\nОбрабатываются через методы Response:\nresponse.json()\nresponse.text()\nresponse.blob()\nresponse.arrayBuffer()\nresponse.formData()\n\nКак понять, в какой тип парсить ответ\nПо заголовку **Content-Type**:\nconst type \\= response.headers.get('content-type');\nif (type.includes('application/json')) {\nreturn response.json();\n}\n\nСервер **обязан** указать формат ответа.\n\nРабота с заголовками\nПередача заголовков\nheaders: {\n'Authorization': 'Bearer token',\n'Accept': 'application/json'\n}\n\nЧтение заголовков ответа\n\nresponse.headers.get('Content-Type');\nHeaders — итерируемый объект.\n\nResponse объект\nОсновные свойства:\nresponse.ok        // true если 2xx\nresponse.status    // код статуса\nresponse.statusText\nresponse.url\n\n⚠️ Тело можно прочитать **только один раз**.\n\nОбработка ошибок (корректно)\n\nfetch(url)\n.then(res \\=\\> {\nif (\\!res.ok) throw new Error(res.status);\nreturn res.json();\n})\n.catch(err \\=\\> console.error(err));\n**Краткий ответ для собеседования**\n\nFetch используется для выполнения HTTP-запросов. Он поддерживает все основные методы, возвращает Promise с объектом Response и не выбрасывает ошибку при 4xx/5xx — это нужно проверять вручную. Формат тела запроса и ответа зависит от Content-Type. Для работы используются заголовки, а парсинг ответа выполняется методами json, text, blob и другими.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "dlya-chego-ispol-zuetsya-kakie-mogut-byt-metody-zaprosov-kakie-mogut-byt-statusy-otveta-vozmozhnye-formaty-body-i-otveta-kak-rabotat-s-zagolovkami-kak-ponyat-v-kakoy-tip-parsit-soderzhimoe-otveta"
    },
    {
        "id": 170,
        "title": "Как устроен ? Для чего нужен? (CORS)",
        "answer": "CORS (Cross-Origin Resource Sharing)\nДля чего нужен CORS\n\n**CORS — это механизм безопасности браузера**, который ограничивает **HTTP-запросы между разными origin**.\nOrigin \\=scheme (protocol) \\+ host \\+ port\nПример разных origin:\n\n* https://site.com\n* http://site.com\n* https://api.site.com\n* https://site.com:3000\n\nБез CORS браузер **блокирует доступ к ответу**, даже если сервер его отправил.\n\nЗачем он нужен\n\n* Защита от **XSS и CSRF**\n* Предотвращение чтения данных с чужих сайтов\n* Контроль того, **кто может обращаться к API**\n\n⚠️ **CORS — это защита браузера, не сервера**\n\nКак работает CORS\n\n1. Браузер отправляет запрос\n2. Сервер отвечает **с CORS-заголовками**\n3. Браузер проверяет заголовки\n4. Если правила не совпадают — **ответ блокируется**\n\nОсновные CORS-заголовки\n**Access-Control-Allow-Origin**\nAccess-Control-Allow-Origin: https://example.com\nили\nAccess-Control-Allow-Origin: \\*\n\n**Access-Control-Allow-Methods**\nAccess-Control-Allow-Methods: GET, POST, PUT\n\n**Access-Control-Allow-Headers**\n\nAccess-Control-Allow-Headers: Content-Type, Authorization\n\n**Access-Control-Allow-Credentials**\n\nAccess-Control-Allow-Credentials: true\n\nПозволяет отправлять:\n\n* cookies\n* authorization headers\n\n⚠️ Нельзя использовать \\* с credentials\n\nПростые и сложные запросы\n\nSimple request\nБез preflight:\n\n* методы: GET, POST, HEAD\n* стандартные заголовки\n* Content-Type:\ntext/plain, application/x-www-form-urlencoded, multipart/form-data\n\nPreflight (OPTIONS)\nЕсли запрос **не простой**, браузер:\n\n1. Отправляет OPTIONS\n2. Проверяет разрешения\n3. Только потом отправляет основной запрос\n\nЧто такое preflight\n\nOPTIONS /api HTTP/1.1\nOrigin: https://site.com\nAccess-Control-Request-Method: POST\nСервер отвечает, разрешён ли запрос.\n\nТипичная ошибка\nСервер вернул данные, но браузер их не отдаёт JS\nЭто **CORS**, а не ошибка сервера.\n\nКак исправляют CORS\nНа сервере:\n\n* добавить нужные заголовки\n* настроить proxy\n* использовать middleware (cors в Express)\n\nНа фронте:\n\n* прокси через dev-сервер\n* same-origin запросы\n* избегать credentials без нужды\n\nЧастый вопрос: почему Postman работает?\nPostman **не браузер** → CORS на него не действует.\n\n**Краткий ответ для собеседования**\n\nCORS — это браузерный механизм безопасности, который ограничивает кросс-доменные HTTP-запросы. Он работает через специальные заголовки сервера и может требовать preflight-запрос OPTIONS. CORS проверяется браузером, а не сервером, и используется для защиты данных.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-ustroen-dlya-chego-nuzhen"
    },
    {
        "id": 171,
        "title": "Почему файлы отправляются этим форматом? Предоставляемые методы.(FormData)",
        "answer": "FormData\nПочему файлы отправляются через FormData\nФайлы отправляются в формате **multipart/form-data**, потому что:\n\n1. **Файл — бинарные данные**, их нельзя корректно передать в JSON\n2. multipart/form-data позволяет:\n* передавать **файлы и обычные поля вместе**\n* не кодировать файл в base64 (экономия трафика)\n* корректно передавать **большие объёмы данных**\n3. Это **стандарт HTML-форм**, поддерживаемый всеми серверами\n\nПри использовании FormData браузер:\n\n* сам формирует границы (boundary)\n* сам выставляет Content-Type\n\n⚠️ **Нельзя вручную задавать Content-Type** при FormData\n\nДля чего используется FormData\n\n* отправка файлов\n* отправка форм с файлами\n* multipart-запросы\n* загрузка изображений, документов, видео\n\nКак создать FormData\nconst formData \\= new FormData();\n\nИз формы:\nconst formData \\= new FormData(formElement);\n\nОсновные методы FormData\nappend(name, value, filename?)\nДобавляет значение (не затирает существующее)\nformData.append('file', file);\n\nset(name, value, filename?)\nУстанавливает или перезаписывает значение\nformData.set('name', 'John');\n\nget(name)\nПолучить первое значение\nformData.get('file');\n\ngetAll(name)\nПолучить все значения по ключу\nformData.getAll('images');\n\nhas(name)\nПроверка существования поля\nformData.has('file');\n\ndelete(name)\nУдалить поле\nformData.delete('file');\nИтерация по FormData\n\nfor (const \\[key, value\\] of formData.entries()) {\nconsole.log(key, value);\n}\n\nМетоды:\n\n* entries()\n* keys()\n* values()\n\nОтправка через fetch\n\nfetch('/upload', {\nmethod: 'POST',\nbody: formData\n});\n\nПочему не JSON для файлов\n\n| JSON | FormData |\n| ----- | ----- |\n| Нет бинарных данных | Поддерживает бинарные |\n| Нужно base64 | Отправка напрямую |\n| Увеличивает размер | Оптимальный размер |\n| Ручной Content-Type | Автоматический |\n\n**Краткий ответ для собеседования**\n\nФайлы отправляются через FormData, потому что используется формат multipart/form-data, который поддерживает бинарные данные и передачу файлов без кодирования. FormData предоставляет методы append, set, get, delete и позволяет отправлять файлы и поля формы вместе, при этом браузер сам формирует заголовки.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "pochemu-fayly-otpravlyayutsya-etim-formatom-predostavlyaemye-metody"
    },
    {
        "id": 172,
        "title": "Как прервать зарос? Прерывание запроса Junior+ Как работать с localStorage, sessionStorage ? В чем между ними разница?( localStorage, sessionStorage)",
        "answer": "Прерывание запроса (AbortController)\nКак прервать запрос\n\nДля прерывания HTTP-запросов (в частности fetch) используется **AbortController**.\nКак работает\n\n1. Создаётся AbortController\n2. Его signal передаётся в fetch\n3. Вызов abort() прерывает запрос\n\nconst controller \\= new AbortController();\nfetch(url, { signal: controller.signal });\ncontroller.abort();\nЧто происходит при прерывании\n\n* fetch отклоняет Promise\n* выбрасывается ошибка AbortError\n* запрос фактически останавливается браузером\n\ntry {\nawait fetch(url, { signal });\n} catch (e) {\nif (e.name \\=== 'AbortError') {\nconsole.log('Request aborted');\n}\n}\n\nЗачем прерывать запросы\n\n* отмена предыдущих запросов (search input)\n* предотвращение race conditions\n* оптимизация ресурсов\n* уход со страницы / размонтирование компонента\n\nПрерывание запросов — Junior+ вопрос\n\n⚠️ setTimeout **не может** прервать fetch\n⚠️ Нужно именно AbortController\n\nlocalStorage и sessionStorage\nЧто это\n\nlocalStorage и sessionStorage — это **Web Storage API**\nИспользуются для хранения данных **в браузере** в формате ключ: значение.\n\nlocalStorage\n\n* Хранится **постоянно**\n* Не очищается при закрытии вкладки\n* Общий для всех вкладок одного origin\n\nlocalStorage.setItem('token', '123');\nlocalStorage.getItem('token');\nlocalStorage.removeItem('token');\nlocalStorage.clear();\n\nsessionStorage\n\n* Живёт **только в рамках вкладки**\n* Удаляется при закрытии вкладки\n* Не доступен между вкладками\n\nsessionStorage.setItem('step', '1');\n\nОтличия localStorage vs sessionStorage\n\n| Характеристика | localStorage | sessionStorage |\n| ----- | ----- | ----- |\n| Время жизни | Бессрочно | До закрытия вкладки |\n| Область | Все вкладки | Одна вкладка |\n| Размер | \\~5–10 МБ | \\~5 МБ |\n| Тип данных | Только строки | Только строки |\n\nРабота с объектами\n\nНужно сериализовать:\nlocalStorage.setItem('user', JSON.stringify(user));\nJSON.parse(localStorage.getItem('user'));\n\nОграничения Web Storage\n\n* Только строки\n* Синхронный API (может блокировать UI)\n* Нет безопасности (доступен JS)\n* Не подходит для чувствительных данных\n\n**Краткий ответ для собеседования**\n\nДля прерывания запросов используется AbortController, который передаёт сигнал в fetch и позволяет отменить запрос. localStorage и sessionStorage — это браузерное хранилище ключ-значение. localStorage хранит данные бессрочно, а sessionStorage — только в рамках одной вкладки.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-prervat-zaros-preryvanie-zaprosa-junior-kak-rabotat-s-localstorage-sessionstorage-v-chem-mezhdu-nimi-raznitsa"
    },
    {
        "id": 173,
        "title": "Как работать с куками ? Как удалить куку? (Куки)",
        "answer": "Cookies (Куки)\nЧто такое cookies\n\n**Cookies** — это небольшие данные, которые браузер:\n\n* хранит на клиенте\n* автоматически отправляет на сервер с каждым HTTP-запросом\n* привязаны к **домену и пути**\n\nИспользуются для:\n\n* авторизации\n* хранения сессий\n* аналитики\n* персонализации\n\nКак работать с куками в JavaScript\n\nЧтение cookies\tdocument.cookie\nВозвращает **строку**:\t\tkey1=value1; key2=value2\nНужно парсить вручную.\n\nУстановка cookie\n\ndocument.cookie \\= \"token=abc123; path=/; max-age=3600\";\n\nОсновные атрибуты cookie\n\n| Атрибут | Назначение |\n| ----- | ----- |\n| expires | Дата истечения |\n| max-age | Время жизни (секунды) |\n| path | Путь |\n| domain | Домен |\n| secure | Только HTTPS |\n| samesite | CSRF-защита |\n| httponly | Недоступна JS |\n\nПример полной cookie\n\ndocument.cookie \\= \"session=1; path=/; secure; samesite=strict\";\n\nКак удалить cookie\nCookie **нельзя удалить напрямую**.\nЕё удаляют, установив **с истёкшим сроком**.\n\nСпособ 1: через max-age\ndocument.cookie \\= \"token=; max-age=0; path=/\";\n\nСпособ 2: через expires\n\ndocument.cookie \\= \"token=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\";\n\n⚠️ path и domain должны совпадать с оригинальными.\n\nHttpOnly cookies\n\n* Недоступны через JS\n* Защищают от XSS\n* Используются для сессий\n\nSet-Cookie: sessionId=abc; HttpOnly;\n\nCookies и fetch\nЧтобы отправлять cookies:\nfetch(url, {\ncredentials: 'include'\n});\n\nОграничения cookies\n\n* Размер \\~4KB\n* Отправляются с каждым запросом\n* Медленнее localStorage\n* Уязвимы без HttpOnly и SameSite\n\n**Краткий ответ для собеседования**\n\nCookies — это клиентское хранилище, которое автоматически отправляется на сервер. В JavaScript с ними работают через document.cookie. Удаление cookie выполняется установкой пустого значения с истёкшим сроком действия. Для безопасности используются атрибуты HttpOnly, Secure и SameSite.\n\n# Регулярки\n\n1. Какие есть флаги? Как работает сивол границы слова с нелатиницей? (Шаблоны и флаги, Символьные классы, Граница слова)\n2. Символы для начала и конца строки. Отличия для многострочного режима (Якоря и многострочный режим)\n3. Как работает диапазон? Исключающий режим. Ветвления. (Спец символы, Наборы и диапазоны, Альтернация)\n4. Какие квантификаторы есть? Режимы работы (Квантификаторы, жадные и ленивые)\n5. Как получить все скобочные группы? Как получить конкретную? Ссылки на скобочные группы. (Скобочные группы, Обратные ссылки)\n6. Как указываются и зачем нужны? (Опережающие и ретроспективные проверки)\n7. Какие методы могут работать используя регулярные выражения ? (Методы RegExp и String)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-rabotat-s-kukami-kak-udalit-kuku"
    },
    {
        "id": 174,
        "title": "Какие есть флаги? Как работает сивол границы слова с нелатиницей? (Шаблоны и флаги, Символьные классы, Граница слова)",
        "answer": "Регулярные выражения (RegExp)\nКакие есть флаги\n\nФлаги управляют поведением регулярного выражения.\n\n| Флаг | Назначение |\n| ----- | ----- |\n| g | Глобальный поиск (все совпадения) |\n| i | Игнорировать регистр |\n| m | Многострочный режим (^ и $) |\n| s | . захватывает перенос строки |\n| u | Unicode режим |\n| y | Липкий поиск (с позиции lastIndex) |\n\nПример:\n/word/gi\n\nШаблоны и символьные классы\nОсновные символьные классы\n\n| Класс | Значение |\n| ----- | ----- |\n| \\\\d | цифра (\\[0-9\\]) |\n| \\\\w | буква, цифра или \\_ *(латиница)* |\n| \\\\s | пробельный символ |\n| \\\\D \\\\W \\\\S | отрицания |\n\n⚠️ \\\\w **не включает кириллицу**\n\nКастомные классы\n\n/\\[a-zA-Zа-яА-Я0-9\\_\\]/u\n\nГраница слова \\\\b\n\nЧто такое \\\\b\n\\\\b — это **граница между \\\\w и \\\\W**\n\\\\w | \\\\W\n\nПроблема с нелатиницей\n\n\\\\w включает **только латиницу**, цифры и \\_\n👉 **Кириллица считается \\\\W**\n'привет'.match(/\\\\bпривет\\\\b/) // ❌ null\nПочему так происходит\nПотому что:\n\\\\b \\= граница ( \\\\w ↔ \\\\W )\nА кириллица не входит в \\\\w.\n\nКак корректно работать с нелатиницей\n\nИспользовать Unicode-классы (\\\\p{})\n/\\\\b\\\\p{L}+\\\\b/gu\nили явно:\n/(^|\\\\s)привет(\\\\s|$)/u\n\nUnicode-флаг u\n\nПозволяет:\n\n* корректно работать с суррогатными парами\n* использовать \\\\p{L}, \\\\p{N} и т.д.\n\n/\\\\p{L}+/u\n\nЧастая ошибка на собеседовании\n\n❌ Ожидать, что \\\\b работает с кириллицей\n✅ Понимать, что \\\\b привязан к \\\\w\n\n**Краткий ответ для собеседования**\n\nВ JavaScript регулярные выражения поддерживают флаги g, i, m, s, u и y. Символьный класс \\\\w и граница слова \\\\b работают только с латиницей. Для корректной работы с нелатиницей необходимо использовать Unicode-флаг u и классы \\\\p{L} либо задавать границы вручную.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-est-flagi-kak-rabotaet-sivol-granitsy-slova-s-nelatinitsey"
    },
    {
        "id": 175,
        "title": "Символы для начала и конца строки. Отличия для многострочного режима (Якоря и многострочный режим)",
        "answer": "Якоря начала и конца строки (^ и $)\nКакие символы используются\n\nВ регулярных выражениях:\n\n* ^ — **начало строки**\n* $ — **конец строки**\n\nОни называются **якорями** и не сопоставляются с символами, а с позициями.\n\nКак работают без многострочного режима\n\nПо умолчанию (m **не указан**):\n/^abc$/.test(\"abc\")      // true\n/^abc$/.test(\"abc\\\\ndef\")   // false\n/^abc$/.test(\"xabc\")    // false\n\n* ^ — начало **всей строки**\n* $ — конец **всей строки**\n\nМногострочный режим (m)\n\nФлаг m меняет поведение ^ и $.\n/^abc$/m.test(\"abc\\\\ndef\") // true\n\nВ режиме m:\n\n* ^ — начало **каждой строки**\n* $ — конец **каждой строки**\n\nРазделителем строки считается \\\\n.\n\nПример сравнения\n\nconst text \\= \"one\\\\ntwo\\\\nthree\";\ntext.match(/^two$/);   // null\ntext.match(/^two$/m);  // \\[\"two\"\\]\n\nОтличие m от s\n\n| Флаг | Влияние |\n| ----- | ----- |\n| m | меняет ^ и $ |\n| s | делает . совпадающим с \\\\n |\n\nЧастая ошибка\n\nОжидать, что:\n^ и $ работают построчно по умолчанию\nЭто **не так**, для этого нужен m.\n\n**Краткий ответ для собеседования**\n\nВ регулярных выражениях ^ и $ — это якоря начала и конца строки. Без флага m они применяются ко всей строке. В многострочном режиме m они работают для каждой строки отдельно, ограниченной символом перевода строки.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "simvoly-dlya-nachala-i-kontsa-stroki-otlichiya-dlya-mnogostrochnogo-rezhima"
    },
    {
        "id": 176,
        "title": "Как работает диапазон? Исключающий режим. Ветвления. (Спец символы, Наборы и диапазоны, Альтернация)",
        "answer": "Наборы, диапазоны и альтернация в RegExp\nКак работают наборы символов \\[\\]\n\nНабор \\[\\] означает:\n**совпадение с одним символом из перечисленных**\n/\\[abc\\]/   // a или b или c\nДиапазоны символов\nСинтаксис\n\\[a-z\\]\n\\[0-9\\]\n\\[A-Z\\]\nОзначает:\nлюбой символ в указанном диапазоне по Unicode-коду\nКомбинирование диапазонов\n\\[a-zA-Z0-9\\_\\]\n\nВажный момент\nДиапазон зависит от **кода символов**, а не алфавита языка.\nДля кириллицы требуется флаг u:\n/\\[а-яё\\]/u\n\nИсключающий (отрицательный) набор \\[^ \\]\nЕсли первый символ внутри \\[\\] — ^, набор становится **отрицательным**.\n/\\[^0-9\\]/   // любой символ, кроме цифры\n\n⚠️ Работает **только в начале набора**\n\nПример\n\n/\\[^a-z\\]/i\nСовпадёт с:\n\n* цифрами\n* пробелами\n* спецсимволами\n\nСпециальные символы внутри наборов\n\n| Символ | Значение |\n| ----- | ----- |\n| \\- | диапазон |\n| ^ | отрицание (только первым) |\n| \\\\ | экранирование |\n| \\] | конец набора |\n\nПример экранирования:\n/\\[\\\\-\\\\\\]\\]/\nАльтернация (ветвление) |\n\n| означает **ИЛИ**.\n/cat|dog/\n\nПриоритет |\n| имеет **низкий приоритет**, поэтому часто нужны скобки:\n/gr(e|a)y/\nОтличие от набора\n\n| Набор | Альтернация |\n| ----- | ----- |\n| \\[ab\\] | a или b (1 символ) |\n| \\`ab | cd\\` |\n\nКомбинирование\n\n/(https?|ftp):\\\\/\\\\//\nЧастые ошибки\n\n❌ \\[cat|dog\\]\n✔ cat|dog\n❌ \\[^a-z^\\]\n✔ \\[^a-z\\]\n\n**Краткий ответ для собеседования**\n\nДиапазоны в регулярных выражениях задаются внутри квадратных скобок и соответствуют диапазону Unicode-кодов. Исключающий набор создаётся с помощью ^ в начале набора. Альтернация | используется для ветвлений и выбирает одно из выражений, при этом часто требует группировки скобками из\\-за низкого приоритета.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-rabotaet-diapazon-isklyuchayuschiy-rezhim-vetvleniya"
    },
    {
        "id": 177,
        "title": "Какие квантификаторы есть? Режимы работы (Квантификаторы, жадные и ленивые)",
        "answer": "Квантификаторы в регулярных выражениях\nЧто такое квантификаторы\n\nКвантификаторы определяют **сколько раз** предыдущий токен (символ, класс, группа) должен повториться.\nОсновные квантификаторы\n\n| Квантификатор | Значение |\n| ----- | ----- |\n| \\* | 0 или более |\n| \\+ | 1 или более |\n| ? | 0 или 1 |\n| {n} | ровно n |\n| {n,} | n или более |\n| {n,m} | от n до m |\n\nПримеры\n\n/a\\*/     // \"\", \"a\", \"aaa\"\n/a+/     // \"a\", \"aaa\"\n/a?/     // \"\" или \"a\"\n/a{3}/   // \"aaa\"\n/a{2,4}/ // \"aa\", \"aaa\", \"aaaa\"\n\nКвантификаторы применяются к:\n\n1\\. Одному символу\t/\\\\d+/\n2\\. Классу символов\t/\\[a-z\\]{3,5}/\n3\\. Группе\t/(ab)+/\n\nЖадный (Greedy) режим — по умолчанию\n\n**Жадные квантификаторы** захватывают **максимально возможное** количество символов, при котором выражение остаётся валидным.\t\".\\*\"\nНа строке:\t\"a\" \"b\" \"c\"\nРезультат:\t\"a\" \"b\" \"c\"\nЛенивый (Lazy / Reluctant) режим\n\nДобавление ? после квантификатора делает его **ленивым** — он захватывает **минимально возможное** количество символов.\t\".\\*?\"\n\nПример\n\nconst str \\= '\\<div\\>text\\</div\\>';\nstr.match(/\\<.\\*\\>/);   // \"\\<div\\>text\\</div\\>\"\nstr.match(/\\<.\\*?\\>/);  // \"\\<div\\>\"\nСравнение жадного и ленивого режимов\n\n| Режим | Поведение |\n| ----- | ----- |\n| Жадный | Максимальный захват |\n| Ленивый | Минимальный захват |\n\nПочему возникают проблемы с жадностью\t/\\<.+\\>/\nЗахватит:\t\\<div\\>text\\</div\\>\nХотя ожидали:\t\\<div\\>\nКвантификатор ? — двойное значение\n\n| Контекст | Значение |\n| ----- | ----- |\n| a? | 0 или 1 |\n| \\*?, \\+?, {n,m}? | ленивый режим |\n\nЛенивыми могут быть\n\n\\*?\n\\+?\n??\n{n,m}?\nВажно знать (Middle)\n\n* Квантификаторы **всегда относятся к предыдущему токену**\n* Ленивость не означает «медленнее», а «минимальный захват»\n* Для сложных парсингов HTML RegExp — плохой инструмент\n\n**Краткий ответ для собеседования**\n\nВ регулярных выражениях используются квантификаторы \\*, \\+, ? и фигурные формы {n,m} для задания количества повторений. По умолчанию они работают в жадном режиме и захватывают максимальное количество символов. Добавление ? после квантификатора переводит его в ленивый режим, при котором захват минимален и останавливается при первом успешном совпадении.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-kvantifikatory-est-rezhimy-raboty"
    },
    {
        "id": 178,
        "title": "Как получить все скобочные группы? Как получить конкретную? Ссылки на скобочные группы. (Скобочные группы, Обратные ссылки)",
        "answer": "Скобочные группы (Capturing Groups)\nЧто такое скобочная группа\n\nСкобочная группа — это часть регулярного выражения, заключённая в (), которая:\n\n1. **Группирует** выражение\n2. **Запоминает** (capture) совпавшую подстроку\n3. Может быть использована повторно (обратные ссылки)\n\n/(ab)+/\n\nКак получить все скобочные группы\n\n1\\. Через String.match()\nconst str \\= '2025-01-09';\nconst result \\= str.match(/(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/);\nРезультат:\n\\[\n\"2025-01-09\", // полное совпадение\n\"2025\",       // группа 1\n\"01\",         // группа 2\n\"09\"          // группа 3\n\\]\n\n* result\\[0\\] — полное совпадение\n* result\\[1...\\] — скобочные группы\n\n2\\. Через RegExp.exec()\n\nconst regex \\= /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/;\nconst res \\= regex.exec('2025-01-09');\nРаботает аналогично match.\n\n3\\. Именованные группы (groups)\n\nconst res \\= '2025-01-09'.match(\n/(?\\<year\\>\\\\d{4})-(?\\<month\\>\\\\d{2})-(?\\<day\\>\\\\d{2})/\n);\n\nres.groups.year;  // \"2025\"\nres.groups.month; // \"01\"\nres.groups.day;   // \"09”\n\nКак получить конкретную группу\n\n| Способ | Пример |\n| ----- | ----- |\n| По индексу | result\\[1\\] |\n| По имени | result.groups.name |\n\nНекаптурирующие группы\n\n(?:...)\n\n* Группируют выражение\n* **НЕ сохраняются** в результат\n\n/(?:ab)+/\nИспользуются для оптимизации и читаемости.\nОбратные ссылки (Backreferences)\nЧто такое обратная ссылка\nОбратная ссылка — это обращение к **уже захваченной группе**.\nОбратные ссылки в шаблоне\n\nПо номеру\t/(a)(b)\\\\2\\\\1/\nСовпадёт с:\tabba\nПример: повторяющееся слово\t/\\\\b(\\\\w+)\\\\s+\\\\1\\\\b/\nСовпадёт:\thello hello\nИменованные обратные ссылки\t/(?\\<word\\>\\\\w+)\\\\s+\\\\k\\<word\\>/\nОбратные ссылки в замене (replace)\n\n'John Smith'.replace(/(\\\\w+)\\\\s+(\\\\w+)/, '$2 $1');\n// \"Smith John\"\n\n| Синтаксис | Значение |\n| ----- | ----- |\n| $1 | группа 1 |\n| $2 | группа 2 |\n| $\\<name\\> | именованная группа |\n\nЧастые ошибки\n❌ Использовать номер группы после некаптурирующей\n❌ Забывать, что группы считаются **слева направо**\n❌ Использовать группы, когда нужны ?:\n\nКогда использовать группы\n\n* Парсинг структурированных строк\n* Валидация форматов\n* Повторяющиеся шаблоны\n* Переиспользование частей шаблона\n\n**Краткий ответ для собеседования**\n\nСкобочные группы позволяют захватывать части совпадения. Получить их можно через match или exec: полное совпадение находится в result\\[0\\], а группы — начиная с result\\[1\\]. Также существуют именованные группы, доступные через result.groups. Обратные ссылки позволяют ссылаться на ранее захваченные группы — по номеру \\\\1 или по имени \\\\k\\<name\\> — и используются для поиска повторяющихся фрагментов или при замене.",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-poluchit-vse-skobochnye-gruppy-kak-poluchit-konkretnuyu-ssylki-na-skobochnye-gruppy"
    },
    {
        "id": 179,
        "title": "Как указываются и зачем нужны? (Опережающие и ретроспективные проверки)",
        "answer": "Опережающие и ретроспективные проверки (Lookaround)\nЧто это такое\n\n**Lookaround** — это специальные конструкции регулярных выражений, которые:\n\n* **проверяют условие**\n* **не захватывают символы**\n* **не включают их в результат совпадения**\n\nИными словами: *«совпадает, если рядом есть / нет что-то»*.\n\nЗачем нужны\nИспользуются, когда необходимо:\n\n* проверить контекст **до или после** совпадения\n* **не включать** этот контекст в результат\n* выполнять сложную валидацию без лишних групп\n\nВиды lookaround\n\n| Тип | Название | Синтаксис |\n| ----- | ----- | ----- |\n| (?=...) | Положительный опережающий | lookahead |\n| (?\\!...) | Отрицательный опережающий | lookahead |\n| (?\\<=...) | Положительный ретроспективный | lookbehind |\n| (?\\<\\!...) | Отрицательный ретроспективный | lookbehind |\n\nОпережающая проверка (Lookahead)\nПроверяет, **что находится справа**, не захватывая это.\nПоложительная (?=...)\t/\\\\d(?=px)/\nСовпадёт с:\t10px → 0\n\n* цифра есть\n* **после неё px**\n* px в результат не входит\n\nОтрицательная (?\\!...)\t\t/\\\\d(?\\!px)/\nСовпадёт с:\t10em → 0\nНЕ совпадёт с:\t10px\nРетроспективная проверка (Lookbehind)\nПроверяет, **что находится слева** от совпадения.\nПоложительная (?\\<=...)\t/(?\\<=\\\\$)\\\\d+/\nСовпадёт:\t$100 → 100\n\n* $ есть слева\n* $ не входит в результат\n\nОтрицательная (?\\<\\!...)\t/(?\\<\\!\\\\$)\\\\d+/\nСовпадёт:\t100\nНЕ совпадёт:\t$100\nПримеры реальных задач\nНайти слово, после которого стоит \\!\t/\\\\w+(?=\\!)/\nНайти число без знака валюты\t/(?\\<\\!\\\\$)\\\\d+/\nПроверка пароля\t/^(?=.\\*\\\\d)(?=.\\*\\[A-Z\\]).{8,}$/\nЗдесь:\n\n* (?=.\\*\\\\d) — есть цифра\n* (?=.\\*\\[A-Z\\]) — есть заглавная буква\n* основное совпадение — длина\n\nОтличие от скобочных групп\n\n| Скобки | Lookaround |\n| ----- | ----- |\n| Захватывают | Не захватывают |\n| Попадают в результат | Не попадают |\n| Можно ссылаться | Нельзя |\n\nОграничения\n\n* Lookbehind **должен быть фиксированной длины** (в JS)\n* Не поддерживается в старых браузерах\n* Может снижать производительность\n\nЧастые ошибки\n❌ Ожидать, что lookaround появится в match\n❌ Использовать группы вместо lookaround\n❌ Делать сложный lookbehind с переменной длиной\n\nКраткий ответ для собеседования\nLookahead и lookbehind — это проверки контекста в регулярных выражениях. Они позволяют проверить, что справа или слева от совпадения есть или нет определённый шаблон, не включая его в результат. Используются для валидации и точного поиска без захвата лишних символов. Синтаксис: (?=...), (?\\!...), (?\\<=...), (?\\<\\!...).",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kak-ukazyvayutsya-i-zachem-nuzhny"
    },
    {
        "id": 180,
        "title": "Какие методы могут работать используя регулярные выражения ? (Методы RegExp и String)",
        "answer": "Методы, работающие с регулярными выражениями\nВ JavaScript с регулярными выражениями работают **два набора методов**:\n\n1. **Методы объекта RegExp**\n2. **Методы строк (String)**, принимающие RegExp\n\n1\\. Методы RegExp\n\nregexp.test(str)\n**Назначение:** проверить, есть ли совпадение\n**Возвращает:** true | false\n/\\\\d+/.test(\"abc123\"); // true\n\n* Быстрый\n* Часто используется в if\n* Меняет lastIndex при флаге g\n\nregexp.exec(str)\n**Назначение:** найти совпадение\n**Возвращает:** Array | null\n/\\\\d+/.exec(\"abc123\");\n\nРезультат:\n\\[\n\"123\",\nindex: 3,\ninput: \"abc123\",\ngroups: undefined\n\\]\n\nОсобенности:\n\n* Работает пошагово с флагом g\n* Возвращает группы захвата\n* Используется для сложного парсинга\n\n2\\. Методы String, принимающие RegExp\n\nstr.match(regexp)\n**Назначение:** получить совпадения\n\"abc123def456\".match(/\\\\d+/g);\n// \\[\"123\", \"456\"\\]\n\nПоведение:\n\n* без g → как exec\n* с g → массив совпадений **без групп**\n\nstr.matchAll(regexp)\n**Назначение:** получить **все совпадения с группами**\n**Возвращает:** Iterator\n\\[...\"a1 b2\".matchAll(/(\\\\w)(\\\\d)/g)\\];\nКаждый элемент:\n\n* полное совпадение\n* группы\n* index\n* input\n\n⚠️ **Требует флаг g**\n\nstr.search(regexp)\n**Назначение:** найти индекс первого совпадения\n**Возвращает:** number | \\-1\n\"abc123\".search(/\\\\d+/); // 3\n\n* Флаг g игнорируется\n* Аналог indexOf, но с RegExp\n\nstr.replace(regexp, replacement)\n**Назначение:** замена\t\t\"abc123\".replace(/\\\\d+/g, \"\\#\"); // \"abc\\#\"\nreplacement может быть:\n\n* строкой ($&, $1, $\\<name\\>)\n* функцией\n\n\"10px\".replace(/\\\\d+/, n \\=\\> n \\* 2);\t// \"20px\"\nstr.replaceAll(regexp, replacement)\n\n* Заменяет **все совпадения**\n* Регулярка **обязана иметь флаг g**\n\n\"a1b2\".replaceAll(/\\\\d/g, \"\\_\");\t\t// \"a\\_b\\_\"\nstr.split(regexp)\n**Назначение:** разбить строку\n\"a, b; c\".split(/\\[,;\\]/);\t// \\[\"a\", \" b\", \" c\"\\]\n\n* Можно использовать группы\n* Часто применяется для парсинга\n\nСводная таблица\n\n| Метод | Где | Возвращает | Назначение |\n| ----- | ----- | ----- | ----- |\n| test | RegExp | boolean | Проверка |\n| exec | RegExp | Array / null | Поиск \\+ группы |\n| match | String | Array / null | Совпадения |\n| matchAll | String | Iterator | Все совпадения \\+ группы |\n| search | String | number | Индекс |\n| replace | String | string | Замена |\n| replaceAll | String | string | Замена всех |\n| split | String | Array | Разделение |\n\nЧастые вопросы на собеседовании\n\nПочему match и exec ведут себя по-разному?\n\n* match с g **не возвращает группы**\n* exec всегда возвращает группы\n\nКогда использовать matchAll?\n\n* Когда нужны **все совпадения \\+ группы**\n* При парсинге сложных структур\n\nПочему test иногда даёт странные результаты?\n\n* Из-за флага g и lastIndex\n\nconst r \\= /\\\\d/g;\nr.test(\"1\"); // true\nr.test(\"1\"); // false\n\n**Краткий ответ для собеседования**\n\nВ JavaScript с регулярными выражениями работают методы RegExp — test, exec, и методы строк — match, matchAll, search, replace, replaceAll, split. Методы строк принимают RegExp и позволяют искать, заменять и разбивать строки, а RegExp-методы используются для проверки и пошагового парсинга с доступом к группам.\n\n# TypeScript\n\n1. Какие основные типы есть? Что такое enum, void, any, never, tuples, unknown? Почему нужно избегать использование any? (Основные типы)\n2. Что такое интерфейс? Как указать опциональные параметры? Как указать параметры только для чтения? Как расширить существующий интерфейс? В чем отличие от типа? (Интерфейс)\n3. Для чего нужны ? Как использовать? Как обьединение нескольких интерфейсов сузить до одного интерфейса ? (Защитники типа)\n4. Как убрать определенные свойства из интерфейса? Как использовать только некоторые свойства из интерфейса? Как сделать все поля необязательными и наоборот? (Unitily типы)\n5. Какие модификаторы доступа существуют? Как происходит наследование? (Классы)\n6. Типизация параметров, опциональные параметры, возвращаемый тип. (Больше о функциях)\n7. Как у функции указать динамический тип? Зачем это нужно? Как указать что динамический тип должен иметь определнные свойства ? Динамический тип по умолчанию ? (Дженерики)",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-metody-mogut-rabotat-ispol-zuya-regulyarnye-vyrazheniya"
    },
    {
        "id": 181,
        "title": "Какие основные типы есть? Что такое enum, void, any, never, tuples, unknown? Почему нужно избегать использование any? (Основные типы)",
        "answer": "Основные типы TypeScript\n\nПримитивные типы:string, number, boolean\nДополнительно:null, undefined\nСпециальные типы:any\n**Что это:** отключает проверку типов\nlet value: any \\= 5;\nvalue.foo.bar(); // допустимо\n**Почему избегаем:**\n\n* ломает типовую безопасность\n* ошибки переносятся в runtime\n* ухудшает автодополнение\n* делает код неотличимым от JS\n\n**Использовать только:**\n\n* при миграции старого JS\n* для временных заглушек\n\nunknown\n**Безопасная альтернатива any**\nlet value: unknown;\nvalue.toUpperCase(); // ошибка\nМожно использовать **только после проверки типа**:\nif (typeof value \\=== \"string\") {\nvalue.toUpperCase();\n}\n\nvoid\n\n**Функция ничего не возвращает**\nfunction log(): void {\nconsole.log(\"hello\");\n}\n\n* фактически возвращает undefined\n* используется в функциях и callbacks\n\nnever\n\n**Функция никогда не завершится корректно**\nfunction throwError(): never {\nthrow new Error(\"Error\");\n}\n\nИспользуется:\n\n* бесконечные циклы\n* throw\n* проверка исчерпывающих switch\n\nСоставные типы\narray\nnumber\\[\\]\nArray\\<string\\>\ntuple\n**Массив с фиксированной структурой**\nconst user: \\[number, string\\] \\= \\[1, \"Anna\"\\];\n\n* порядок и типы строго заданы\n* удобны для return значений\n\nОбъектные типы\nobject\n{}\nRecord\\<K, V\\>\nenum\n**Набор именованных констант**\nenum Status {\nPending,\nSuccess,\nError\n}\nМожно задавать значения:\nenum Role {\nAdmin \\= \"ADMIN\",\nUser \\= \"USER\"\n}\n\nОсобенности:\n\n* компилируется в JS\n* можно использовать как тип и как значение\n\n⚠️ В новых проектах часто заменяют:\n\ntype Role \\= \"ADMIN\" | \"USER\";\n\nСравнение ключевых типов\n\n| Тип | Назначение |\n| ----- | ----- |\n| any | Полное отключение типизации |\n| unknown | Безопасный входной тип |\n| void | Отсутствие возвращаемого значения |\n| never | Код недостижим |\n| tuple | Фиксированный массив |\n| enum | Именованные константы |\n\n**Короткий ответ для собеседования**\n\nTypeScript расширяет JavaScript статической типизацией. Помимо примитивов string, number, boolean, есть специальные типы: any — отключает проверки и потому нежелателен; unknown — безопасная альтернатива; void — для функций без возвращаемого значения; never — для функций, которые никогда не завершаются. Также используются tuple для массивов с фиксированной структурой и enum для наборов именованных констант.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "kakie-osnovnye-tipy-est-chto-takoe-enum-void-any-never-tuples-unknown-pochemu-nuzhno-izbegat-ispol-zovanie-any"
    },
    {
        "id": 182,
        "title": "Что такое интерфейс? Как указать опциональные параметры? Как указать параметры только для чтения? Как расширить существующий интерфейс? В чем отличие от типа? (Интерфейс)",
        "answer": "Что такое интерфейс (interface)?\n\n**Interface** — это контракт структуры объекта.\nОн описывает **какие поля и методы должен иметь объект**, не задавая реализацию.\ninterface User {\nid: number;\nname: string;\n}\n\nИспользуется для:\n\n* объектов\n* параметров функций\n* классов\n* публичных API\n\nКак указать опциональные параметры?\n\nИспользуется ? после имени свойства:\ninterface User {\nid: number;\nemail?: string;\n}\n\n* поле может отсутствовать\n* тип будет string | undefined\n\nКак указать параметры только для чтения?\n\nИспользуется ключевое слово readonly:\ninterface User {\nreadonly id: number;\nname: string;\n}\nuser.id \\= 5; // ❌ ошибка\n\n* защита от изменения\n* удобно для id, токенов, конфигураций\n\nКак расширить существующий интерфейс?\n\nИспользуется extends:\ninterface Person {\nname: string;\n}\n\ninterface User extends Person {\nid: number;\n}\nМожно расширять **несколько интерфейсов**:\ninterface User extends Person, Timestamped {}\nВ чем отличие interface от type?\nГлавное различие\n\n| Критерий | interface | type |\n| ----- | ----- | ----- |\n| Расширение | extends | & (intersection) |\n| Объединение | ❌ | \\` |\n| Declaration merging | ✅ | ❌ |\n| Использование для примитивов | ❌ | ✅ |\n| Использование для функций | ✅ | ✅ |\n\nDeclaration Merging (ключевое отличие)\ninterface User {\nname: string;\n}\n\ninterface User {\nage: number;\n}\n\n➡️ **Объединятся автоматически**\n\nUser {\nname: string;\nage: number;\n}\nС type так **нельзя**.\n\nКогда использовать interface, а когда type?\n\nИспользуй interface, если:\n\n* описываешь объекты\n* проектируешь публичный API\n* работаешь с классами\n* важна расширяемость\n\nИспользуй type, если:\n\n* нужны union или tuple\n* описываешь примитивы\n* комбинируешь сложные типы\n\n**Короткий ответ для собеседования**\n\nInterface в TypeScript — это контракт структуры объекта. Опциональные свойства задаются через ?, свойства только для чтения — через readonly. Интерфейсы расширяются с помощью extends и поддерживают declaration merging. В отличие от type, интерфейсы нельзя использовать для union-типов, но они лучше подходят для описания объектов и публичных API.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "chto-takoe-interfeys-kak-ukazat-optsional-nye-parametry-kak-ukazat-parametry-tol-ko-dlya-chteniya-kak-rasshirit-suschestvuyuschiy-interfeys-v-chem-otlichie-ot-tipa"
    },
    {
        "id": 183,
        "title": "Для чего нужны ? Как использовать? Как объединение нескольких интерфейсов сузить до одного интерфейса ? (Защитники типа)",
        "answer": "Для чего нужны защитники типов (Type Guards)?\n\n**Type Guards** используются для **уточнения (сужения) типа значения во время выполнения**, чтобы TypeScript понимал, **с каким конкретным типом мы работаем** внутри блока кода.\nОни решают проблему работы с:\n\n* union типами (A | B)\n* unknown\n* any (частично)\n* сложными объектами\n\nКак использовать защитники типов?\n1\\. typeof — для примитивов\nfunction log(value: string | number) {\nif (typeof value \\=== \"string\") {\nvalue.toUpperCase(); // string\n}\n}\n2\\. instanceof — для классов\nclass User {}\nclass Admin {}\n\nfunction check(user: User | Admin) {\nif (user instanceof Admin) {    // Admin  }\n}\n\n3\\. Проверка наличия свойства (in)\n\ntype User \\= { name: string };\ntype Admin \\= { role: string };\nfunction check(person: User | Admin) {\nif (\"role\" in person) {    // Admin  }\n}\n\n4\\. Пользовательский type guard (is)\n\ntype User \\= { name: string };\ntype Admin \\= { name: string; role: string };\nfunction isAdmin(p: User | Admin): p is Admin {  return \"role\" in p;}\nfunction handle(p: User | Admin) {\nif (isAdmin(p)) {    p.role; // Admin  }\n}\n\n➡️ **Это самый мощный и правильный способ**\n\nКак объединение нескольких интерфейсов сузить до одного?\nИспользуется **type guard**, который проверяет уникальные признаки интерфейса.\n\nПример\n\ninterface Car {  speed: number;}\ninterface Plane {  altitude: number;}\nfunction isPlane(v: Car | Plane): v is Plane {  return \"altitude\" in v;}\n\nfunction move(v: Car | Plane) {\nif (isPlane(v)) {\nv.altitude;\n} else {    v.speed;  }\n}\n\nВстроенные защитники типов\n\n* Array.isArray(value)\n* value instanceof Class\n* typeof value \\=== \"string\"\n* value \\!== null\n\nВажное замечание (Middle+)\n\nType guards:\n\n* работают **во время выполнения**\n* влияют на **типизацию на этапе компиляции**\n* не меняют реальный тип объекта\n\n**Короткий ответ для собеседования**\n\nType guards нужны для сужения union-типов во время выполнения. Они позволяют TypeScript точно понимать тип внутри блока кода. Используются typeof, instanceof, in, а также пользовательские функции с предикатом value is Type. Это основной способ сузить несколько интерфейсов до одного.",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "dlya-chego-nuzhny-kak-ispol-zovat-kak-ob-edinenie-neskol-kih-interfeysov-suzit-do-odnogo-interfeysa"
    },
    {
        "id": 184,
        "title": "Как убрать определенные свойства из интерфейса? Как использовать только некоторые свойства из интерфейса? Как сделать все поля необязательными и наоборот? (Unitily типы)",
        "answer": "Как убрать определённые свойства из интерфейса?\n\nИспользуется Omit\\<T, K\\> — **исключает поля из типа**.\ninterface User {\nid: number;\nname: string;\npassword: string;\n}\ntype PublicUser \\= Omit\\<User, \"password\"\\>;\n\n➡️ Удаляет одно или несколько свойств.\n\nКак использовать только некоторые свойства из интерфейса?\nИспользуется Pick\\<T, K\\> — **выбирает нужные поля**.\ntype UserPreview \\= Pick\\<User, \"id\" | \"name\"\\>;\n\nКак сделать все поля необязательными?\nИспользуется Partial\\<T\\>:\ntype UpdateUser \\= Partial\\<User\\>;\nВсе свойства становятся ?.\n\nКак сделать все поля обязательными?\n\nИспользуется Required\\<T\\>:\ntype FullUser \\= Required\\<Partial\\<User\\>\\>;\n\nЧасто используемые Utility Types\nReadonly\\<T\\>\nЗапрещает изменение свойств:  type ReadonlyUser \\= Readonly\\<User\\>;\n\nRecord\\<K, T\\>\nСоздаёт объект с заданными ключами:  type Roles \\= Record\\<\"admin\" | \"user\", boolean\\>;\n\nExclude\\<T, U\\>\nИсключает типы из union:\ntype Status \\= \"success\" | \"error\" | \"loading\";\ntype Visible \\= Exclude\\<Status, \"loading\"\\>;\n\nExtract\\<T, U\\>\nОставляет пересечение типов:  type Visible \\= Extract\\<Status, \"error\" | \"loading\"\\>;\n\nNonNullable\\<T\\>\nУбирает null | undefined:\ntype Safe \\= NonNullable\\<string | null\\>;\n\n**Короткий ответ для собеседования**\n\nДля работы с частями интерфейса используются utility-типы: Pick — выбрать поля, Omit — исключить, Partial — сделать поля необязательными, Required — обязательными, Readonly — только для чтения. Они позволяют переиспользовать и модифицировать типы без дублирования.\n\nЧастая ошибка\n\n❌ Модифицировать интерфейс вручную\n✅ Использовать utility types",
        "category": "Types",
        "difficulty": "Medium",
        "slug": "kak-ubrat-opredelennye-svoystva-iz-interfeysa-kak-ispol-zovat-tol-ko-nekotorye-svoystva-iz-interfeysa-kak-sdelat-vse-polya-neobyazatel-nymi-i-naoborot"
    },
    {
        "id": 185,
        "title": "Какие модификаторы доступа существуют? Как происходит наследование? (Классы)",
        "answer": "Модификаторы доступа в классах\n\nTypeScript поддерживает три основных модификатора доступа:\n\n| Модификатор | Доступ | Описание |\n| ----- | ----- | ----- |\n| public | Везде | Доступно из любого места. По умолчанию все поля и методы public. |\n| private | Только внутри класса | Доступно **только в самом классе**. Наследники не видят. |\n| protected | Внутри класса и наследников | Доступно внутри класса и классов-наследников. Вне класса недоступно. |\n\nПример\n\nclass User {\npublic name: string;\nprivate password: string;\nprotected role: string;\n\nconstructor(name: string, password: string, role: string) {\nthis.name \\= name;\nthis.password \\= password;\nthis.role \\= role;\n}\n\nprivate checkPassword(pwd: string) {\nreturn this.password \\=== pwd;\n}\n}\n\n* user.name — доступно\n* user.password — ❌ ошибка\n* this.role в наследнике — ✅ доступно\n\nНаследование в классах\nКлючевое слово extends\n\n* Позволяет создать класс-наследник, который **наследует свойства и методы родителя**.\n* Наследник может **переопределять методы** и использовать super для вызова родительского конструктора или методов.\n\nclass Admin extends User {\nconstructor(name: string, password: string) {\nsuper(name, password, \"admin\"); // вызывает конструктор родителя\n}\n\nshowRole() {\nconsole.log(this.role); // protected доступно\n}\n}\n\n* private поля родителя **невидимы** наследнику\n* protected поля доступны наследнику\n* public поля и методы доступны везде\n\nВажные моменты\n\n* Если метод наследника **переопределяет** метод родителя, можно вызывать super.method()\n* Конструктор наследника **обязано должен вызвать super()**, если родительский конструктор требует параметры\n* Наследование может быть **многоуровневым**, но TypeScript поддерживает только одиночное наследование (extends один класс)\n* Для множественного поведения используют **миксины или интерфейсы**\n\n**Короткий ответ для собеседования**\n\nВ TypeScript классы имеют модификаторы доступа: public (везде), private (только внутри класса), protected (класс \\+ наследники). Наследование происходит через extends. Наследник получает public и protected свойства родителя, может переопределять методы и вызывать родительский конструктор через super().",
        "category": "General",
        "difficulty": "Medium",
        "slug": "kakie-modifikatory-dostupa-suschestvuyut-kak-proishodit-nasledovanie"
    },
    {
        "id": 186,
        "title": "Типизация параметров, опциональные параметры, возвращаемый тип. (Больше о функциях)",
        "answer": "Типизация параметров\n\nВ TypeScript **каждому параметру можно указать тип**:\nfunction sum(a: number, b: number): number {\nreturn a \\+ b;\n}\n\n* a: number — параметр a типа number\n* b: number — параметр b типа number\n* : number после скобок — тип **возвращаемого значения**\n\n**Примечание:** Если тип возвращаемого значения не указан, TypeScript **выведет его автоматически**.\n\nОпциональные параметры\n\nИспользуется ? после имени параметра:\nfunction greet(name: string, title?: string) {\nconsole.log(\\`Hello ${title ? title \\+ \" \" : \"\"}${name}\\`);\n}\n\n* Параметр title может отсутствовать\n* Внутри функции его тип: string | undefined\n\nПараметры по умолчанию\n\nfunction greet(name: string, title: string \\= \"Mr./Ms.\") {\nconsole.log(\\`Hello ${title} ${name}\\`);\n}\n\n* Если аргумент не передан, используется значение по умолчанию\n* Такой параметр автоматически считается опциональным\n\nОстаточные параметры (rest)\n\nДля передачи переменного числа аргументов:\nfunction sumAll(...numbers: number\\[\\]): number {\nreturn numbers.reduce((a, b) \\=\\> a \\+ b, 0);\n}\n\n* numbers: number\\[\\] — массив чисел\n* Можно передавать любое количество аргументов\n\nТип возвращаемого значения\n\nУказывается после скобок:\nfunction multiply(a: number, b: number): number {\nreturn a \\* b;\n}\n\n* TypeScript проверяет, чтобы функция возвращала значение указанного типа\n* Можно явно указать void для функций без return:\n\nfunction logMessage(msg: string): void {\nconsole.log(msg);\n}\n\nТипизация функций как переменных\n\nlet fn: (x: number, y: number) \\=\\> number;\nfn \\= (a, b) \\=\\> a \\+ b;\n\n* (x: number, y: number) \\=\\> number — тип функции\n* Параметры и возвращаемое значение проверяются TypeScript\n\nПолезные комбинации\n\nfunction fetchData(id: number, options?: { cache?: boolean }): Promise\\<string\\> {\nreturn Promise.resolve(\\`Data for ${id}\\`);\n}\n\n* Опциональный объект с опциональными полями\n* Функция возвращает Promise\\<string\\>\n\n**Короткий ответ для собеседования**\n\nВ TypeScript функция типизируется через указание типов параметров и возвращаемого значения. Опциональные параметры задаются через ?, параметры по умолчанию могут быть пропущены. Остаточные параметры позволяют передавать переменное число аргументов. Типизация функций как переменных позволяет проверять сигнатуру функции на этапе компиляции.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "tipizatsiya-parametrov-optsional-nye-parametry-vozvraschaemyy-tip"
    },
    {
        "id": 187,
        "title": "Как у функции указать динамический тип? Зачем это нужно? Как указать что динамический тип должен иметь определнные свойства ? Динамический тип по умолчанию ? (Дженерики)",
        "answer": "Что такое дженерики и зачем они нужны?\n\n**Generics** позволяют задавать **динамический тип для функции, класса или интерфейса**, чтобы она могла работать с **разными типами данных** при сохранении **типовой безопасности**.\n\nПример без дженериков (небезопасно)\n\nfunction identity(value: any) {\nreturn value;\n}\nconst num \\= identity(42); // тип any\nnum.toFixed(); // ✅, но TS не знает, что это число\n\n* Использование any теряет проверку типов\n\nПример с дженериком\n\nfunction identity\\<T\\>(value: T): T {\nreturn value;\n}\nconst num \\= identity\\<number\\>(42); // T \\= number\nnum.toFixed(); // ✅ безопасно\nconst str \\= identity\\<string\\>(\"hello\"); // T \\= string\nstr.toUpperCase(); // ✅ безопасно\n\n* \\<T\\> — placeholder для типа\n* Тип определяется при вызове функции (или выводится TypeScript автоматически)\n\nКак указать, что динамический тип должен иметь определённые свойства?\n\nИспользуем **ограничение через extends**:\ninterface HasId {\nid: number;\n}\n\nfunction getId\\<T extends HasId\\>(obj: T) {\nreturn obj.id;\n}\ngetId({ id: 10, name: \"John\" }); // ✅ работает\ngetId({ name: \"John\" }); // ❌ ошибка, нет id\n\n* Ограничение T extends HasId говорит: «тип T **должен иметь поле id**»\n\nКак задать динамический тип по умолчанию?\n\nМожно указать значение по умолчанию:\nfunction wrap\\<T \\= string\\>(value: T) {\nreturn { value };\n}\n\nconst a \\= wrap(\"hello\"); // T \\= string\nconst b \\= wrap(42);      // T \\= number, выведен автоматически\n\n* Если тип не указан явно, используется string\n\nДженерики в классах и интерфейсах\n\nclass Box\\<T\\> {\nconstructor(public content: T) {}\n}\nconst numBox \\= new Box\\<number\\>(123);\nconst strBox \\= new Box(\"hello\"); // TS выведет T \\= string\n\n* Работает также для интерфейсов и типов:\n\ninterface ApiResponse\\<T\\> {\ndata: T;\nerror?: string;\n}\n\nПочему это важно?\n\n* Позволяет **переиспользовать код** без потери типизации\n* Исключает использование any\n* Делает API функций и классов **гибким и безопасным**\n\n**Короткий ответ для собеседования**\n\nДженерики позволяют задавать динамический тип для функции, класса или интерфейса. Ограничения через extends гарантируют, что тип имеет необходимые свойства. По умолчанию можно задать тип через \\<T \\= DefaultType\\>. Это важно для переиспользуемого и типобезопасного кода.",
        "category": "Functions",
        "difficulty": "Medium",
        "slug": "kak-u-funktsii-ukazat-dinamicheskiy-tip-zachem-eto-nuzhno-kak-ukazat-chto-dinamicheskiy-tip-dolzhen-imet-opredelnnye-svoystva-dinamicheskiy-tip-po-umolchaniyu"
    }
];
