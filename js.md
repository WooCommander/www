# Список вопросов

Основы JavaScript

1. Как объявить константу и переменную, в чем отличие? Что такое var и почему не используем? Правильное наименование. (переменные и константы)  
2. Какие основные типы данны? Что будет при делении на 0? Что будет при ""\\2 ? Что такое value и reference типы? В чём разница между null и undefined? Какие значения являются falsy? Как узнать тип переменной? (типы данных)  
3. Что такое явное и неявное преобразование? Особенности преобразование к number и boolean. (преобразование типов)  
4. В каком порядке выполняются операторы? Как взять остаток от деления, возвести в степень? (Базовые операторы Таблица приоритетов)  
5. В чём разница между двойным и тройным равно?  Каков принцип сравнения строк и разных типов? Сравнение null и undefined с числами. (Операторы сравнения)  
6. Как обработать несколько случаев одной функцией?  Как тернарно можно заменить if else? (Условное ветвление)  
7. Какие логические операторы знаете? Что возвращают? (Логические операторы)  
8. Как работает ?? В чем отличие от ||? (Оператор объединения с null '??')  
9. Какие вариации цикла while существуют? В чем отличие? (**Циклы while и for**)  
10. Что такое break и continue? Что делает break? Почему нужно всегда указывать default? (Конструкция "switch")  
11. Как работать с функциями? Что такое чистая функция? Отличие function declaration от function expression? Отличие стрелочных функций от function? (Функции, Function expression Стрелочные функции)

Объекты и функции

1. Как добавить свойство в объекте? Как удалить свойство из объекта? Как проверить что свойство существует? Как можно перебирать свойтсва? (Объекты)  
2. Что такое копирование по ссылке? Как сделать полную копию объекта? Какие проблемы есть при копировании по ссылке? Что такое вложенное клонирование? Глобальный метод для клонирования объектов? (Копирование объектов, Глоб.метод для клонирования)  
3. Как добавить метод в свойство объекта? Что такое this и как оно себя ведёт? Чему будет равно this указанное вне функций? Как работает this в стрелочных функциях? (Методы объекта)  
4. Что такое конструктор? Что такое new? Как ведёт себя return в конструкторе?  (Конструктор, new)  
5. Для чего нужен оператор «?» Как работает с функциями и массивами? Какую проблему решает? (Опциональная цепочка)  
6. Зачем нужен? Сравнение символов. Глобальные символы. Получаем символы через Object.keys? Как получить символы объекта? (Symbol  )  
7. Когда используется? Какие варианты преобразований? Какие способы задания преобразующих функций? Какие ограничения по возвращаемым значениям? Какой приоритет выполнения методов преобразований при разных операциях? (Объекты в примитивы)

Типы данных

1. Почему у примитивов есть методы? В чём разница между number и new Number? (Методы примитивов)   
2. Какими способами можно записать число? Как можно округлисть число в различные стороны? Какой результат 0.1 \+ 0.2? Как получить случайное число? Как получить число из строки? Как найти минимальное\\максимальное число между числами?(Числа)  
3. В чём разница между различными кавычками и зачем это надо? Какие спец.символы есть? Как получить доступ к символу? Как изменить регистр строки или только первой буквы? Как найти последее и первое вхождение? Методы как вырезать подстроку? Как происходит сравнение строк? Правильное сравнение. Теговые шаблоны. (Строки)   
4. Как объявить массив? Как получить доступ к № элементу? Как добавить и удалить элемент с начала и с конца? Как перебрать все элементы c помощью цикла? (Массивы)  
5. Как объединить два массива? Методы удаления элементов (по признаку, по индексу) и что они возвращают? Как перебрать массив (c возвращением нового массива или undefined)? (Методы массивов)   
6. Как найти элемент массива с начала и с конца и получить к нему доступ по индексу? Какие методы позволяют узнать что в массиве есть элемент и получить его (самого, индекс , или просто boolean о его наличии)? Как отсортировать массив? Как преобразовать массив к строке ? (Методы массивов(basicWeb))   
7. Как получить единое значение на основе всего массива? Как проверить что все или один элемент подходят по условию? Как сделать вложенный массив плоским? (Методы массивов(MDN))   
8. Как работает for of? Как добавить итератор, что должен возвращать? Как создать массив из итератора или псевдомассива? (Итераторы)  
9. Какие ключи могут быть? Как быстро сделать уникальную выборку? (Map и Set)   
10. Как достать все свойства объекта? Как достать все значения объекта? Как достать все свойства со значениями? Все ли свойства будут возвращены таким образом? Метода создания обьекта из массива свойств и значений ? Object в Map , Map в Object (keys, values, entries)  
11. Как с помощью деструктуризации работать с обьектами\\массивами ? Операции rest и spread. (Деструктуризация)  
12.  Как получить текущую дату? Как получить завтрашнюю дату? Как узнать какой сейчас день, месяц, год? Как считать дату из форматированной строки? Как получить смещение часового пояса ? (Дата и время)   
13. Как работать с JSON ? В каком случае stringify не работает? Какие типы данных не попадают в JSON? Как переопределить вывод JSON.stringify ? (JSON)

Продвинутая работа с функциями

1. Максимальная глубина рекурсии. Что такое контекст выполнения функции ? Что такое стек контекстов выполнения ? (Рекурсия и стек)  
2. Сколько аргумемнтов может быть у функции? Как получить все аргументы не зная их названий? Что такое arguments и как работает в стрелочных функциях? Как можно объединить два массива? (Остаточные параметры и оператор расширения)  
3. Что такое замыкание? Что такое IIFE? Что такое лексическое окружение? Что будет если функция не найдет переменную в теле? Что происходит внутри циклов? (Замыкание)  
4. Что лежит внутри? Назовите несколько полезных свойств\\методов лежащих в глобальном обьекте (Глобальный объект)  
5. Какие свойства есть у объекта функции? Что такое именнованная функция исполнения NFE ? Для чего нужна? Можно ли задать свои свойства в обьект функции ? (Объект функции)  
6. Для чего нужна такая конструкция? В чём отличие? (New Function)  
7. Как сделать чтобы функция выполнилась только один раз через № времени? Как сделать чтобы выполнялась каждые № времени? Всегда ли функция сработает через № времени? Что происходит когда задаем timeout 0? (SetTimeout, setInterval)  
8. Что такое call и apply? Какую задачу решают? В чём отличие? Что такое декоратор? (Декораторы и переадресация вызова, call/apply)  
9. Что такое контекст? Как и зачем привязывать контекст? Как привязать контекст ко всем функциям объекта? (Привязка контекста к функции)

Работа с DOM API

10. Как происходит навигация по элементам DOM : 1\. к родителю 2\. к сестринским элементам 3\. к первому\\последнему дочернему 4\. получение списка дочерних (Навигация по DOM-элементам)  
11. Как происходит поиск элементов : 1\. по названию тэга 2\. по аттрибуту name 3\. по имени класса 4\. по id 5\. по селектору CSS ? Что возвращают эти методы? (Поиск: getElement\*, querySelector\*)  
12. Какие свойства есть у элемента DOM ? (Свойства узлов: тип, тег и содержимое)   
13. Какие способы вставки элемента есть : 1.перед элементов 2\. после элемента 3\. внутри дочерних вначале 4.внутри дочерних в конце ? Как удалить элемент из DOM дерева? (Изменение документа)

Работа с событиями JS

1. Какие свойства есть в обьекте события (элемент на котором висит обработчик, элемент который инициировал событие) ? Как повесить\\отменить событие ? Как повесить сразу несколько обработчиков на одно событие? Какой нюанс нужно учитывать при удалении обработчика события (подсказка: затрагивает ссылочный тип). Какие 3 стадии есть у события ? Как отменить всплытие сопытия ? Обьект события и его свойства. (Основы работы с событиями, стадии всплытия и погружения)  
2. Как отменить действие браузера по умолчанию ? (Действия браузера по умолчанию)

Свойства объекта, их конфигурация

1. Какие есть флаги? Способы их установки? Методы глобального запечатывания объекта. (Флаги и дескрипторы свойств)  
2. Что такое? Какие дескрипторы? (Свойства \- геттеры и сеттеры)

Прототипы, наследование

1. Что такое наследование? Где лежит прототип? Куда происходит запись? Какое значение this? Как получить только неунаследованные ключи?( Прототипное наследование)  
2. Как добавить прототип в функцию конструктор? Как экземпляр связывается с функционалом функции-конструктора ? (F.prototype Middle+ Какие встроеные прототипы есть? Как изменить встроеный прототип? Встроенные прототипы Middle- Как создать объект без прототипа? Зачем такое нужно? (Методы прототипов)

Классы

1. Что такое класс? Что такое конструктор класса и когда он создается? Как можно заменить класс , функцией конструктором ? (Класс)  
2. Как переопределить методы класса? Как переорпеделить конструктор? Что такое super? Как в этом участвуют прототипы? (Наследование классо)  
3. Что такое static? Могут ли быть класс, константа, функция статическими? Для чего это надо? (Статические свойства и методы)  
4. Как указать что поле приватное/защищённое? Какие выгоды это даёт? (Приватные и защищённые методы и свойства)  
5. Как происходит наследование статических методов? Middle Как расширить встроенный класс? Какое отличие наследования встроенных классов? (Расширение встроенных классов)  
6. Как проверить к какому классу принадлежит объект? Почему нельзя использовать typeOf? Как работает instanceOf ?( instanceOf)  
7. Как вынести общую логику между классами?(Примеси)

Обработка ошибок

1. Как обрабатывать ошибки? Как создать свою собственную ошибку? Как выполнить код после try и catch? Какие данные об ошибке мы можем получить? Какие есть глобальные обработчики ошибок ? (try catch)

Промисы

1. Что такое callback? Как обрабатывать ошибки? Как вызвать callback внутри callback? Есть ли недостатки?( Callback)  
2. Что такое Promise? Какие два состояния могут быть? Могут ли сработать оба состояния одновременно? Что делают resolve и reject? Как работать с результатом работы промиса? (Promise, Цепочка промисов)  
3. Как обрабатываются ошибки внутри промисов? Что будет если поставить then после catch? Что будет если не поставить catch? Второй аргуметр у then. (Промисы: обработка ошибок)  
4. all, allSettled, any, race, resolve, reject (Promise API)  
5. Что такое async/await? В каких функциях можно использовать await? Можно использовать await глобально? Как работает await с успешным\\отклоненым промисом? (async/await)

Генераторы

1. Зачем нужны генераторы? Какие методы генераторов? Где они используются? (Генераторы)  
2. Какие отличия от обычных? (Асинхронные итераторы и генераторы)

Общее (память\\событийный цикл)

1. Как JavaScript понимает, что пора очищать память? Принцип достижимости (Сборка мусора)  
2. В чем отличие от обычных Map и Set ? Для чего нужны ? (WeakMap и WeakSet)  
3. Что такое микрозадачи? Как работает очередь микрозадач? (Микрозадачи)  
4. В каком порядке выполняются задачи? Какие отличия микрозадач от макрозадач? (Событийный цикл)

Общее (доп.)

1. Как импортировать всё из модуля? Почему так делать не правильно? Как импортировать и экспортировать с другим названием? Что такое экспорт по умолчанию? Чем отличается и какие проблемы есть? (Экспорт и импорт)  
2. Как вывести текст в консоль? Как вывести предупреждение, ошибку? Как отобразить данные в виде таблицы? Как с помощью консоли засечь таймер ? (Console)  
3. Работа с модулем URL. Работа с модулем URLSearchParams. Какие методы для работы с модулями ? Для чего нужны ? (URL API)  
4. Как работает ? File и FileReader Middle Какие методы предоставляет и зачем? Как работать с датой , числами , строками ? Какие методы могут работать с параметрами как в Intl? (Intl)

Запросы и хранение данных

1. Для чего используется? Какие могут быть методы запросов? Какие могут быть статусы ответа? Возможные форматы body и ответа. Как работать с заголовками ? Как понять в какой тип парсить содержимое ответа ? (Fetch)  
2. Как устроен ? Для чего нужен? (CORS)   
3. Почему файлы отправляются этим форматом? Предоставляемые методы.(FormData)  
4. Как прервать зарос? Прерывание запроса Junior+ Как работать с localStorage, sessionStorage ? В чем между ними разница?( localStorage, sessionStorage)  
5. Как работать с куками ? Как удалить куку? (Куки)

Регулярки

1. Какие есть флаги? Как работает сивол границы слова с нелатиницей? (Шаблоны и флаги, Символьные классы, Граница слова)  
2. Символы для начала и конца строки. Отличия для многострочного режима (Якоря и многострочный режим)  
3. Как работает диапазон? Исключающий режим. Ветвления. (Спец символы, Наборы и диапазоны, Альтернация)  
4. Какие квантификаторы есть? Режимы работы (Квантификаторы, жадные и ленивые)   
5. Как получить все скобочные группы? Как получить конкретную? Ссылки на скобочные группы. (Скобочные группы, Обратные ссылки)  
6. Как указываются и зачем нужны? (Опережающие и ретроспективные проверки)  
7. Какие методы могут работать используя регулярные выражения ? (Методы RegExp и String)

TypeScript

1. Какие основные типы есть? Что такое enum, void, any, never, tuples, unknown? Почему нужно избегать использование any? (Основные типы)  
2. Что такое интерфейс? Как указать опциональные параметры? Как указать параметры только для чтения? Как расширить существующий интерфейс? В чем отличие от типа? (Интерфейс)  
3. Для чего нужны ? Как использовать? Как обьединение нескольких интерфейсов сузить до одного интерфейса ? (Защитники типа)  
4. Как убрать определенные свойства из интерфейса? Как использовать только некоторые свойства из интерфейса? Как сделать все поля необязательными и наоборот? (Unitily типы)  
5. Какие модификаторы доступа существуют? Как происходит наследование? (Классы)  
6. Типизация параметров, опциональные параметры, возвращаемый тип. (Больше о функциях)   
7. Как у функции указать динамический тип? Зачем это нужно? Как указать что динамический тип должен иметь определнные свойства ? Динамический тип по умолчанию ? (Дженерики)

# Основы JavaScript

1. Как объявить константу и переменную, в чем отличие? Что такое var и почему не используем? Правильное наименование. (переменные и константы)  
2. Какие основные типы данны? Что будет при делении на 0? Что будет при ""\\2 ? Что такое value и reference типы? В чём разница между null и undefined? Какие значения являются falsy? Как узнать тип переменной? (типы данных)  
3. Что такое явное и неявное преобразование? Особенности преобразование к number и boolean. (преобразование типов)  
4. В каком порядке выполняются операторы? Как взять остаток от деления, возвести в степень? (Базовые операторы Таблица приоритетов)  
5. В чём разница между двойным и тройным равно?  Каков принцип сравнения строк и разных типов? Сравнение null и undefined с числами. (Операторы сравнения)  
6. Как обработать несколько случаев одной функцией?  Как тернарно можно заменить if else? (Условное ветвление)  
7. Какие логические операторы знаете? Что возвращают? (Логические операторы)  
8. Как работает ?? В чем отличие от ||? (Оператор объединения с null '??')  
9. Какие вариации цикла while существуют? В чем отличие? (**Циклы while и for**)  
10. Что такое break и continue? Что делает break? Почему нужно всегда указывать default? (Конструкция "switch")  
11. Как работать с функциями? Что такое чистая функция? Отличие function declaration от function expression? Отличие стрелочных функций от function? (Функции, Function expression Стрелочные функции)

---

ОТВЕТЫ

### 1\. Как объявить константу и переменную, в чем отличие? Что такое var и почему не используем? Правильное наименование. (переменные и константы).

Объявление:  
let count \= 0;      // переменная  
const MAX\_USERS \= 5; // константа

Различия let и const

| Критерий | let | const |
| :---- | :---- | :---- |
| Переприсваивание | Можно | Нельзя |
| Блочная область видимости | Да | Да |
| Hoisting | Есть, но TDZ | Есть, но TDZ |
| Инициализация | Можно позже | Обязательно сразу |

let a;  
a \= 10;  
const b \= 5;  
// b \= 6 ❌

Что такое **var** и почему его не используют?

**var** — устаревший способ объявления переменных в JavaScript (до ES6).  
Почему var не используют

1. Функциональная, а не блочная область видимости  
2. Hoisting с инициализацией undefined  
3. Разрешено повторное объявление  
4. Проблемы в асинхронном коде  
5. Загрязнение глобальной области (window)

console.log(x); // undefined  
var x \= 10;  
Правильное наименование переменных и констант

Переменные

* camelCase  
* Говорящие имена  
* Глаголы для действий, существительные для данных

let userName;  
let isLoading;  
let totalPrice;

Константы

* SCREAMING\_SNAKE\_CASE — для глобальных/конфигурационных значений  
* camelCase — для локальных неизменяемых значений


const API\_URL \= "https://api.example.com";  
const maxItems \= 10;

Чего избегать  
let x;      // ❌ неинформативно  
let data;   // ❌ слишком общее  
let temp1;  // ❌

**Идеальная финальная формулировка:**  
В современном JavaScript переменные объявляются через let, а константы через const. const запрещает переприсваивание, но не делает объекты неизменяемыми. var — устаревший механизм с функциональной областью видимости и hoisting, из\-за чего может приводить к ошибкам, поэтому в новом коде не используется. Переменные именуются в camelCase, константы — в SCREAMING\_SNAKE\_CASE для глобальных значений.

---

### 2\. Какие основные типы данны? Что будет при делении на 0? Что будет при ""\\2 ? Что такое value и reference типы? В чём разница между null и undefined? Какие значения являются falsy? Как узнать тип переменной? (типы данных)

Какие основные типы данных в JavaScript?

**Примитивные** (value types): number, string, boolean, null, undefined, symbol, bigint.  
**Ссылочные** (reference types): object (включая Object, Array, Function, Date, Map, Set и т.д.)  
**Что будет при делении на 0?**

5 / 0 – Infinity; \-5 / 0 – \-Infinity; 0 / 0  –  NaN  
JavaScript **не выбрасывает ошибку**, а возвращает специальные числовые значения.  
**Что будет при " " / 2?**

"" / 2 – 0  
Пустая строка приводится к числу 0\. Оператор / выполняет **неявное приведение типов**.  
**Value и Reference типы**

Value

* Хранятся и передаются **как копия**  
* Изменение не влияет на оригинал

let a \= 5;  
let b \= a;  
b \= 10;  
// a \=== 5

Reference

* Хранятся и передаются **по ссылке**  
* Изменения видны во всех ссылках

const obj1 \= { x: 1 };  
const obj2 \= obj1;  
obj2.x \= 2;  
// obj1.x \=== 2

Разница между null и undefined

| Критерий | null | undefined |
| ----- | ----- | ----- |
| Значение | намеренно задано | не инициализировано |
| Тип | object (баг) | undefined |
| Использование | задаётся вручную | значение по умолчанию |

let a;        // undefined  
let b \= null; // null  
**Falsy значения**: Значения, приводящиеся к false:false, 0, \-0, 0n, "", null, undefined, NaN

**Как узнать тип переменной?**

Основной способ: **typeof** value;  
Особенности typeof  
typeof null      // "object" ❌  
typeof \[\]        // "object"  
typeof function(){} // "function"  
Корректные проверки  
Array.isArray(val);    // массив  
val \=== null;          // null  
Number.isNaN(val);     // NaN

**Идеальная финальная формулировка**

В JavaScript есть примитивные типы, которые передаются по значению, и ссылочные типы, которые передаются по ссылке. Деление на ноль не выбрасывает ошибку, а возвращает Infinity или NaN. Язык допускает неявное приведение типов, например пустая строка при делении приводится к нулю. null — это намеренное отсутствие значения, undefined — отсутствие инициализации. Тип значения можно определить через typeof, учитывая его ограничения.

---

### 3\. Что такое явное и неявное преобразование? Особенности преобразование к number и boolean. (преобразование типов)

Неявное преобразование (Implicit Coercion)  
Происходит **автоматически движком JavaScript** при выполнении операций, когда типы операндов не совпадают.  
"2" \* 2  // 4; "5" \- 1 // 4; true \+ 1 // 2  
Используется операторами: \+, \-, \*, /, \==, логическими операциями.  
Явное преобразование (Explicit Coercion)  
Выполняется **разработчиком намеренно** с помощью встроенных функций.  
Number("5")   // 5; String(10) // "10"; Boolean(1) // true

**Преобразование к number**

**Неявное**: "10" \- 2    // 8; " " / 2     // 0; true \* 2    // 2, false \+ 1   // 1  
**Явное**: Number("10") – 10; Number("abc") –  NaN; Number("") –  0; Number(null) – 0; Number(undefined) – NaN

Важные нюансы

* NaN — результат неудачного числового преобразования  
* NaN \!== NaN  
* Проверка: Number.isNaN()

**Преобразование к boolean**

Falsy значения: false, 0, \-0, 0n, "", null, undefined, NaN  
Truthy — всё остальное, включая: "0", "false", \[\], {}

**Идеальная финальная формулировка**

Явное преобразование выполняется разработчиком с помощью функций Number, String, Boolean. Неявное преобразование происходит автоматически при выполнении операций над значениями разных типов. Наиболее сложные преобразования связаны с приведением к number и boolean, поэтому в продакшн-коде рекомендуется использовать явное приведение и строгие сравнения.

---

### 4\. В каком порядке выполняются операторы? Как взять остаток от деления, возвести в степень? (Базовые операторы Таблица приоритетов)

Операторы выполняются согласно **приоритету операторов** — от более высокого к более низкому.  
При равном приоритете учитывается **ассоциативность** (слева направо или справа налево).  
Ключевые группы приоритетов (от высокого к низкому)

1. Группировка (...)  
2. Постфиксные  value++; value--  
3. Унарные \++value; \--value; \!value; \+value; typeof  
4. Возведение в степень \*\*   // ассоциативность справа налево  
5. Умножение / деление / остаток \*  /  %  
6. Сложение / вычитание \+  \-  
7. Сравнение \< \> \<= \>=  
8. Равенство \== \!= \=== \!==  
9. Логические  &&; ||  
10. Тернарный condition ? a : b  
11. Присваивание  \= \+= \-= \*= /= \*\*=

## 

Как взять остаток от деления?  
Используется оператор %  
5 % 2 // 1  
10 % 3 // 1  
Важно:

* % — это **остаток**, а не математический модуль  
* С отрицательными числами результат может быть отрицательным

Как возвести в степень?  
**Современный способ**  2 \*\* 3 // 8  
**Старый способ** Math.pow(2, 3); // 8  
Примеры приоритета  
2 \+ 3 \* 4      // 14		(2 \+ 3\) \* 4    // 20  
2 \*\* 3 \*\* 2    // 512		// 2 \*\* (3 \*\* 2\)  
Практическое правило

* Всегда используйте **скобки**, если порядок неочевиден  
* Не полагайтесь на знание всей таблицы приоритетов

Идеальная формулировка для собеседования  
Операторы в JavaScript выполняются согласно таблице приоритетов. Сначала выполняются унарные и арифметические операции, затем сравнения, логические операции и присваивание. Остаток от деления вычисляется оператором %, а возведение в степень — оператором \*\*, который имеет правую ассоциативность.

---

### 5\. В чём разница между двойным и тройным равно? Каков принцип сравнения строк и разных типов? Сравнение null и undefined с числами. (Операторы сравнения)

Разница между \== и \===

| Оператор | Проверяет | Преобразование типов |
| ----- | ----- | ----- |
| \== | только значение | **неявное приведение типов** (coercion) |
| \=== | значение и тип | **строгое сравнение**, без приведения |

Примеры  
5 \== "5"    // true  (строка \-\> число)			5 \=== "5"   // false (разные типы)  
null \== undefined  // true				null \=== undefined // false  
**Принцип сравнения строк**

* Сравниваются **символы по Unicode** (лексикографически)  
* Приведение к числу не выполняется  ("2" \> "10" // true, потому что "2" \> "1" (первый символ))  
* Если один операнд **не строка**, выполняется приведение к числу ("5" \> 3 // true, "5" \-\> 5\)

**Сравнение разных типов**

1. **Булевы значения** → преобразуются к числу (true → 1, false → 0\)  
2. **Строка и число** → строка преобразуется к числу  
3. **null / undefined** имеют особые правила:

**Сравнение 			Результат**  
null \== undefined		true  
null \=== undefined		false  
null \> 0			false  
null \< 1			true  
undefined \> 0			false  
undefined \< 1			false  
undefined \== 0		false  
**Важно:** null и undefined при числовом сравнении ведут себя по-разному.  
Ключевые правила

* Использовать \=== и \!== по умолчанию  
* \== допустимо только при проверке **null/undefined**  
* Всегда учитывать **неявное приведение типов** для чисел и строк

**Идеальная формулировка для собеседования**

\== проверяет только значение с неявным приведением типов, а \=== проверяет значение и тип без приведения. При сравнении строк учитывается порядок символов Unicode, а при сравнении разных типов происходит приведение: строки → числа, булевы → числа. null равен только undefined при \==, но с числами сравнивается особым образом. В продакшн-коде рекомендуется использовать строгое сравнение (===).

---

### 6\. Как обработать несколько случаев одной функцией? Как тернарно можно заменить if else? (Условное ветвление) 

**Как обработать несколько случаев одной функцией?**  
**1\. Используем if…else if…else**  
function checkNumber(num) {  
  if (num \> 0\) {  
    return "Положительное";  
  } else if (num \< 0\) {  
    return "Отрицательное";  
  } else {  
    return "Ноль";  
  }  
}

* Можно обрабатывать **любое количество случаев**  
* Удобно для диапазонов и сложных условий

**2\. Используем switch**  
function getDayName(day) {  
  switch(day) {  
    case 1:  
      return "Понедельник";  
    case 2:  
      return "Вторник";  
    case 3:  
      return "Среда";  
    default:  
      return "Другой день";  
  }  
}

* Чаще используется для **сравнения с конкретными значениями**  
* Блоки case могут объединяться  
* Неявно сравнивает через \===

**3\. Объект/Map как словарь**  
const messages \= {  
  1: "Понедельник",  
  2: "Вторник",  
  3: "Среда",  
};

function getMessage(day) {  
  return messages\[day\] || "Другой день";  
}

* Альтернатива множественным if или switch  
* Удобно для статических соответствий

**Как тернарно заменить if…else**  
Синтаксис:  
condition ? valueIfTrue : valueIfFalse  
**Примеры**  
let age \= 18;  
let status \= age \>= 18 ? "Взрослый" : "Несовершеннолетний";  
Можно вкладывать тернарные операторы:  
let num \= 0;  
let sign \= num \> 0 ? "Положительное" : num \< 0 ? "Отрицательное" : "Ноль";

**Важно:** вложенные тернарные операторы **не должны быть слишком сложными** — читаемость важнее.

**Идеальная формулировка для собеседования**

Чтобы обработать несколько случаев одной функцией, используют if…else if…else, switch или словари (объекты/Map). Для простых условных выражений можно использовать тернарный оператор condition ? valueIfTrue : valueIfFalse, а для нескольких вариантов допускаются вложенные тернарные выражения, хотя для читаемости лучше использовать if или switch.

### 7\. Какие логические операторы знаете? Что возвращают? (Логические операторы)

Какие логические операторы есть в JavaScript?  
Основные логические операторы:

1. && — логическое И  
2. || — логическое ИЛИ  
3. \! — логическое НЕ  
4. ?? — nullish coalescing (ES2020)

Что возвращают логические операторы?  
Логические операторы в JavaScript **возвращают не true/false, а один из операндов**.

Оператор && (И)

* Возвращает **первое falsy значение**  
* Если все значения truthy — возвращает **последнее**

true && "text"      // "text"		0 && "text"         // 0		"a" && 5 && true    // true

Используется для:

* проверки условий  
* условного выполнения кода

isAuth && loadData();

Оператор || (ИЛИ)

* Возвращает **первое truthy значение**  
* Если все falsy — возвращает **последнее**

false || "default"  // "default"			0 || 10    // 10

Используется для:

* задания значений по умолчанию

const name \= input || "Guest";

Оператор \! (НЕ)

* Приводит значение к boolean и инвертирует его

\!true       // false		\!\!"text"    // true

\!\! — распространённый способ явного приведения к boolean.

Оператор ?? (Nullish coalescing)

* Возвращает **первое значение, которое не null и не undefined**  
* **Не считает 0, "", false ошибочными**

0 ?? 10    // 0			null ?? 10   // 10		undefined ?? 5 // 5  
Разница || и ?? (важно)

0 || 10   // 10 ❌  
0 ?? 10   // 0  ✅  
**Идеальная формулировка для собеседования**

В JavaScript есть логические операторы &&, ||, \! и ??. Они используют short-circuit и возвращают не логическое значение, а один из операндов. && возвращает первое falsy значение, || — первое truthy, \! инвертирует boolean, а ?? работает только с null и undefined, что удобно для значений по умолчанию.

### 8\. Как работает ?? В чем отличие от ||? (Оператор объединения с null '??')

Как работает оператор ?? (Nullish Coalescing)?  
?? возвращает **первый операнд, который не равен null и не равен undefined**.  
Если левый операнд — null или undefined, возвращается правый.  
const value \= a ?? b;

**Примеры**

null ?? "default"        // "default"  
undefined ?? 10          // 10  
0 ?? 10                  // 0  
"" ?? "text"             // ""  
false ?? true            // false

**Отличие ?? от ||**

Ключевая разница

* || работает с **falsy значениями**  
* ?? работает **только с null и undefined**

**Сравнение**  
0 || 10     // 10  ❌  
0 ?? 10     // 0  ✅

"" || "x"   // "x" ❌  
"" ?? "x"   // ""  ✅

false || 1  // 1  ❌  
false ?? 1  // false ✅

**Когда использовать ??**

* Когда 0, "", false — **валидные значения**  
* Для значений по умолчанию из API, форм, настроек

const page \= params.page ?? 1;

**Важные ограничения**

* Нельзя напрямую смешивать ?? с && или || без скобок

// ❌ Ошибка  
a ?? b || c

// ✅ Правильно  
(a ?? b) || c

**Идеальная формулировка для собеседования**

Оператор ?? возвращает первый операнд, который не является null или undefined. В отличие от ||, он не считает 0, пустую строку или false ошибочными значениями. Это позволяет безопасно задавать значения по умолчанию, не затирая валидные данные.

### 9\. Какие вариации цикла while существуют? В чем отличие? (**Циклы while и for**)

**Какие вариации цикла while существуют?**  
В JavaScript есть **две формы цикла while**:

1. while  
2. do...while

Цикл while  
Синтаксис  
while (condition) {  
  // код  
}

Как работает

* Сначала проверяется условие  
* Затем выполняется тело цикла  
* Может не выполниться ни разу

Пример  
let i \= 0;  
while (i \< 3\) {  
  console.log(i);  
  i++;  
}

Цикл do...while  
Синтаксис  
do {  
  // код  
} while (condition);

Как работает

* Сначала выполняется тело  
* Затем проверяется условие  
* Выполняется **минимум один раз**

Пример  
let i \= 0;  
do {  
  console.log(i);  
  i++;  
} while (i \< 0);

В чём отличие while и do...while

| Критерий | while | do...while |
| :---- | :---- | :---- |
| Проверка условия | До выполнения | После выполнения |
| Минимум итераций | 0 | 1 |
| Использование | когда условие заранее известно | когда тело должно выполниться хотя бы раз |

Сравнение с for

Цикл for  
for (let i \= 0; i \< 3; i++) {  
  console.log(i);  
}  
Когда использовать

* for — когда известны начало, конец и шаг  
* while — когда неизвестно количество итераций  
* do...while — когда требуется минимум одна итерация

**Идеальная формулировка для собеседования**

В JavaScript есть два варианта цикла while: обычный while, где условие проверяется до выполнения тела, и do...while, который выполняется как минимум один раз. while используют, когда количество итераций заранее неизвестно, а do...while — когда код должен выполниться хотя бы один раз. В отличие от них, for удобен, когда известны начальные и конечные значения.

### 10\. Что такое break и continue? Что делает break? Почему нужно всегда указывать default? (Конструкция "switch")

**Что такое break и continue?**

break

* **Прерывает выполнение цикла или switch полностью**  
* Управление передаётся за пределы конструкции

for (let i \= 0; i \< 5; i++) {  
  if (i \=== 2\) break;  
  console.log(i); // 0, 1  
}

Используется также в switch.

continue

* **Пропускает текущую итерацию цикла**  
* Переходит к следующей итерации

for (let i \= 0; i \< 5; i++) {  
  if (i \=== 2\) continue;  
  console.log(i); // 0, 1, 3, 4  
}  
⚠️ В switch **continue не используется**.  
**Что делает break в switch?**

* Завершает выполнение текущего case  
* Предотвращает **fall-through** (проваливание в следующий case)

switch (value) {  
  case 1:  
    doA();  
    break;  
  case 2:  
    doB();  
    break;  
}  
Без break код продолжит выполняться дальше.  
**Почему нужно всегда указывать default в switch?**

Причины

1. **Обработка неожиданных значений**  
2. **Защита от багов**  
3. **Повышение читаемости**  
4. **Логирование ошибок**

switch (status) {  
  case "success":  
    handleSuccess();  
    break;  
  case "error":  
    handleError();  
    break;  
  default:  
    handleUnknown();  
}

Важно

* default — аналог else  
* Выполняется, если **ни один case не совпал**  
* Может быть размещён **в любом месте**, но по стандарту — в конце

**Идеальная формулировка для собеседования**

break завершает выполнение цикла или конструкции switch, а continue пропускает текущую итерацию цикла. В switch оператор break используется для предотвращения fall-through. Блок default обязателен, так как позволяет обработать неожиданные значения и делает поведение конструкции предсказуемым.

### 11\. Как работать с функциями? Что такое чистая функция? Отличие function declaration от function expression? Отличие стрелочных функций от function? (Функции, Function expression Стрелочные функции)

**Как работать с функциями в JavaScript?**

Функции — это **первоклассные объекты**:

* могут быть присвоены переменным  
* переданы как аргументы  
* возвращены из других функций

function sum(a, b) {  
  return a \+ b;  
}

**Что такое чистая функция?**

**Чистая функция** — функция, которая:

1. **При одинаковых входных данных всегда возвращает одинаковый результат**  
2. **Не имеет побочных эффектов**

Побочные эффекты:

* изменение внешних переменных  
* мутация аргументов  
* работа с DOM  
* HTTP-запросы, console.log

// ❌ не чистая  
let total \= 0;  
function add(x) {  
  total \+= x;  
}

// ✅ чистая  
function add(a, b) {  
  return a \+ b;  
}

**Function Declaration vs Function Expression**

Function Declaration  
function foo() {  
  return "hello";  
}

* Поднимается целиком (hoisting)  
* Доступна до объявления  
* Имеет имя

Function Expression  
const foo \= function () {  
  return "hello";  
};

* Не поднимается как функция  
* Выполняется только после объявления  
* Может быть анонимной

Ключевое отличие  
Function Declaration доступна до объявления, Function Expression — нет.

**Стрелочные функции vs обычные функции**  
Синтаксис  
const sum \= (a, b) \=\> a \+ b;  
Основные отличия

| Критерий | Function | Arrow function |
| ----- | ----- | ----- |
| this | динамический | **лексический** |
| arguments | есть | нет |
| new | можно | нельзя |
| Hoisting | да (declaration) | нет |
| super | есть | нет |

Пример this  
const obj \= {  
  value: 10,  
  getValue: () \=\> this.value  
};

obj.getValue(); // undefined

Когда использовать стрелочные функции

* Колбэки (map, filter, reduce)  
* Когда нужен лексический this  
* Короткие функции без контекста

Когда НЕ использовать стрелочные функции

* Методы объекта  
* Конструкторы  
* Когда нужен собственный this

**Идеальная формулировка для собеседования**

Функции в JavaScript являются объектами первого класса. Чистая функция не имеет побочных эффектов и возвращает одинаковый результат для одинаковых входных данных. Function Declaration поднимается целиком и доступна до объявления, в отличие от Function Expression. Стрелочные функции отличаются лексическим this, отсутствием arguments и невозможностью использования как конструктор.

# Объекты и функции

1. Как добавить свойство в объекте? Как удалить свойство из объекта? Как проверить что свойство существует? Как можно перебирать свойтсва? (Объекты)  
2. Что такое копирование по ссылке? Как сделать полную копию объекта? Какие проблемы есть при копировании по ссылке? Что такое вложенное клонирование? Глобальный метод для клонирования объектов? (Копирование объектов, Глоб.метод для клонирования)  
3. Как добавить метод в свойство объекта? Что такое this и как оно себя ведёт? Чему будет равно this указанное вне функций? Как работает this в стрелочных функциях? (Методы объекта)  
4. Что такое конструктор? Что такое new? Как ведёт себя return в конструкторе?  (Конструктор, new)  
5. Для чего нужен оператор «?» Как работает с функциями и массивами? Какую проблему решает? (Опциональная цепочка)  
6. Зачем нужен? Сравнение символов. Глобальные символы. Получаем символы через Object.keys? Как получить символы объекта? (Symbol  )  
7. Когда используется? Какие варианты преобразований? Какие способы задания преобразующих функций? Какие ограничения по возвращаемым значениям? Какой приоритет выполнения методов преобразований при разных операциях? (Объекты в примитивы)

### 1\. Как добавить свойство в объекте? Как удалить свойство из объекта? Как проверить что свойство существует? Как можно перебирать свойтсва? (Объекты)

**Как добавить свойство в объект?**

Через точку  
const user \= {};  
user.name \= "Anna";  
Используется, когда имя свойства известно заранее.

Через квадратные скобки  
user\["age"\] \= 25;  
user\[key\] \= "value";  
Используется для динамических ключей.

**Как удалить свойство из объекта?**

delete user.age;  
**Удаляет свойство из объекта.**  
⚠️ Важно: delete влияет на производительность, для частых операций лучше использовать иммутабельные подходы.  
**Как проверить, что свойство существует?**

1\. in   "name" in user; 

Проверяет наличие свойства **в объекте и прототипе**.  
2\. hasOwnProperty  user.hasOwnProperty("name");  
Проверяет только **собственные свойства**.  
3\. Проверка на undefined (не рекомендуется)   user.name \!== undefined;  
Не отличает отсутствие свойства от значения undefined.

**Как перебирать свойства объекта?**

for...in  
for (const key in user) {  
  if (user.hasOwnProperty(key)) {  
    console.log(key, user\[key\]);  
  }  
}  
Перебирает также свойства прототипа.

Object.keys()  
Object.keys(user); // \["name", "age"\]  
Возвращает массив ключей.

Object.values()  
Object.values(user); // \["Anna", 25\]

Object.entries()  
Object.entries(user); // \[\["name", "Anna"\], \["age", 25\]\]

Удобно для map, forEach.

**Идеальная формулировка для собеседования**

Свойства в объект добавляются через точечную нотацию или квадратные скобки. Удаление выполняется оператором delete. Проверить наличие свойства можно через in или hasOwnProperty, в зависимости от необходимости учитывать прототип. Перебирать свойства можно с помощью for...in или методов Object.keys, Object.values и Object.entries.

### 2\. Что такое копирование по ссылке? Как сделать полную копию объекта? Какие проблемы есть при копировании по ссылке? Что такое вложенное клонирование? Глобальный метод для клонирования объектов? (Копирование объектов, Глоб.метод для клонирования)

**Что такое копирование по ссылке?**

Копирование по ссылке означает, что **переменные ссылаются на один и тот же объект в памяти**.  
const a \= { x: 1 };  
const b \= a;

b.x \= 2;  
a.x; // 2

Изменения через одну ссылку видны через другую.

Какие проблемы есть при копировании по ссылке?

* Неожиданная мутация данных  
* Сложность отладки  
* Побочные эффекты  
* Ошибки в React/Redux (нарушение иммутабельности)

**Как сделать полную копию объекта?**

Поверхностное копирование (shallow copy)  
Копируются только свойства первого уровня.  
const copy1 \= { ...obj };  
const copy2 \= Object.assign({}, obj);

❌ Вложенные объекты всё ещё копируются по ссылке.

**Что такое вложенное клонирование?**

**Вложенное (глубокое) клонирование** — копирование объекта **со всеми вложенными уровнями**, без общих ссылок.  
Способы глубокого клонирования

1\. structuredClone() — глобальный метод (лучший вариант)  
const clone \= structuredClone(obj);

✔ Глубокое копирование  
✔ Поддерживает Date, Map, Set  
❌ Не копирует функции, DOM, Symbol

2\. JSON.parse(JSON.stringify()) (ограниченный способ)  
const clone \= JSON.parse(JSON.stringify(obj));

❌ Теряет undefined, функции, Date, Map, Set  
❌ Не работает с циклическими ссылками

3\. Рекурсивное клонирование  
Используется при кастомной логике.

**Глобальный метод для клонирования объектов**

**structuredClone()** — стандартный глобальный метод для глубокого клонирования объектов.

**Идеальная формулировка для собеседования**

Копирование по ссылке означает, что несколько переменных указывают на один объект, из\-за чего изменения отражаются везде. Поверхностное копирование копирует только верхний уровень, а вложенные объекты остаются по ссылке. Для полного вложенного клонирования используется structuredClone, который выполняет глубокое копирование без общих ссылок.

### 3\. Как добавить метод в свойство объекта? Что такое this и как оно себя ведёт? Чему будет равно this указанное вне функций? Как работает this в стрелочных функциях? (Методы объекта)

**Как добавить метод в объект?**

Метод — это функция, являющаяся свойством объекта.  
Классический способ  
const user \= {  
  name: "Anna",  
  sayHi: function () {  
    return \`Hi, ${this.name}\`;  
  }  
};  
Сокращённый синтаксис (ES6)  
const user \= {  
  name: "Anna",  
  sayHi() {  
    return \`Hi, ${this.name}\`;  
  }  
};  
Динамическое добавление  
user.logout \= function () {  
  this.isAuth \= false;  
};

**Что такое this?**

this — это **контекст вызова функции**, то есть объект, от имени которого она была вызвана.  
this определяется **в момент вызова**, а не в момент объявления (кроме стрелочных функций).

**Чему равно this вне функций?**

* **В браузере (не в strict mode)** — window  
* **В strict mode** — undefined  
* **В модулях (type="module")** — undefined

console.log(this); // window или undefined

**Как работает this в обычных функциях?**

const user \= {  
  name: "Anna",  
  sayHi() {  
    console.log(this.name);  
  }  
};  
user.sayHi(); // "Anna"

Если функцию вызвать без объекта:  
const fn \= user.sayHi;  
fn(); // undefined (или ошибка в strict mode)  
**Как работает this в стрелочных функциях?**

* **Стрелочные функции не имеют собственного this**  
* Они **берут this из внешнего лексического окружения**

const user \= {  
  name: "Anna",  
  sayHi: () \=\> {  
    console.log(this.name);  
  }  
};  
user.sayHi(); // undefined

Правило  
❌ Не использовать стрелочные функции как методы объекта  
✔ Использовать стрелочные функции в колбэках

**Идеальная формулировка для собеседования**

Метод — это функция, являющаяся свойством объекта. this указывает на объект, от имени которого была вызвана функция. Вне функций this ссылается на глобальный объект или undefined в строгом режиме. Стрелочные функции не имеют собственного this и берут его из внешнего контекста, поэтому их не используют как методы объектов.

### 4\. Что такое конструктор? Что такое new? Как ведёт себя return в конструкторе?  (Конструктор, new)

**Что такое конструктор?**

**Конструктор** — это функция, предназначенная для **создания и инициализации объектов одного типа**.  
По соглашению:

* имя с **заглавной буквы**  
* вызывается через new

function User(name) {  
  this.name \= name;  
}

**Что такое new и как он работает?**

Оператор new выполняет **4 шага**:

1. Создаёт новый пустой объект  
2. Устанавливает прототип:  
   obj.\_\_proto\_\_ \= Constructor.prototype  
3. Привязывает this к созданному объекту  
4. Возвращает объект (если return не переопределён)

const user \= new User("Anna");

**Как ведёт себя return в конструкторе?**

1\. return с объектом  
Если вернуть объект — **он заменит this**:  
function User() {  
  this.name \= "Anna";  
  return { name: "Kate" };  
}  
new User(); // { name: "Kate" }  
2\. return с примитивом  
Примитив **игнорируется**, возвращается this:  
function User() {  
  this.name \= "Anna";  
  return 123;  
}  
new User(); // { name: "Anna" }  
3\. Без return  
Возвращается созданный объект (this).

Важные ограничения

* Конструктор **нельзя вызывать без new** (в strict mode — ошибка)  
* Стрелочные функции **не могут быть конструкторами**  
* new ломает контекст this при забывчивости

**Идеальная формулировка для собеседования**

Конструктор — это функция, используемая для создания объектов, которая вызывается через new. Оператор new создаёт объект, связывает его с прототипом конструктора, устанавливает this и возвращает объект. Если в конструкторе явно вернуть объект, он заменит this; если вернуть примитив — он будет проигнорирован.

### 5\. Для чего нужен оператор «?» Как работает с функциями и массивами? Какую проблему решает? (Опциональная цепочка)

**Для чего нужен оператор ?.?**

Оператор **опциональной цепочки (?.)** используется для **безопасного доступа к свойствам, методам и элементам массивов**, которые могут быть null или undefined.  
Он предотвращает ошибку:  
*Cannot read property of undefined*

**Какую проблему он решает?**

Без ?.:  
user && user.profile && user.profile.name;  
С ?.:  
user?.profile?.name;

✔ Код короче  
✔ Читаемее  
✔ Без runtime-ошибок

**Как работает ?.?**

* Если значение **null или undefined**, выражение возвращает undefined  
* Дальнейшее вычисление **останавливается** (short-circuit)

Использование с объектами			user?.name;		user?.address?.city;  
Использование с функциями		user.sayHi?.();  
Функция вызывается **только если существует**.  
Использование с массивами 		users?.\[0\]?.name;  
Безопасный доступ по индексу.

**Сочетание с ??**

const name \= user?.profile?.name ?? "Guest";

Ограничения

* Работает **только с null и undefined**  
* Не ловит ошибки других типов  
* Нельзя использовать слева от присваивания

user?.name \= "Anna"; // ❌ ошибка

**Идеальная формулировка для собеседования**

Оператор опциональной цепочки ?. позволяет безопасно обращаться к свойствам, методам и элементам массивов, которые могут быть null или undefined. Он предотвращает runtime-ошибки и заменяет цепочки логических проверок, останавливая выполнение при первом null или undefined.

### 6\. Зачем нужен? Сравнение символов. Глобальные символы. Получаем символы через Object.keys? Как получить символы объекта? (Symbol  )

**Зачем нужен Symbol?**

Symbol — это **примитивный уникальный идентификатор**, который используется для:

* создания **уникальных ключей объектов**  
* предотвращения **конфликтов имён свойств**  
* создания **скрытых или приватных свойств**

const id \= Symbol("id");  
const obj \= {};  
obj\[id\] \= 123;

Сравнение символов

* Символы **всегда уникальны**, даже если имеют одинаковое описание:

const sym1 \= Symbol("key");  
const sym2 \= Symbol("key");  
sym1 \=== sym2; // false

* Гарантирует уникальность ключей

Глобальные символы

* Создаются через Symbol.for("name")  
* Если символ с таким ключом уже существует — возвращается **тот же символ**, иначе создаётся новый

const globalSym \= Symbol.for("app.key");  
const sameSym \= Symbol.for("app.key");  
globalSym \=== sameSym; // true

* Используются для **глобальных реестров и общих ключей**

Как получить символы объекта?

* **Object.keys(obj)** возвращает только **строковые ключи**, символы не включаются  
* Чтобы получить символы, используем:

Object.getOwnPropertySymbols(obj);

* Для получения **всех свойств** (строки \+ символы):

Reflect.ownKeys(obj);

Пример

const sym \= Symbol("secret");  
const obj \= { name: "Anna", \[sym\]: 123 };

Object.keys(obj);            // \["name"\]  
Object.getOwnPropertySymbols(obj); // \[Symbol(secret)\]  
Reflect.ownKeys(obj);        // \["name", Symbol(secret)\]

**Идеальная формулировка для собеседования**

Symbol — это примитив, создающий уникальные идентификаторы для свойств объектов, предотвращая конфликты имён. Символы всегда уникальны, даже с одинаковым описанием. Для глобальных символов используется Symbol.for, который гарантирует одну и ту же ссылку на символ. Строковые ключи объекта получают через Object.keys, символы — через Object.getOwnPropertySymbols, а все ключи — через Reflect.ownKeys.

### 7\. Когда используется? Какие варианты преобразований? Какие способы задания преобразующих функций? Какие ограничения по возвращаемым значениям? Какой приоритет выполнения методов преобразований при разных операциях? (Объекты в примитивы)

**Преобразование объектов в примитивы**

В JavaScript объекты иногда автоматически приводятся к примитивным типам — **числу, строке или булеву значению**, например:  
const obj \= { value: 10 };  
console.log(obj \+ 5); // ?

Это называется **ToPrimitive**.

**Когда используется?**

* Арифметические операции (+, \-, \*, /)  
* Конкатенация строк  
* Логические операции, условия (if(obj))  
* Сравнения (==, \<, \>)

**Какие варианты преобразований?**

1. **String** — объект преобразуется в строку  
2. **Number** — объект преобразуется в число  
3. **Default** — зависит от операции (+ строка/число)

Способы задания преобразующих функций

1\. Метод toString()

* Должен возвращать строку

const obj \= {  
  toString() { return "10"; }  
};

2\. Метод valueOf()

* Должен возвращать число или объект

const obj \= {  
  valueOf() { return 20; }  
};

3\. Метод \[Symbol.toPrimitive\](hint)

* Универсальный способ  
* hint \= "string" | "number" | "default"

const obj \= {  
  \[Symbol.toPrimitive\](hint) {  
    if (hint \=== "number") return 10;  
    if (hint \=== "string") return "hello";  
    return true;  
  }  
};

Ограничения по возвращаемым значениям

* Должен возвращать **примитив** (string, number, boolean, symbol, null, undefined)  
* Возврат объекта вызовет **TypeError** при преобразовании в примитив

const obj \= {  
  toString() { return {}; }  
};  
console.log(obj \+ ""); // TypeError  
Приоритет выполнения методов

| Операция | Метод преобразования |
| ----- | ----- |
| Арифметика (+, \-, \*, /) | valueOf → toString (default \= number) |
| Конкатенация (+ со строкой) | toString → valueOf (default \= string) |
| Явное приведение (String(obj)) | toString → valueOf |
| Явное приведение (Number(obj)) | valueOf → toString |
| \[Symbol.toPrimitive\] | Приоритет над toString/valueOf |

Пример работы

const obj \= {  
  valueOf() { return 10; },  
  toString() { return "20"; },  
  \[Symbol.toPrimitive\](hint) {  
    if (hint \=== "number") return 30;  
    return "hello";  
  }  
};

console.log(+obj);        // 30  
console.log(\`${obj}\`);    // "hello"  
console.log(obj \+ 5);     // "hello5" (default → string)

**Идеальная формулировка для собеседования**

Объекты преобразуются в примитивы автоматически при арифметике, конкатенации, логике и сравнении. Преобразование можно задать через методы toString, valueOf или \[Symbol.toPrimitive\](hint). Методы должны возвращать **примитив**. Приоритет: \[Symbol.toPrimitive\] \> valueOf \> toString, с учётом типа операции (string, number, default). Это позволяет контролировать поведение объекта при автоматическом приведении типов.

# Типы данных

1. Почему у примитивов есть методы? В чём разница между number и new Number? (Методы примитивов)   
2. Какими способами можно записать число? Как можно округлисть число в различные стороны? Какой результат 0.1 \+ 0.2? Как получить случайное число? Как получить число из строки? Как найти минимальное\\максимальное число между числами?(Числа)  
3. В чём разница между различными кавычками и зачем это надо? Какие спец.символы есть? Как получить доступ к символу? Как изменить регистр строки или только первой буквы? Как найти последее и первое вхождение? Методы как вырезать подстроку? Как происходит сравнение строк? Правильное сравнение. Теговые шаблоны. (Строки)   
4. Как объявить массив? Как получить доступ к № элементу? Как добавить и удалить элемент с начала и с конца? Как перебрать все элементы c помощью цикла? (Массивы)  
5. Как объединить два массива? Методы удаления элементов (по признаку, по индексу) и что они возвращают? Как перебрать массив (c возвращением нового массива или undefined)? (Методы массивов)   
6. Как найти элемент массива с начала и с конца и получить к нему доступ по индексу? Какие методы позволяют узнать что в массиве есть элемент и получить его (самого, индекс , или просто boolean о его наличии)? Как отсортировать массив? Как преобразовать массив к строке ? (Методы массивов(basicWeb))   
7. Как получить единое значение на основе всего массива? Как проверить что все или один элемент подходят по условию? Как сделать вложенный массив плоским? (Методы массивов(MDN))   
8. Как работает for of? Как добавить итератор, что должен возвращать? Как создать массив из итератора или псевдомассива? (Итераторы)  
9. Какие ключи могут быть? Как быстро сделать уникальную выборку? (Map и Set)   
10. Как достать все свойства объекта? Как достать все значения объекта? Как достать все свойства со значениями? Все ли свойства будут возвращены таким образом? Метода создания обьекта из массива свойств и значений ? Object в Map , Map в Object (keys, values, entries)  
11. Как с помощью деструктуризации работать с обьектами\\массивами ? Операции rest и spread. (Деструктуризация)  
12.  Как получить текущую дату? Как получить завтрашнюю дату? Как узнать какой сейчас день, месяц, год? Как считать дату из форматированной строки? Как получить смещение часового пояса ? (Дата и время)   
13. Как работать с JSON ? В каком случае stringify не работает? Какие типы данных не попадают в JSON? Как переопределить вывод JSON.stringify ? (JSON)

### 1\. Почему у примитивов есть методы? В чём разница между number и new Number? (Методы примитивов) 

**Почему у примитивов есть методы?**

* Примитивы (string, number, boolean, symbol, bigint) **не являются объектами**, но у них есть методы.  
* При обращении к методу JS **временно создаёт объект-обёртку** (wrapper object), вызывает метод и **удаляет объект**.

const str \= "hello";  
console.log(str.toUpperCase()); // "HELLO"  
// Внутренне: new String(str).toUpperCase()

* Это называется **автообёртка примитива** (autoboxing).

Разница между number и new Number

Примитив  
const a \= 5;  
typeof a; // "number"

* Лёгкий тип, хранит только значение  
* Методы работают через автообёртку  
* Сравнение с \=== работает как ожидалось

Объект Number  
const b \= new Number(5);  
typeof b; // "object"

* Содержит **значение внутри объекта**  
* Любые методы работают напрямую  
* **Сравнение строго (===) с примитивом — false**

5 \=== new Number(5); // false

* Обычно создавать объекты через new Number **не нужно**, используют только примитивы.

**Идеальная формулировка для собеседования**

Примитивы имеют методы благодаря автообёртке: JavaScript временно создаёт объект-обёртку, вызывает метод и удаляет объект. Примитив number — лёгкий тип для хранения значения, тогда как new Number создаёт объект с числовым значением, что влияет на сравнение и производительность. На практике используют примитивы.

### 2\. Какими способами можно записать число? Как можно округлисть число в различные стороны? Какой результат 0.1 \+ 0.2? Как получить случайное число? Как получить число из строки? Как найти минимальное\\максимальное число между числами?(Числа)

**1\. Какими способами можно записать число?**

* **Десятичная система** (обычно)		let a \= 42;  
* **Шестнадцатеричная**			let a \= 0x2A; // 42  
* **Восьмеричная (ES6)**			let a \= 0o52; // 42  
* **Двоичная (ES6)**				let a \= 0b101010; // 42  
* **Экспоненциальная запись**			let a \= 1.23e2; // 123

**2\. Как можно округлить число?**

| Метод | Описание | Пример |
| ----- | ----- | ----- |
| Math.floor(x) | округление вниз | Math.floor(4.9) → 4 |
| Math.ceil(x) | округление вверх | Math.ceil(4.1) → 5 |
| Math.round(x) | стандартное округление | Math.round(4.5) → 5 |
| Math.trunc(x) | удаление дробной части | Math.trunc(4.9) → 4 |
| Number.toFixed(n) | округление до n знаков и преобразование в строку | (4.567).toFixed(2) → "4.57" |

**3\. Результат 0.1 \+ 0.2**

0.1 \+ 0.2; // 0.30000000000000004

* Из-за **погрешности представления чисел с плавающей запятой**  
* Решения:

Math.round((0.1 \+ 0.2) \* 10\) / 10; // 0.3

**4\. Как получить случайное число?**

* Math.random() — число от 0 (включительно) до 1 (не включительно)

Math.random(); // 0 \<= x \< 1

* Случайное целое число от min до max:

function getRandomInt(min, max) {  
  return Math.floor(Math.random() \* (max \- min \+ 1)) \+ min;  
}

**5\. Как получить число из строки?**

| Способ | Пример |
| ----- | ----- |
| Number("42") | 42 |
| parseInt("42px") | 42 |
| parseFloat("3.14em") | 3.14 |
| \+str | \+"42" → 42 |
| Math.floor/ceil/round(+"3.5") | 3 |

**6\. Как найти минимальное / максимальное число между числами?**

* Math.min(...values) — минимальное

Math.min(5, 2, 8); // 2

* Math.max(...values) — максимальное

Math.max(5, 2, 8); // 8

* С массивом через spread:

const arr \= \[5,2,8\];  
Math.min(...arr); // 2

**Идеальная формулировка для собеседования**

В JavaScript числа можно записывать в десятичной, двоичной, восьмеричной, шестнадцатеричной и экспоненциальной формах. Для округления используют Math.floor, Math.ceil, Math.round, Math.trunc и toFixed. Сложение дробей, как 0.1 \+ 0.2, может давать погрешность. Случайные числа получают через Math.random. Преобразование строки в число выполняется через Number, parseInt, parseFloat или унарный \+. Минимальное и максимальное значение среди чисел определяется через Math.min и Math.max.

### 3\. В чём разница между различными кавычками и зачем это надо? Какие спец.символы есть? Как получить доступ к символу? Как изменить регистр строки или только первой буквы? Как найти последее и первое вхождение? Методы как вырезать подстроку? Как происходит сравнение строк? Правильное сравнение. Теговые шаблоны. (Строки) 

**1\. Различные кавычки и зачем они нужны**

В JS есть три типа кавычек для строк:

| Тип | Пример | Особенности |
| ----- | ----- | ----- |
| "double quotes" | "Hello" | Поддержка обычных строк, можно экранировать ' без проблем |
| 'single quotes' | 'Hello' | Аналогично двойным кавычкам, удобно для вложенных кавычек |
| \`backticks\` | \`Hello ${name}\` | Шаблонные строки: интерполяция ${}, многострочные строки, вложенные выражения |

**2\. Специальные символы (escape sequences)**

* \\n — новая строка  
* \\r — возврат каретки  
* \\t — табуляция  
* \\' — апостроф  
* \\" — двойная кавычка  
* \\\\ — обратный слеш  
* \\uXXXX — Unicode символ  
* \\xXX — шестнадцатеричный код символа

console.log("Line1\\nLine2");

**3\. Как получить доступ к символу строки**

* Через **индексацию**

const str \= "Hello";  
console.log(str\[0\]); // "H"

* Через метод charAt()

str.charAt(0); // "H"

**4\. Как изменить регистр строки**

* **Всё в верхний или нижний регистр**

str.toUpperCase(); // "HELLO"  
str.toLowerCase(); // "hello"

* **Только первая буква**

str\[0\].toUpperCase() \+ str.slice(1).toLowerCase();

**5\. Как найти первое и последнее вхождение**

* str.indexOf("o") — первое вхождение  
* str.lastIndexOf("l") — последнее вхождение  
* str.includes("el") — проверка наличия подстроки  
* str.startsWith("He"), str.endsWith("lo") — проверка начала/конца

**6\. Методы вырезания подстроки**

| Метод | Синтаксис | Особенности |
| ----- | ----- | ----- |
| slice(start, end) | str.slice(1,4) | Поддерживает отрицательные индексы |
| substring(start, end) | str.substring(1,4) | Отрицательные индексы интерпретируются как 0 |
| substr(start, length) | str.substr(1,3) | Длина вместо конечного индекса (устаревший метод) |

**7\. Как происходит сравнение строк**

* Строки сравниваются **лексикографически** (по Unicode)

"a" \< "b"; // true  
"apple" \< "banana"; // true

* Для правильного сравнения с учётом языка:

"a".localeCompare("b"); // \-1

**8\. Теговые шаблонные строки (Tagged templates)**

Позволяют **обрабатывать шаблонные строки через функцию**.  
function tag(strings, ...values) {  
  console.log(strings); // \["Hello ", "\!"\]  
  console.log(values);  // \["World"\]  
  return strings\[0\] \+ values\[0\] \+ strings\[1\];  
}

const result \= tag\`Hello ${"World"}\!\`; // "Hello World\!"

* Используются для:  
  * интернационализации  
  * безопасного HTML (escape)  
  * кастомной обработки строк

**Идеальная формулировка для собеседования**

В JS строки можно задавать с помощью одинарных, двойных кавычек и шаблонных литералов. Специальные символы позволяют добавлять переносы, табуляции и Unicode-символы. Доступ к символу осуществляется через индекс или charAt(). Изменение регистра — через toUpperCase/toLowerCase, для первой буквы — комбинируем с slice. Поиск подстрок — через indexOf, lastIndexOf, includes, startsWith, endsWith. Вырезать подстроку можно через slice, substring или substr. Строки сравниваются лексикографически, а localeCompare учитывает язык. Теговые шаблоны позволяют кастомно обрабатывать шаблонные строки перед интерполяцией.

### 4\. Как объявить массив? Как получить доступ к № элементу? Как добавить и удалить элемент с начала и с конца? Как перебрать все элементы c помощью цикла? (Массивы)

**1\. Как объявить массив**

// Литерал массива  
const arr1 \= \[1, 2, 3\];  
// Конструктор  
const arr2 \= new Array(1, 2, 3);  
// Пустой массив фиксированной длины  
const arr3 \= new Array(5); // \[empty × 5\]

**2\. Как получить доступ к элементу по индексу**

* Индексы начинаются с 0

const arr \= \[10, 20, 30\];  
console.log(arr\[0\]); // 10  
console.log(arr\[arr.length \- 1\]); // 30

**3\. Как добавить/удалить элемент**

С конца  
arr.push(40);    // добавить  
arr.pop();       // удалить и вернуть

С начала  
arr.unshift(5);  // добавить  
arr.shift();     // удалить и вернуть

**4\. Как перебрать элементы**

Цикл for  
for (let i \= 0; i \< arr.length; i++) {  
  console.log(arr\[i\]);  
}

Цикл for...of  
for (const value of arr) {  
  console.log(value);  
}

Метод forEach  
arr.forEach((value, index) \=\> {  
  console.log(index, value);  
});

**Идеальная формулировка для собеседования**

Массивы объявляются через литерал \[\] или конструктор new Array(). Доступ к элементам осуществляется по индексу, начиная с 0\. Добавление/удаление элементов производится с помощью push/pop (конец) и unshift/shift (начало). Перебор возможен через обычный цикл for, for...of или метод forEach.

### 5\. Как объединить два массива? Методы удаления элементов (по признаку, по индексу) и что они возвращают? Как перебрать массив (c возвращением нового массива или undefined)? (Методы массивов) 

**1\. Как объединить два массива**

Через concat  
const arr1 \= \[1,2\];  
const arr2 \= \[3,4\];  
const result \= arr1.concat(arr2); // \[1,2,3,4\]

Через spread  
const result \= \[...arr1, ...arr2\]; // \[1,2,3,4\]

**2\. Методы удаления элементов**

С конца  
arr.pop(); // удаляет последний элемент, возвращает его

С начала  
arr.shift(); // удаляет первый элемент, возвращает его

По индексу  
arr.splice(index, count); // удаляет count элементов, начиная с index, возвращает массив удалённых элементов

По признаку (условию)  
arr \= arr.filter(el \=\> el \!== value); // возвращает новый массив без элементов, удовлетворяющих условию

**3\. Перебор массива**

Перебор без возвращения нового массива

* forEach — возвращает undefined

arr.forEach(el \=\> console.log(el));

Перебор с возвращением нового массива

* map — возвращает массив одинаковой длины с результатами функции

const newArr \= arr.map(el \=\> el \* 2);

* filter — возвращает массив только с элементами, прошедшими проверку

const even \= arr.filter(el \=\> el % 2 \=== 0);

* reduce — возвращает любое значение, аккумулируя результат

const sum \= arr.reduce((acc, el) \=\> acc \+ el, 0);

**Идеальная формулировка для собеседования**

Два массива можно объединить через concat или spread (\[...\]). Удаление элементов выполняется методами pop/shift (возвращают удалённый элемент) и splice (возвращает массив удалённых элементов), по условию — через filter (возвращает новый массив). Перебор без возврата нового массива делают через forEach (возвращает undefined), а с созданием нового массива — через map, filter или reduce.

### 6\. Как найти элемент массива с начала и с конца и получить к нему доступ по индексу? Какие методы позволяют узнать что в массиве есть элемент и получить его (самого, индекс , или просто boolean о его наличии)? Как отсортировать массив? Как преобразовать массив к строке ? (Методы массивов(basicWeb)) 

**1\. Как найти элемент массива и получить индекс**

С начала

* indexOf(value) — возвращает индекс первого вхождения, или \-1, если не найдено

const arr \= \[1,2,3,2\];  
arr.indexOf(2); // 1

* findIndex(callback) — возвращает индекс первого элемента, удовлетворяющего условию

arr.findIndex(el \=\> el \> 2); // 2  
С конца

* lastIndexOf(value) — индекс последнего вхождения

arr.lastIndexOf(2); // 3

**2\. Методы для проверки наличия элемента и получения его**

| Метод | Что возвращает | Пример |
| ----- | ----- | ----- |
| includes(value) | true / false | \[1,2,3\].includes(2) → true |
| find(callback) | элемент или undefined | \[1,2,3\].find(el \=\> el \> 2\) → 3 |
| findIndex(callback) | индекс или \-1 | \[1,2,3\].findIndex(el \=\> el \> 2\) → 2 |

**3\. Как отсортировать массив**

Простая сортировка (строки по умолчанию)  
const arr \= \[3,1,2\];  
arr.sort(); // \[1,2,3\] (строковое сравнение)  
С числовым сравнением  
arr.sort((a,b) \=\> a \- b); // \[1,2,3\]  
arr.sort((a,b) \=\> b \- a); // \[3,2,1\]

**4\. Как преобразовать массив в строку**

* toString() — элементы через ,

\[1,2,3\].toString(); // "1,2,3"

* join(separator) — указать разделитель

\[1,2,3\].join("-"); // "1-2-3"

**Идеальная формулировка для собеседования**

Для поиска элементов массива с начала используют indexOf или findIndex, с конца — lastIndexOf. Проверку наличия выполняет includes (boolean), а для получения элемента — find (возвращает элемент) или findIndex (индекс). Сортировка выполняется через sort; для чисел необходимо передать callback (a,b)=\>a-b. Преобразовать массив в строку можно методами toString() (через запятую) или join(separator) для кастомного разделителя.

### 7\. Как получить единое значение на основе всего массива? Как проверить что все или один элемент подходят по условию? Как сделать вложенный массив плоским? (Методы массивов(MDN)) 

**1\. Получение единого значения из массива**

Метод reduce

* Применяет функцию ко всем элементам массива, аккумулируя результат в одно значение.

const arr \= \[1,2,3,4\];  
const sum \= arr.reduce((acc, el) \=\> acc \+ el, 0); // 10

* Можно использовать для любых операций: сумма, умножение, конкатенация, объект из массива и т.д.

const arr \= \["a","b","c"\];  
const str \= arr.reduce((acc, el) \=\> acc \+ el, ""); // "abc"

**2\. Проверка условий для всех или одного элемента**

every(callback)

* Возвращает true, если **все элементы** удовлетворяют условию

\[2,4,6\].every(n \=\> n % 2 \=== 0); // true

some(callback)

* Возвращает true, если **хотя бы один элемент** удовлетворяет условию

\[1,2,3\].some(n \=\> n % 2 \=== 0); // true

**3\. Превращение вложенного массива в плоский**

Метод flat(depth)

* Делает массив плоским на заданную глубину depth (по умолчанию 1\)

const nested \= \[1,\[2,3\],\[4,\[5,6\]\]\];  
nested.flat(); // \[1,2,3,4,\[5,6\]\]  
nested.flat(2); // \[1,2,3,4,5,6\]

* Для **полного выравнивания**:

nested.flat(Infinity);

**Идеальная формулировка для собеседования**

Для получения единого значения из массива используют reduce, который аккумулирует результат через функцию обратного вызова. Для проверки условий применяют every (все элементы соответствуют) и some (хотя бы один элемент соответствует). Вложенные массивы можно сделать плоскими с помощью метода flat(depth), где depth задаёт глубину рекурсии, или Infinity для полного выравнивания.

### 8\. Как работает for of? Как добавить итератор, что должен возвращать? Как создать массив из итератора или псевдомассива? (Итераторы)

**1\. Как работает for...of**

* Цикл for...of перебирает **итерируемые объекты** (arrays, strings, maps, sets и др.)  
* На каждой итерации возвращает **значение элемента** (не индекс)

const arr \= \[10, 20, 30\];  
for (const value of arr) {  
  console.log(value); // 10, 20, 30  
}

* Отличие от for...in: for...in перебирает **ключи/индексы**, for...of — **значения**

**2\. Как добавить итератор к объекту**

* Любой объект можно сделать итерируемым, добавив метод \[Symbol.iterator\]

const obj \= {  
  data: \[1,2,3\],  
  \[Symbol.iterator\]() {  
    let index \= 0;  
    const data \= this.data;  
    return {  
      next() {  
        if(index \< data.length){  
          return { value: data\[index++\], done: false };  
        } else {  
          return { value: undefined, done: true };  
        }  
      }  
    }  
  }  
};

for(const val of obj){  
  console.log(val); // 1,2,3  
}  
Что должен возвращать итератор

* Метод next() возвращает объект с двумя свойствами:  
  * value — текущее значение  
  * done — true, когда элементы закончились

**3\. Как создать массив из итератора или псевдомассива**

* Через Array.from():

const arr \= Array.from("hello"); // \["h","e","l","l","o"\]  
const set \= new Set(\[1,2,3\]);  
const arr2 \= Array.from(set); // \[1,2,3\]

* Через spread-оператор:

const arr3 \= \[...set\]; // \[1,2,3\]

* Псевдомассивы (например arguments) также можно превратить:

function f(){  
  const args \= Array.from(arguments);  
  console.log(args);  
}  
f(1,2,3); // \[1,2,3\]

**Идеальная формулировка для собеседования**

for...of используется для перебора итерируемых объектов, возвращая их значения на каждой итерации. Чтобы объект стал итерируемым, нужно реализовать метод \[Symbol.iterator\], который возвращает итератор с методом next(), отдающим объект {value, done}. Из итераторов или псевдомассивов можно создать массив через Array.from() или spread-оператор \[...iterable\].

### 9\. Какие ключи могут быть? Как быстро сделать уникальную выборку? (Map и Set) 

**1\. Map: ключи и значения**

* **Map** — коллекция ключ-значение, где:  
  * Ключи могут быть **любого типа**: примитивы, объекты, функции и т.д.  
  * Значения могут быть любыми

const map \= new Map();  
map.set("key", 123);  
map.set(42, "value");  
map.set({}, "obj");  
map.set(()=\>{}, "func");  
console.log(map.get(42)); // "value"

* Отличие от обычного объекта:  
  * Объект хранит только строки или символы как ключи  
  * Map сохраняет порядок добавления  
  * Map имеет методы size, set, get, has, delete, clear

**2\. Set: уникальные значения**

* **Set** — коллекция уникальных значений любого типа  
* Быстро обеспечивает **уникальность элементов**

const set \= new Set(\[1,2,2,3,3,3\]);  
console.log(set); // Set {1,2,3}

* Методы:  
  * add(value) — добавить  
  * has(value) — проверить наличие  
  * delete(value) — удалить  
  * clear() — очистить  
  * size — количество элементов

**3\. Как быстро сделать уникальную выборку из массива**

* Через Set:

const arr \= \[1,2,2,3,3,3\];  
const unique \= \[...new Set(arr)\]; // \[1,2,3\]

* Работает для примитивов (числа, строки, символы) и обеспечивает **очень быструю проверку уникальности**

**Идеальная формулировка для собеседования**

В Map ключи могут быть любого типа — примитивы, объекты, функции. Значения тоже любые. Map сохраняет порядок и имеет удобные методы get, set, has, delete. Для быстрого получения уникальных элементов используют Set, который хранит только уникальные значения. Чтобы сделать массив уникальным, создают new Set(array) и, при необходимости, превращают обратно в массив через spread: \[...new Set(array)\].

### 10\. Как достать все свойства объекта? Как достать все значения объекта? Как достать все свойства со значениями? Все ли свойства будут возвращены таким образом? Метода создания обьекта из массива свойств и значений ? Object в Map , Map в Object (keys, values, entries)

**1\. Как достать все свойства объекта (ключи)**

* **Object.keys(obj)** — возвращает массив **собственных перечисляемых свойств (ключей)**

const obj \= {a:1, b:2};  
console.log(Object.keys(obj)); // \["a","b"\]

* Не возвращает:  
  * свойства в цепочке прототипов  
  * неперечисляемые свойства

**2\. Как достать все значения объекта**

* **Object.values(obj)** — возвращает массив значений **только собственных перечисляемых свойств**

console.log(Object.values(obj)); // \[1,2\]

**3\. Как достать все свойства со значениями**

* **Object.entries(obj)** — возвращает массив пар \[ключ, значение\]

console.log(Object.entries(obj)); // \[\["a",1\],\["b",2\]\]

**4\. Все ли свойства будут возвращены?**

* Нет, возвращаются **только собственные перечисляемые свойства объекта**  
* Свойства из прототипа и неперечисляемые свойства **не попадут**

Object.defineProperty(obj, "hidden", {value: 42, enumerable: false});  
Object.keys(obj); // \["a","b"\]

**5\. Методы создания объекта из массива свойств и значений**

* **Object.fromEntries()** — превращает массив пар \[ключ, значение\] обратно в объект

const entries \= \[\["a",1\],\["b",2\]\];  
const obj2 \= Object.fromEntries(entries);  
console.log(obj2); // {a:1, b:2}

**6\. Преобразование между Object и Map**

Object → Map  
const obj \= {a:1, b:2};  
const map \= new Map(Object.entries(obj));

Map → Object  
const map \= new Map(\[\["a",1\],\["b",2\]\]);  
const obj \= Object.fromEntries(map);

* Полезно для случаев, когда нужна структура ключ-значение с ключами любого типа (Map), но иногда нужно работать с обычными объектами.

**Идеальная формулировка для собеседования**

Все собственные перечисляемые свойства объекта можно получить через Object.keys (ключи), Object.values (значения) и Object.entries (пары ключ-значение). Свойства прототипа и неперечисляемые свойства не возвращаются. Создать объект из массива пар \[ключ,значение\] позволяет Object.fromEntries(). Для преобразования между объектом и Map используют Object.entries(obj) → new Map() и Object.fromEntries(map) → объект.

### 11\. Как с помощью деструктуризации работать с обьектами\\массивами ? Операции rest и spread. (Деструктуризация)

**1\. Деструктуризация объектов**

Позволяет извлекать свойства объекта в отдельные переменные.  
const user \= {name: "Alice", age: 25, city: "Paris"};

// Простая деструктуризация  
const {name, age} \= user;  
console.log(name, age); // Alice 25

// Можно задать новые имена переменным  
const {name: userName, city: userCity} \= user;  
console.log(userName, userCity); // Alice Paris

// Значения по умолчанию  
const {country \= "France"} \= user;  
console.log(country); // France

// Остаточные свойства (rest)  
const {name, ...rest} \= user;  
console.log(rest); // {age:25, city:"Paris"}

**2\. Деструктуризация массивов**

Извлечение элементов массива в переменные по позиции.  
const arr \= \[1,2,3,4\];

// Простая деструктуризация  
const \[a, b\] \= arr;  
console.log(a,b); // 1 2

// Пропуск элементов  
const \[first,,third\] \= arr;  
console.log(first, third); // 1 3

// Остаточные элементы (rest)  
const \[x, ...others\] \= arr;  
console.log(others); // \[2,3,4\]

**3\. Операции Spread (...)**

* **Для массивов**

const arr1 \= \[1,2\];  
const arr2 \= \[3,4\];  
const merged \= \[...arr1, ...arr2\]; // \[1,2,3,4\]

* **Для объектов**

const obj1 \= {a:1};  
const obj2 \= {b:2};  
const mergedObj \= {...obj1, ...obj2}; // {a:1,b:2}

* Используется для **копирования** и объединения без изменения оригинала.

**4\. Операции Rest (...)**

* Используется **при деструктуризации** для сбора остатка элементов в новый массив или объект

const \[first, ...restArr\] \= \[1,2,3,4\];  
console.log(restArr); // \[2,3,4\]

const {a, ...restObj} \= {a:1, b:2, c:3};  
console.log(restObj); // {b:2, c:3}

**Идеальная формулировка для собеседования**

Деструктуризация позволяет извлекать значения из объектов или массивов в отдельные переменные. Для объектов используется синтаксис {prop1, prop2}, для массивов — \[el1, el2\]. Операция rest (...rest) собирает оставшиеся элементы/свойства в новый массив или объект. Операция spread (...) используется для копирования и объединения массивов или объектов, позволяя работать с ними иммутабельно.

### 12\. Как получить текущую дату? Как получить завтрашнюю дату? Как узнать какой сейчас день, месяц, год? Как считать дату из форматированной строки? Как получить смещение часового пояса ? (Дата и время) 

**1\. Как получить текущую дату**

* Через конструктор Date без аргументов

const now \= new Date();  
console.log(now); // текущая дата и время

* Текущая метка времени в миллисекундах с 1970-01-01

Date.now(); // 1693228800000

**2\. Как получить завтрашнюю дату**

const tomorrow \= new Date();  
tomorrow.setDate(tomorrow.getDate() \+ 1);  
console.log(tomorrow);

* setDate() автоматически учитывает переход на следующий месяц или год.

**3\. Как узнать день, месяц, год**

const date \= new Date();

date.getDate();    // день месяца (1-31)  
date.getMonth();   // месяц (0-11, январь \= 0\)  
date.getFullYear(); // год (4 цифры)  
date.getDay();     // день недели (0-6, воскресенье \= 0\)

**4\. Как считать дату из форматированной строки**

const d1 \= new Date("2025-12-28"); // ISO 8601  
const d2 \= new Date("12/28/2025"); // локальный формат

* Рекомендуется использовать **ISO формат YYYY-MM-DD**, чтобы избежать различий между браузерами.

**5\. Как получить смещение часового пояса**

* getTimezoneOffset() возвращает разницу между UTC и локальным временем в **минутах**

const tzOffset \= new Date().getTimezoneOffset();  
console.log(tzOffset); // например 180 (МСК \+3:00)

* Положительное значение — западнее UTC, отрицательное — восточнее.

**Идеальная формулировка для собеседования**

Текущую дату и время получают через new Date(), а метку времени — через Date.now(). Чтобы получить завтрашнюю дату, используют setDate(getDate()+1). День, месяц, год и день недели определяются методами getDate(), getMonth(), getFullYear() и getDay(). Дату из строки лучше создавать через ISO формат YYYY-MM-DD. Смещение часового пояса относительно UTC получают через getTimezoneOffset().

### 13\. Как работать с JSON ? В каком случае stringify не работает? Какие типы данных не попадают в JSON? Как переопределить вывод JSON.stringify ? (JSON)

**1\. Как работать с JSON**

* **JSON (JavaScript Object Notation)** — текстовый формат для обмена данными между системами.

Парсинг JSON в объект  
const jsonString \= '{"name":"Alice","age":25}';  
const obj \= JSON.parse(jsonString);  
console.log(obj.name); // "Alice"

Преобразование объекта в JSON  
const obj \= {name:"Alice", age:25};  
const jsonString \= JSON.stringify(obj);  
console.log(jsonString); // '{"name":"Alice","age":25}'

**2\. В каких случаях JSON.stringify не работает**

* Свойства, значения которых **undefined**, **функции**, или **символы**, **игнорируются**.

JSON.stringify({a: undefined, b: () \=\> {}, c: Symbol()}); // "{}"

* **Циклические ссылки** в объекте вызовут **ошибку**

const obj \= {};  
obj.self \= obj;  
JSON.stringify(obj); // TypeError: Converting circular structure to JSON

**3\. Типы данных, не попадающие в JSON**

* undefined  
* function  
* Symbol  
* Символические свойства (Symbol('id'))  
* Циклические структуры без replacer

**4\. Как переопределить вывод JSON.stringify**

С помощью метода toJSON у объекта  
const obj \= {  
  name: "Alice",  
  age: 25,  
  toJSON() {  
    return {name: this.name}; // вернется только имя  
  }  
};  
console.log(JSON.stringify(obj)); // '{"name":"Alice"}'

С помощью replacer-функции  
const obj \= {name:"Alice", age:25};  
const json \= JSON.stringify(obj, (key, value) \=\> key \=== "age" ? undefined : value);  
console.log(json); // '{"name":"Alice"}'

**Идеальная формулировка для собеседования**

JSON — это текстовый формат обмена данными. Для преобразования строки в объект используют JSON.parse(), а для объекта в строку — JSON.stringify(). stringify не учитывает свойства с undefined, функциями или символами, и выдаёт ошибку при циклических ссылках. Переопределить вывод можно через метод toJSON() объекта или через функцию replacer в JSON.stringify.

# Продвинутая работа с функциями

1. Максимальная глубина рекурсии. Что такое контекст выполнения функции ? Что такое стек контекстов выполнения ? (Рекурсия и стек)  
2. Сколько аргумемнтов может быть у функции? Как получить все аргументы не зная их названий? Что такое arguments и как работает в стрелочных функциях? Как можно объединить два массива? (Остаточные параметры и оператор расширения)  
3. Что такое замыкание? Что такое IIFE? Что такое лексическое окружение? Что будет если функция не найдет переменную в теле? Что происходит внутри циклов? (Замыкание)  
4. Что лежит внутри? Назовите несколько полезных свойств\\методов лежащих в глобальном обьекте (Глобальный объект)  
5. Какие свойства есть у объекта функции? Что такое именнованная функция исполнения NFE ? Для чего нужна? Можно ли задать свои свойства в обьект функции ? (Объект функции)  
6. Для чего нужна такая конструкция? В чём отличие? (New Function)  
7. Как сделать чтобы функция выполнилась только один раз через № времени? Как сделать чтобы выполнялась каждые № времени? Всегда ли функция сработает через № времени? Что происходит когда задаем timeout 0? (SetTimeout, setInterval)  
8. Что такое call и apply? Какую задачу решают? В чём отличие? Что такое декоратор? (Декораторы и переадресация вызова, call/apply)  
9. Что такое контекст? Как и зачем привязывать контекст? Как привязать контекст ко всем функциям объекта? (Привязка контекста к функции)

### 1\. Максимальная глубина рекурсии. Что такое контекст выполнения функции ? Что такое стек контекстов выполнения ? (Рекурсия и стек)

**1\. Максимальная глубина рекурсии**

* Это **ограничение на количество вложенных вызовов функции** в JavaScript, которое определяется движком (например, V8, SpiderMonkey).  
* Превышение этой глубины вызывает ошибку **RangeError: Maximum call stack size exceeded**.

function f() {  
  return f();  
}  
f(); // RangeError

* Обычно в современных движках глубина рекурсии порядка **\~10 000 — 100 000 вызовов**, зависит от памяти и оптимизации.

**2\. Контекст выполнения функции**

* Контекст выполнения (**Execution Context**) — это **объект, который содержит информацию о том, как выполняется текущая функция**.

Содержит:

1. **Переменные** и константы, объявленные внутри функции  
2. **Аргументы функции**  
3. **Ссылку на внешнее окружение (scope chain)**  
4. **Значение this**  
* Каждый раз, когда вызывается функция, создается новый контекст выполнения.

**3\. Стек контекстов выполнения**

* **Call stack** — стек, где хранятся контексты выполнения всех активных функций.  
* Механизм работы:  
  1. При вызове функции контекст добавляется в **стек** (push)  
  2. Функция выполняется  
  3. После завершения контекст удаляется из стека (pop)

globalContext  
 └─ functionA()  
     └─ functionB()

* Если стек переполнен (слишком много вложенных вызовов, рекурсия), возникает **RangeError**.

**Идеальная формулировка для собеседования**

Максимальная глубина рекурсии — это ограничение количества вложенных вызовов функций в JavaScript, превышение которого приводит к ошибке RangeError. Контекст выполнения функции (Execution Context) содержит локальные переменные, аргументы, ссылку на внешнее окружение и значение this. Все контексты выполнения хранятся в стеке вызовов (Call Stack): при вызове функции контекст помещается в стек, а после завершения — удаляется.

### 2\. Сколько аргумемнтов может быть у функции? Как получить все аргументы не зная их названий? Что такое arguments и как работает в стрелочных функциях? Как можно объединить два массива? (Остаточные параметры и оператор расширения)

**1\. Сколько аргументов может быть у функции**

* **Технически** — нет жёсткого ограничения, кроме ограничений памяти и движка.  
* В большинстве движков можно передавать сотни и тысячи аргументов, но обычно используют **небольшое количество для удобства**.

**2\. Как получить все аргументы, не зная их названий**

Через объект arguments

* Доступно в **обычных функциях**, но **не работает в стрелочных**.

function f() {  
  console.log(arguments);  
}  
f(1,2,3); // \[1,2,3\] (псевдомассив)

* arguments — это **псевдомассив**, можно использовать индексы и length, но нельзя напрямую применять методы массива (map, filter) без приведения к массиву.

Через остаточные параметры (rest)

* Работает в **обычных функциях и стрелочных**.

function f(...args) {  
  console.log(args); // \[1,2,3\]  
}  
f(1,2,3);

* ...args собирает все оставшиеся аргументы в **настоящий массив**, можно использовать любые методы массивов.

**3\. Как работает arguments в стрелочных функциях**

* Стрелочные функции **не имеют собственного arguments**.  
* Они берут arguments из **внешнего (лексического) контекста**.

function outer() {  
  const arrow \= () \=\> console.log(arguments);  
  arrow();  
}  
outer(1,2); // \[1,2\]

**4\. Как объединить два массива**

Через spread  
const arr1 \= \[1,2\];  
const arr2 \= \[3,4\];  
const merged \= \[...arr1, ...arr2\]; // \[1,2,3,4\]

Через concat

const merged \= arr1.concat(arr2); // \[1,2,3,4\]

**Идеальная формулировка для собеседования**

Функция может принимать произвольное количество аргументов, ограниченное только ресурсами движка. Чтобы получить все аргументы без знания их имён, используют arguments (в обычных функциях) или остаточные параметры ...args (работают и в стрелочных функциях, возвращая настоящий массив). Стрелочные функции не имеют собственного arguments, используют внешнее окружение. Для объединения массивов применяют оператор расширения (\[...arr1, ...arr2\]) или метод concat().

### 3\. Что такое замыкание? Что такое IIFE? Что такое лексическое окружение? Что будет если функция не найдет переменную в теле? Что происходит внутри циклов? (Замыкание)

**1\. Что такое замыкание (Closure)**

* Замыкание — это **функция вместе с окружением**, в котором она была создана.  
* Оно позволяет функции **доступ к переменным внешней функции**, даже после того как внешняя функция завершила выполнение.

function outer() {  
  const secret \= 42;  
  return function inner() {  
    console.log(secret);  
  };  
}

const fn \= outer();  
fn(); // 42

* Применение:  
  * Инкапсуляция данных  
  * Создание приватных переменных  
  * Фабрики функций

**2\. Что такое IIFE (Immediately Invoked Function Expression)**

* **Функция, которая вызывается сразу после объявления**

(function() {  
  console.log("IIFE выполнено");  
})();

* Часто используется для:  
  * Создания **локального скоупа** и предотвращения загрязнения глобального пространства  
  * Инициализации кода

**3\. Что такое лексическое окружение (Lexical Environment)**

* Лексическое окружение — это **структура, которая хранит привязку идентификаторов к значениям в момент объявления функции или блока**.  
* Включает:  
  * Локальные переменные  
  * Ссылку на внешнее окружение (parent scope)  
* Именно благодаря лексическому окружению замыкания **“помнят” внешние переменные**.

function a() {  
  let x \= 10;  
  return function b() {  
    console.log(x); // доступ к переменной x из лексического окружения функции a  
  };  
}

**4\. Что будет, если функция не найдет переменную в теле**

* JS ищет переменную **по цепочке областей видимости (scope chain)**:  
  1. Локальная область функции  
  2. Внешние области, по цепочке  
  3. Глобальная область  
* Если переменная не найдена, **будет ошибка ReferenceError**.

**5\. Что происходит внутри циклов и замыканий**

* Если внутри цикла создаются функции с использованием var, они **будут ссылаться на одну переменную**:

for(var i=0; i\<3; i++){  
  setTimeout(()=\>console.log(i), 0);  
}  
// 3,3,3

* Использование let создает **новую переменную для каждой итерации**, замыкание сохраняет правильное значение:

for(let i=0; i\<3; i++){  
  setTimeout(()=\>console.log(i), 0);  
}  
// 0,1,2

**Идеальная формулировка для собеседования**

Замыкание — это функция вместе с лексическим окружением, которое позволяет ей хранить доступ к внешним переменным даже после завершения внешней функции. IIFE — это немедленно вызываемая функция, используемая для создания локального скоупа. Лексическое окружение хранит идентификаторы и ссылки на внешние области видимости. Если функция не найдет переменную в теле и во внешних областях, будет ReferenceError. В циклах замыкания ведут себя по-разному для var (одна переменная на все итерации) и let (новая переменная для каждой итерации).

### 4\. Что лежит внутри? Назовите несколько полезных свойств\\методов лежащих в глобальном обьекте (Глобальный объект)

**1\. Что такое глобальный объект**

* В JavaScript глобальный объект — это **объект, который существует в любой среде выполнения и содержит глобальные переменные, функции и объекты**.  
* В браузере это window, в Node.js — global. В современных стандартах можно использовать globalThis, которое универсально для всех сред.

console.log(globalThis); // глобальный объект

* Все глобальные переменные, объявленные через var или function, становятся свойствами глобального объекта.

var x \= 10;  
console.log(window.x); // 10 (в браузере)

**2\. Что лежит внутри глобального объекта**

* **Глобальные функции**: setTimeout, setInterval, clearTimeout, parseInt, parseFloat, isNaN  
* **Глобальные объекты**: Math, Date, JSON, Array, Object, Promise  
* **Свойства среды**: navigator, location, document (в браузере)  
* **Конструкторы и классы**: RegExp, Error, Map, Set

**3\. Полезные методы и свойства глобального объекта**

* globalThis.setTimeout(fn, delay) — вызов функции с задержкой  
* globalThis.clearTimeout(id) — отмена таймера  
* globalThis.parseInt(str, radix) — преобразование строки в целое число  
* globalThis.isNaN(value) — проверка на NaN  
* globalThis.console — вывод в консоль (console.log, console.error)  
* В Node.js:  
  * global.process — информация о процессе  
  * global.Buffer — работа с бинарными данными

**Идеальная формулировка для собеседования**

Глобальный объект — это объект, который существует в любой среде и содержит глобальные переменные, функции и встроенные объекты. В браузере это window, в Node.js — global, универсально — globalThis. Внутри него лежат глобальные функции (setTimeout, parseInt), встроенные объекты (Math, Date, JSON), конструкторы (Map, Set) и свойства среды (navigator, document). Полезные методы: setTimeout, clearTimeout, parseInt, isNaN, console.log.

### 5\. Какие свойства есть у объекта функции? Что такое именнованная функция исполнения NFE ? Для чего нужна? Можно ли задать свои свойства в обьект функции ? (Объект функции)

**1\. Свойства объекта функции**

* В JavaScript функции — это **объекты**, поэтому у них есть свойства и методы.  
* Основные стандартные свойства:

| Свойство | Описание |
| ----- | ----- |
| name | Имя функции |
| length | Количество ожидаемых аргументов (параметров) |
| prototype | Объект прототипа для создания экземпляров (только для обычных функций) |
| caller | Ссылка на функцию, которая вызвала текущую (не рекомендуется) |
| arguments | Доступ к аргументам вызывающей функции (устарело) |

* Функции также наследуют методы объекта Function (call, apply, bind).

**2\. Что такое именованная функция исполнения (NFE — Named Function Expression)**

* **NFE** — это функция, объявленная как выражение с именем:

const factorial \= function fact(n) {  
  if(n\<=1) return 1;  
  return n \* fact(n-1); // можно использовать имя внутри самой функции  
};  
console.log(factorial(5)); // 120

* Особенности:  
  * Имя доступно **только внутри функции** (fact)  
  * Внешне функция доступна через переменную (factorial)  
  * Удобно для рекурсии и отладки (имя отображается в стеке вызовов)

**3\. Для чего нужна NFE**

* **Рекурсия внутри функции**, когда переменная может быть переопределена снаружи  
* **Отладка** — имя функции видно в стек-трейсе  
* **Изоляция имени** — не засоряет внешнее пространство

**4\. Можно ли задать свои свойства в объект функции**

* Да, функция — объект, и ей можно добавлять свои свойства:

function sayHi() {}  
sayHi.description \= "Функция для приветствия";  
console.log(sayHi.description); // "Функция для приветствия"

* Применение:  
  * Кэширование результатов  
  * Хранение настроек  
  * Метаданные функции

**Идеальная формулировка для собеседования**

Функция в JavaScript — это объект с собственными свойствами name, length, prototype, а также методами call, apply, bind. Named Function Expression (NFE) — именованное функциональное выражение, имя доступно внутри функции и удобно для рекурсии и отладки. Внешне функция доступна через переменную, а внутри можно использовать имя для вызова самой себя. Функциям можно задавать собственные свойства для хранения метаданных, кэша или конфигураций.

### 6\. Для чего нужна такая конструкция? В чём отличие? (New Function)

**1\. Что такое new Function**

* Конструктор Function позволяет **создавать функции динамически из строки**:

const sum \= new Function('a', 'b', 'return a \+ b');  
console.log(sum(2,3)); // 5

* Синтаксис:

new Function (\[arg1\[, arg2\[, ...argN\]\],\] functionBody)

* Последний аргумент — тело функции в виде строки, предыдущие — имена аргументов.

**2\. Для чего нужна**

* Динамическое создание функций на основе данных, например:  
  * Генерация кода во время выполнения  
  * Сценарии с конфигурируемыми функциями  
* Аналог eval, но создаёт **новый контекст выполнения**, без доступа к локальным переменным текущей области.

let x \= 10;  
const f \= new Function('return typeof x');   
console.log(f()); // "undefined" — не видит локальные переменные

**3\. Отличие от обычной функции**

| Особенность | Function Declaration / Expression | new Function |
| :---- | :---- | :---- |
| Контекст | Лексическое окружение создается при объявлении | Всегда глобальный контекст, локальные переменные вызывающей функции недоступны |
| Синтаксис | function foo(a,b){} | new Function('a','b','return a+b') |
| Использование | Статически | Динамически (строка кода) |
| Оптимизация | Движки оптимизируют обычные функции | Менее оптимизировано, slower |

* new Function работает аналогично eval, **опасен для безопасности**, если использовать строки из внешних источников.

**Идеальная формулировка для собеседования**

Конструктор new Function создаёт функцию из строки с аргументами и телом функции. Отличие от обычной функции в том, что создаётся **новый глобальный контекст**, локальные переменные вызывающей области недоступны. Применяется для динамического создания функций, но менее безопасен и менее оптимизирован, чем обычные Function Declaration или Expression.

### 7\. Как сделать чтобы функция выполнилась только один раз через № времени? Как сделать чтобы выполнялась каждые № времени? Всегда ли функция сработает через № времени? Что происходит когда задаем timeout 0? (SetTimeout, setInterval)

**1\. Выполнить функцию только один раз через заданное время**

* Используется **setTimeout**:

function sayHi() {  
  console.log("Привет\!");  
}

// Выполнить через 2 секунды  
setTimeout(sayHi, 2000);

* Аргументы:  
  * callback — функция  
  * delay — задержка в миллисекундах

**2\. Выполнять функцию каждые N миллисекунд**

* Используется **setInterval**:

setInterval(() \=\> console.log("Привет\!"), 1000); // каждые 1 секунду

* Для остановки интервала:

const id \= setInterval(() \=\> console.log("Привет\!"), 1000);  
clearInterval(id);

**3\. Всегда ли функция сработает через N времени?**

* **Нет**, setTimeout и setInterval гарантируют **минимальную задержку**, но:  
  * JavaScript работает в **однопоточном Event Loop**  
  * Если стек вызовов занят, выполнение задерживается  
  * Задержка может быть **дольше**, но не короче указанной

setTimeout(() \=\> console.log("Hi"), 0);  
console.log("Done"); // "Done" выведется первым

**4\. Что происходит при setTimeout(fn, 0\)**

* Функция помещается в **очередь задач (task queue)**, выполнится **после текущего стека вызовов**  
* Используется для **отложенного выполнения**, но не мгновенно

console.log("Start");  
setTimeout(() \=\> console.log("Timeout 0"), 0);  
console.log("End");  
// Вывод: Start \-\> End \-\> Timeout 0

**Идеальная формулировка для собеседования**

Чтобы функция выполнилась один раз через N миллисекунд, используют setTimeout(callback, delay). Чтобы выполнялась каждые N миллисекунд — setInterval(callback, interval) с возможностью остановки через clearInterval(id). Функции через таймер **не гарантируют точное время выполнения**, задержка может быть больше указанной из\-за занятости стека и Event Loop. setTimeout(fn, 0\) помещает функцию в очередь задач и выполняет её после завершения текущего кода.

### 8\. Что такое call и apply? Какую задачу решают? В чём отличие? Что такое декоратор? (Декораторы и переадресация вызова, call/apply)

**1\. Что такое call и apply**

* **call** и **apply** — методы функции, позволяющие **вызывать функцию с явным указанием контекста (this)** и аргументов.

function greet(greeting, punctuation) {  
  console.log(\`${greeting}, ${this.name}${punctuation}\`);  
}  
const user \= {name: "Alice"};  
greet.call(user, "Hello", "\!");  // Hello, Alice\!  
greet.apply(user, \["Hi", "\!\!"\]); // Hi, Alice\!\!

**2\. Задача, которую решают**

* Позволяют **задавать контекст (this) вручную**, что важно:  
  * при работе с методами объектов  
  * при переиспользовании функций  
  * для декораторов и функционального программирования

**3\. Отличие call от apply**

| Метод | Аргументы |
| ----- | ----- |
| call | Передаём контекст и **список аргументов через запятую** |
| apply | Передаём контекст и **массив аргументов** |

* Пример:

greet.call(user, "Hello", "\!");   // каждый аргумент отдельно  
greet.apply(user, \["Hello", "\!"\]); // массив аргументов

**4\. Что такое декоратор**

* **Декоратор** — функция, которая **оборачивает другую функцию**, добавляя поведение до или после её выполнения.

function logDecorator(fn) {  
  return function(...args) {  
    console.log("Вызов функции с аргументами:", args);  
    return fn.apply(this, args);  
  }  
}

function sum(a,b){ return a+b; }  
const decoratedSum \= logDecorator(sum);  
console.log(decoratedSum(2,3));   
// Вызов функции с аргументами: \[2,3\]  
// 5

* Часто используется для:  
  * Логирования  
  * Кэширования  
  * Валидации аргументов  
  * Измерения времени выполнения

**Идеальная формулировка для собеседования**

Методы call и apply позволяют вызвать функцию с явным контекстом this. Разница в том, что call принимает аргументы по одному через запятую, а apply — массив аргументов. Эти методы часто используются при переадресации вызова, повторном использовании функций и в декораторах. Декоратор — это функция, которая оборачивает другую функцию для расширения её поведения, например, логирование, кэширование или проверка аргументов.

### 9\. Что такое контекст? Как и зачем привязывать контекст? Как привязать контекст ко всем функциям объекта? (Привязка контекста к функции)

**1\. Что такое контекст (this)**

* Контекст — это **значение this внутри функции**, которое определяет, к каким данным функция имеет доступ.  
* В JavaScript this зависит **от способа вызова функции**, а не от её места объявления.

const obj \= {name: "Alice"};  
function greet() {  
  console.log(this.name);  
}  
greet();          // undefined или ошибка в strict mode  
obj.greet \= greet;  
obj.greet();       // "Alice" — this ссылается на obj

**2\. Зачем привязывать контекст**

* Чтобы функция **всегда использовала нужный объект как this**, независимо от того, где она вызвана.  
* Полезно:  
  * при передаче метода как callback  
  * при асинхронном коде  
  * для обработки событий

**3\. Как привязать контекст к функции**

a) Через bind

* Создаёт **новую функцию с фиксированным this**:

const obj \= {name: "Alice"};  
function greet() { console.log(this.name); }  
const boundGreet \= greet.bind(obj);  
boundGreet(); // "Alice"  
b) Через call или apply

* Немедленно вызывают функцию с нужным контекстом:

greet.call(obj);  // "Alice"  
greet.apply(obj); // "Alice"

**4\. Как привязать контекст ко всем функциям объекта**

* Используем bind при инициализации методов:

const obj \= {  
  name: "Alice",  
  greet() { console.log(this.name); },  
  bye() { console.log("Bye " \+ this.name); }  
};

// привязка всех методов к obj  
for (const key of Object.keys(obj)) {  
  if (typeof obj\[key\] \=== "function") {  
    obj\[key\] \= obj\[key\].bind(obj);  
  }  
}

* Теперь методы **сохраняют правильный this**, даже если их передать как колбэк.

**Идеальная формулировка для собеседования**

Контекст (this) — это объект, на который ссылается функция во время выполнения. Привязывают контекст, чтобы функция всегда работала с правильным объектом, независимо от места вызова. Контекст можно привязать через bind (создаёт новую функцию), через call/apply (немедленно вызывает с контекстом). Чтобы привязать this ко всем методам объекта, можно пройтись по его методам и использовать bind.

# Работа с DOM API

1. Как происходит навигация по элементам DOM : 1\. к родителю 2\. к сестринским элементам 3\. к первому\\последнему дочернему 4\. получение списка дочерних (Навигация по DOM-элементам)  
2. Как происходит поиск элементов : 1\. по названию тэга 2\. по аттрибуту name 3\. по имени класса 4\. по id 5\. по селектору CSS ? Что возвращают эти методы? (Поиск: getElement\*, querySelector\*)  
3. Какие свойства есть у элемента DOM ? (Свойства узлов: тип, тег и содержимое)   
4. Какие способы вставки элемента есть : 1.перед элементов 2\. после элемента 3\. внутри дочерних вначале 4.внутри дочерних в конце ? Как удалить элемент из DOM дерева? (Изменение документа)

### 1\. Как происходит навигация по элементам DOM : 1\. к родителю 2\. к сестринским элементам 3\. к первому\\последнему дочернему 4\. получение списка дочерних (Навигация по DOM-элементам)

Общий принцип

DOM — это **дерево узлов**. Навигация по DOM — это перемещение между узлами: родитель → дети → соседи.

Важно различать:

* **Element-узлы** (только HTML-элементы)  
* **Node-узлы** (элементы \+ текст \+ комментарии)

1\. Навигация к родителю

К родительскому элементу  
element.parentElement

* Возвращает **родительский HTML-элемент**  
* Если родителя нет — null

К родительскому узлу (любой тип)  
element.parentNode  
Используют редко, так как может вернуть Document.  
2\. Навигация к сестринским элементам

Следующий элемент  
element.nextElementSibling  
Предыдущий элемент  
element.previousElementSibling

* Игнорируют текстовые узлы  
* Если элемента нет — null

⚠️ nextSibling / previousSibling — возвращают **любой узел**, включая текст  
3\. Первый и последний дочерний элемент

Первый дочерний элемент  
element.firstElementChild  
Последний дочерний элемент  
element.lastElementChild  
⚠️ firstChild / lastChild — могут вернуть текст  
4\. Получение списка дочерних элементов

Только элементы  
element.children

* HTMLCollection (живой)  
* Только HTML-элементы

Все узлы (включая текст)  
element.childNodes

* NodeList  
* Включает \#text, комментарии

Краткая таблица (идеально для собеседования)

| Задача | Свойство |
| ----- | ----- |
| Родитель | parentElement |
| Следующий сосед | nextElementSibling |
| Предыдущий сосед | previousElementSibling |
| Первый ребёнок | firstElementChild |
| Последний ребёнок | lastElementChild |
| Все дети (элементы) | children |
| Все узлы | childNodes |

**Идеальная формулировка для собеседования**

Навигация по DOM происходит через свойства элементов. Для перехода к родителю используют parentElement, к соседним элементам — nextElementSibling и previousElementSibling. Первый и последний дочерний элемент получаем через firstElementChild и lastElementChild. Список всех дочерних элементов — children. 

### 2\. Как происходит поиск элементов : 1\. по названию тэга 2\. по аттрибуту name 3\. по имени класса 4\. по id 5\. по селектору CSS ? Что возвращают эти методы? (Поиск: getElement\*, querySelector\*)

Общий принцип поиска в DOM

Поиск элементов выполняется **от документа или от конкретного элемента**.  
Методы делятся на две группы:

1. **Старые методы getElement\***  
2. **Современные методы querySelector\* (CSS-селекторы)**

1\. Поиск по названию тега

document.getElementsByTagName('div');

* Возвращает **HTMLCollection**  
* Коллекция **живая** (обновляется при изменении DOM)  
* Можно вызывать от document и от любого элемента

parent.getElementsByTagName('p');

2\. Поиск по атрибуту name

document.getElementsByName('username');

* Возвращает **NodeList**  
* Используется в основном для форм  
* Можно вызывать **только от document**

3\. Поиск по имени класса

document.getElementsByClassName('item');

* Возвращает **HTMLCollection**  
* Коллекция **живая**  
* Можно вызывать от document и от элемента

4\. Поиск по id

document.getElementById('header');

* Возвращает **один элемент** или null  
* id уникален  
* Вызывается **только от document**

5\. Поиск по CSS-селектору

Один элемент  
document.querySelector('.item');

Все элементы

document.querySelectorAll('.item');

* Используют **любой CSS-селектор**  
* querySelector → первый найденный элемент или null  
* querySelectorAll → **NodeList (статический)**

Что возвращают методы (ключевое отличие)

| Метод | Что возвращает | Живой |
| ----- | ----- | ----- |
| getElementById | Element / null | ❌ |
| getElementsByTagName | HTMLCollection | ✅ |
| getElementsByClassName | HTMLCollection | ✅ |
| getElementsByName | NodeList | ❌ |
| querySelector | Element / null | ❌ |
| querySelectorAll | NodeList | ❌ |

HTMLCollection vs NodeList (частый вопрос)

* **HTMLCollection**  
  * Живой  
  * Только элементы  
  * Нет forEach  
* **NodeList**  
  * Статический (в querySelectorAll)  
  * Может содержать любые узлы  
  * Есть forEach

**Идеальная формулировка для собеседования**

Поиск элементов в DOM можно выполнять через методы getElement\* и querySelector\*. По тегу используется getElementsByTagName, по атрибуту name — getElementsByName, по классу — getElementsByClassName, по id — getElementById. Универсальный способ — querySelector и querySelectorAll, которые принимают CSS-селекторы. getElement\* возвращают живые коллекции, а querySelectorAll — статический NodeList.

### 3\. Какие свойства есть у элемента DOM ? (Свойства узлов: тип, тег и содержимое) 

Общая идея

Каждый элемент DOM — это **узел (Node)**.  
У узлов есть свойства, описывающие:

1. **Тип узла**  
2. **Название тега**  
3. **Содержимое**

Тип узла (nodeType)

node.nodeType  
Возвращает **числовой код типа узла**.  
Основные значения:

| Значение | Тип узла |
| ----- | ----- |
| 1 | Element node (\<div\>) |
| 3 | Text node |
| 8 | Comment node |
| 9 | Document node |

На практике чаще всего проверяют:  
node.nodeType \=== 1 // HTML-элемент

Название тега (tagName, nodeName)

tagName  
element.tagName

* Возвращает **имя HTML-тега в верхнем регистре**  
* Работает **только для элементов**

div.tagName; // "DIV"

nodeName

node.nodeName

* Работает **для любых узлов**  
* Для элементов совпадает с tagName  
* Для текста возвращает \#text

Содержимое узла

innerHTML  
element.innerHTML

* Возвращает или устанавливает **HTML-содержимое**  
* Может менять структуру DOM  
* Менее безопасен (XSS)

textContent

element.textContent

* Возвращает **только текст**  
* Игнорирует HTML-теги  
* Работает быстрее и безопаснее

innerText

element.innerText

* Возвращает **видимый текст**  
* Учитывает CSS (display: none)  
* Медленнее, чем textContent

Краткое сравнение содержимого

| Свойство | HTML | CSS влияет | Безопасность |
| ----- | ----- | ----- | ----- |
| innerHTML | ✅ | ❌ | ❌ |
| textContent | ❌ | ❌ | ✅ |
| innerText | ❌ | ✅ | ✅ |

**Идеальная формулировка для собеседования**

DOM-элемент является узлом и имеет свойства nodeType для определения типа узла, tagName и nodeName для имени тега. Для работы с содержимым используются innerHTML — для HTML, textContent — для чистого текста и innerText — для видимого текста с учётом стилей. В большинстве случаев предпочтителен textContent как более безопасный и быстрый 

### 4\. Какие способы вставки элемента есть : 1.перед элементов 2\. после элемента 3\. внутри дочерних вначале 4.внутри дочерних в конце ? Как удалить элемент из DOM дерева? (Изменение документа)

### 

Общий принцип

DOM — **мутабельное дерево**.  
Элемент можно:

* вставить **относительно другого элемента**  
* вставить **внутрь контейнера**  
* удалить из DOM

Современный стандарт — **методы before / after / prepend / append / remove**.

Вставка элемента перед элементом

element.before(newElement);

* Вставляет newElement **перед** element  
* Работает и с элементами, и со строками

item.before(div);

Вставка элемента после элемента

element.after(newElement);

* Вставляет newElement **после** element

item.after(div);

Вставка внутрь дочерних — в начале

parent.prepend(newElement);

* Добавляет элемент **первым ребёнком**

list.prepend(li);

Вставка внутрь дочерних — в конце

parent.append(newElement);

* Добавляет элемент **последним ребёнком**

list.append(li);

Альтернативный универсальный способ (insertAdjacentHTML)

element.insertAdjacentHTML(position, html);

| Position | Куда вставляет |
| ----- | ----- |
| beforebegin | Перед элементом |
| afterbegin | Внутрь, в начало |
| beforeend | Внутрь, в конец |
| afterend | После элемента |

Используется для **вставки HTML-строк без пересоздания DOM**.

Как удалить элемент из DOM

Современный способ

element.remove();

* Полностью удаляет элемент из DOM  
* Ссылка в JS остаётся

Старый способ (редко)

element.parentElement.removeChild(element);

**Идеальная формулировка для собеседования**

Для изменения DOM используют методы before и after — для вставки элемента перед или после другого элемента, prepend и append — для вставки внутрь контейнера в начало или конец. Для удаления элемента применяется remove(). Также существует метод insertAdjacentHTML, который позволяет вставлять HTML-строку в конкретное место без пересоздания DOM.

### 

# Работа с событиями JS

1. Какие свойства есть в обьекте события (элемент на котором висит обработчик, элемент который инициировал событие) ? Как повесить\\отменить событие ? Как повесить сразу несколько обработчиков на одно событие? Какой нюанс нужно учитывать при удалении обработчика события (подсказка: затрагивает ссылочный тип). Какие 3 стадии есть у события ? Как отменить всплытие сопытия ? Обьект события и его свойства. (Основы работы с событиями, стадии всплытия и погружения)  
2. Как отменить действие браузера по умолчанию ? (Действия браузера по умолчанию)

### 1\. Какие свойства есть в обьекте события (элемент на котором висит обработчик, элемент который инициировал событие) ? Как повесить\\отменить событие ? Как повесить сразу несколько обработчиков на одно событие? Какой нюанс нужно учитывать при удалении обработчика события (подсказка: затрагивает ссылочный тип). Какие 3 стадии есть у события ? Как отменить всплытие сопытия ? Обьект события и его свойства. (Основы работы с событиями, стадии всплытия и погружения)

Объект события (Event)

Когда происходит событие, браузер создаёт **объект события** и передаёт его в обработчик.  
button.addEventListener('click', (event) \=\> {  
  console.log(event);  
});

Ключевые свойства объекта события

🔹 Элемент, на котором висит обработчик  
event.currentTarget

* Элемент, **на котором зарегистрирован обработчик**  
* Всегда один и тот же внутри обработчика

🔹 Элемент, который инициировал событие  
event.target

* Реальный элемент, **где произошло событие**  
* Используется в делегировании событий

Часто используемые свойства

| Свойство | Назначение |
| ----- | ----- |
| type | Тип события (click, input) |
| target | Источник события |
| currentTarget | Элемент с обработчиком |
| eventPhase | Текущая фаза события |
| timeStamp | Время события |

Как повесить событие

Современный способ  
element.addEventListener('click', handler);

* Можно повесить **несколько обработчиков**  
* Не перезаписывает существующие

Как отменить событие

element.removeEventListener('click', handler);

⚠️ **Нюанс:**

* Функция должна быть **той же самой ссылкой**, что и при добавлении

❌ Не сработает:

element.addEventListener('click', () \=\> {});  
element.removeEventListener('click', () \=\> {});

✅ Правильно:

function handler() {}  
element.addEventListener('click', handler);  
element.removeEventListener('click', handler);

Как повесить несколько обработчиков на одно событие

element.addEventListener('click', handler1);  
element.addEventListener('click', handler2);

* Все обработчики выполнятся по порядку добавления

Три стадии события

1. **Погружение (capturing)**  
   Событие идёт от document к целевому элементу  
2. **Целевая фаза (target)**  
   Событие достигает event.target  
3. **Всплытие (bubbling)**  
   Событие поднимается вверх по DOM

element.addEventListener('click', handler, true); // capturing

Как отменить всплытие события

event.stopPropagation();

* Останавливает дальнейшее всплытие

event.stopImmediatePropagation();

* Останавливает всплытие **и другие обработчики на этом элементе**

Как отменить стандартное поведение

event.preventDefault();

* Например: отмена перехода по ссылке или отправки формы

**Идеальная формулировка для собеседования**

При возникновении события браузер создаёт объект Event, который содержит информацию о событии. event.target — элемент, который инициировал событие, а event.currentTarget — элемент, на котором висит обработчик. События навешиваются через addEventListener и удаляются через removeEventListener, при этом важно передавать одну и ту же ссылку на функцию. Событие проходит три стадии: погружение, целевую и всплытие. Всплытие можно остановить через stopPropagation, а стандартное поведение — через preventDefault.

### 2\. Как отменить действие браузера по умолчанию ? (Действия браузера по умолчанию)

Основной способ — event.preventDefault()

* Используется для **отмены стандартного поведения браузера**, связанного с событием.

link.addEventListener('click', (event) \=\> {  
  event.preventDefault();  
});

Что считается действием браузера по умолчанию

Примеры:

* Переход по ссылке \<a\>  
* Отправка формы \<form\>  
* Фокус по клику  
* Прокрутка страницы (wheel, touchmove)  
* Контекстное меню (right click)  
* Перетаскивание элементов

Частые примеры

Отмена отправки формы

form.addEventListener('submit', (e) \=\> {  
  e.preventDefault();  
});

Отмена перехода по ссылке

\<a href="/profile" id="link"\>Profile\</a\>

document.getElementById('link')  
  .addEventListener('click', e \=\> e.preventDefault());

Отмена контекстного меню

document.addEventListener('contextmenu', e \=\> e.preventDefault());

Важный нюанс — passive listeners

* Для некоторых событий (wheel, touchmove) обработчики по умолчанию **passive**  
* В passive-обработчиках **нельзя вызвать preventDefault()**

element.addEventListener('touchmove', handler, { passive: false });

Не путать с stopPropagation

| Метод | Что делает |
| ----- | ----- |
| preventDefault() | Отменяет стандартное поведение |
| stopPropagation() | Останавливает всплытие события |

**Идеальная формулировка для собеседования**

Чтобы отменить действие браузера по умолчанию, используют метод event.preventDefault(). Он блокирует стандартное поведение, например, переход по ссылке или отправку формы. При этом важно учитывать passive-обработчики, в которых preventDefault недоступен, и не путать его с stopPropagation, который управляет только всплытием события.

## Свойства объекта, их конфигурация

1. Какие есть флаги? Способы их установки? Методы глобального запечатывания объекта. (Флаги и дескрипторы свойств)  
2. Что такое? Какие дескрипторы? (Свойства \- геттеры и сеттеры)

### 1\. Какие есть флаги? Способы их установки? Методы глобального запечатывания объекта. (Флаги и дескрипторы свойств)

Что такое флаги (дескрипторы) свойств

Каждое свойство объекта в JavaScript имеет **дескриптор** — набор флагов, определяющих его поведение.  
const user \= { name: "Alice" };  
Object.getOwnPropertyDescriptor(user, 'name');

Основные флаги (для data-свойств)

| Флаг | Значение |
| ----- | ----- |
| value | Значение свойства |
| writable | Можно ли изменять значение |
| enumerable | Участвует ли в for...in, Object.keys |
| configurable | Можно ли удалять и менять дескриптор |

Флаги для accessor-свойств

| Флаг | Назначение |
| ----- | ----- |
| get | Функция-геттер |
| set | Функция-сеттер |
| enumerable | Перечисляемость |
| configurable | Переконфигурация |

⚠️ Accessor-свойство **не может** иметь value и writable.

4\. Способы установки флагов

Object.defineProperty

Object.defineProperty(user, 'age', {  
  value: 30,  
  writable: false,  
  enumerable: true,  
  configurable: false  
});

* Если флаг не указан → false по умолчанию

Object.defineProperties

Object.defineProperties(user, {  
  name: { writable: false },  
  age: { enumerable: false }  
});

Методы глобального «запечатывания» объекта

🔒 Object.preventExtensions(obj)

* Запрещает добавление новых свойств  
* Существующие можно менять и удалять

🔐 Object.seal(obj)

* Запрещает добавление и удаление свойств  
* Делает configurable: false  
* Значения менять можно

❄️ Object.freeze(obj)

* Полностью «замораживает» объект  
* Запрещает:  
  * добавление  
  * удаление  
  * изменение значений  
* Устанавливает writable: false, configurable: false

⚠️ Поверхностная заморозка (shallow)

Проверка состояния объекта

| Метод | Проверка |
| ----- | ----- |
| Object.isExtensible(obj) | Можно ли добавлять свойства |
| Object.isSealed(obj) | Запечатан ли |
| Object.isFrozen(obj) | Заморожен ли |

**Идеальная формулировка для собеседования**

Свойства объектов имеют дескрипторы с флагами writable, enumerable и configurable. Они определяют, можно ли изменять значение, участвует ли свойство в перечислении и можно ли его удалять или переконфигурировать. Флаги задаются через Object.defineProperty. Для глобального ограничения объекта используются preventExtensions, seal и freeze, которые поэтапно ограничивают добавление, удаление и изменение свойств.

### 2\. Что такое? Какие дескрипторы? (Свойства \- геттеры и сеттеры)

Что такое геттеры и сеттеры

**Геттеры и сеттеры** — это свойства объекта, значение которых определяется **функциями доступа**, а не хранимым значением.

* get — вызывается при чтении свойства  
* set — вызывается при записи свойства

const user \= {  
  name: 'Alex',  
  get fullName() {  
    return this.name \+ ' Smith';  
  },  
  set fullName(value) {  
    this.name \= value.split(' ')\[0\];  
  }  
};

📌 Внешне используются **как обычные свойства**, а не как функции.

Какие дескрипторы есть у accessor-свойств

Accessor-свойства имеют **другой набор дескрипторов**, чем data-свойства.  
Дескрипторы accessor-свойства

| Дескриптор | Назначение |
| ----- | ----- |
| get | Функция-геттер |
| set | Функция-сеттер |
| enumerable | Перечисляемость |
| configurable | Возможность изменения/удаления |

❌ У accessor-свойств **нет**:

* value  
* writable

Получение дескриптора

Object.getOwnPropertyDescriptor(user, 'fullName');

Результат:  
{  
  get: ƒ,  
  set: ƒ,  
  enumerable: true,  
  configurable: true  
}  
Создание геттеров и сеттеров через defineProperty

Object.defineProperty(user, 'age', {  
  get() {  
    return this.\_age;  
  },  
  set(value) {  
    if (value \< 0\) throw new Error('Invalid age');  
    this.\_age \= value;  
  },  
  enumerable: true,  
  configurable: true  
});

Отличие accessor-свойств от data-свойств

| Data property | Accessor property |
| ----- | ----- |
| value, writable | get, set |
| Хранит значение | Вычисляет значение |
| Можно напрямую изменить | Можно валидировать |

Зачем нужны геттеры и сеттеры

Основные задачи:

1. **Инкапсуляция**  
2. **Валидация данных**  
3. **Ленивая и вычисляемая логика**  
4. **Обратная совместимость API**  
5. **Реакция на изменение значения**

set price(value) {  
  this.\_price \= value;  
  this.recalculateTotal();  
}

Важные нюансы (часто спрашивают)

Геттер вызывается при:

obj.prop;

Сеттер вызывается при:

obj.prop \= value;

Если сеттера нет

obj.prop \= value; // silently ignored или TypeError в strict mode

this в геттере/сеттере

* this — объект, к которому обращаются

**Формулировка для собеседования**

Геттеры и сеттеры — это accessor-свойства, которые позволяют перехватывать чтение и запись значения. Они не имеют value и writable, а вместо этого используют функции get и set. Управляются через дескрипторы свойств и позволяют реализовать инкапсуляцию, валидацию и вычисляемые свойства, оставаясь прозрачными для пользователя API.

# Прототипы, наследование

1. Что такое наследование? Где лежит прототип? Куда происходит запись? Какое значение this? Как получить только неунаследованные ключи?( Прототипное наследование)  
2. Как добавить прототип в функцию конструктор? Как экземпляр связывается с функционалом функции-конструктора ? (F.prototype Middle+ Какие встроеные прототипы есть? Как изменить встроеный прототип? Встроенные прототипы Middle- Как создать объект без прототипа? Зачем такое нужно? (Методы прототипов)

### 1\. Что такое наследование? Где лежит прототип? Куда происходит запись? Какое значение this? Как получить только неунаследованные ключи?( Прототипное наследование)

Что такое наследование в JavaScript

**Наследование** — это механизм, при котором объект получает доступ к свойствам и методам другого объекта через **цепочку прототипов**.

В JS наследование **прототипное**, а не классовое.  
const animal \= {  eats: true};  
const dog \= {  barks: true};

Object.setPrototypeOf(dog, animal);

Теперь:  
dog.eats // true (унаследовано)

Где лежит прототип

Фактически:

* Прототип хранится во **внутреннем слоте** объекта — \[\[Prototype\]\]

Доступ к нему:

* obj.\_\_proto\_\_ (не рекомендуется)  
* Object.getPrototypeOf(obj) — корректно  
* Object.setPrototypeOf(obj, proto) — установка

Object.getPrototypeOf(dog) \=== animal; // true

Как работает поиск свойства

1. Сначала ищется **в самом объекте**  
2. Если не найдено — поиск идёт в \[\[Prototype\]\]  
3. Далее — вверх по цепочке  
4. До null

dog.barks  // найдено в dog  
dog.eats   // найдено в animal

Куда происходит запись свойства

❗ **Запись всегда происходит в сам объект**, а не в прототип.  
dog.eats \= false;

Теперь:  
dog.eats      // false (собственное)  
animal.eats  // true (не изменился)

📌 Исключение:

* если в прототипе есть **setter**, он будет вызван

Какое значение this

this всегда указывает на **объект слева от точки**, а не на прототип.  
const animal \= {  
  say() {  
    console.log(this.type);  
  }  
};  
const dog \= {  type: 'dog'};  
Object.setPrototypeOf(dog, animal);  
dog.say(); // this \=== dog  
📌 Даже если метод лежит в прототипе — this это **вызывающий объект**.

Наследование и функции-конструкторы

function Animal(name) {  
  this.name \= name;  
}

Animal.prototype.eat \= function () {  
  return this.name \+ ' eats';  
};

function Dog(name) {  
  Animal.call(this, name);  
}

Dog.prototype \= Object.create(Animal.prototype);  
Dog.prototype.constructor \= Dog;

Цепочка:  
dog → Dog.prototype → Animal.prototype → Object.prototype → null

Как получить только НЕунаследованные ключи

✅ Собственные enumerable-свойства  
Object.keys(obj);

✅ Все собственные (включая non-enumerable)

Object.getOwnPropertyNames(obj);

✅ Собственные \+ Symbol

Object.getOwnPropertySymbols(obj);

✅ Абсолютно все собственные

Reflect.ownKeys(obj);

❌ for...in

for (const key in obj) {  
  // включает унаследованные enumerable  
}

Проверка: собственное или унаследованное

obj.hasOwnProperty('key');          // true / false  
Object.hasOwn(obj, 'key');          // современный вариант

Частые вопросы с подвохом

Можно ли менять прототип?

* Да, но **дорого по производительности**  
* Лучше задавать при создании (Object.create)

Что у вершины цепочки?

Object.getPrototypeOf(Object.prototype) \=== null;

**Краткая формулировка для собеседования**

В JavaScript наследование реализовано через цепочку прототипов. Каждый объект имеет скрытое свойство \[\[Prototype\]\], по которому происходит поиск свойств. Чтение идёт вверх по цепочке, а запись всегда происходит в сам объект. Значение this определяется объектом вызова, а не местом объявления метода. Для получения только собственных свойств используются Object.keys, Object.getOwnPropertyNames и Reflect.ownKeys.

### 2\. Как добавить прототип в функцию конструктор? Как экземпляр связывается с функционалом функции-конструктора ? (F.prototype Middle+ Какие встроеные прототипы есть? Как изменить встроеный прототип? Встроенные прототипы Middle- Как создать объект без прототипа? Зачем такое нужно? (Методы прототипов)

Как добавить прототип в функцию-конструктор (F.prototype)

У **каждой функции** в JS есть свойство prototype (используется **только при вызове через new**).  
function User(name) {  
  this.name \= name;  
}  
User.prototype.sayHi \= function () {  
  return \`Hi, ${this.name}\`;  
};

* User.prototype — объект, который станет прототипом экземпляров  
* В него добавляют **методы и общие свойства**

Как экземпляр связывается с функционалом конструктора

При вызове new User() происходит **4 шага**:

1. Создаётся пустой объект  
2. Его \[\[Prototype\]\] указывает на User.prototype  
3. this внутри User ссылается на этот объект  
4. Возвращается объект (если return не вернул объект явно)

const user \= new User('Alex');  
Object.getPrototypeOf(user) \=== User.prototype; // true

📌 Связь:  
user → \[\[Prototype\]\] → User.prototype  
Где правильно хранить методы

❌ Плохо (дублирование):  
function User() {  
  this.sayHi \= function () {};  
}  
✅ Правильно:  
User.prototype.sayHi \= function () {};

Какие встроенные прототипы есть (Middle-)

Каждый тип имеет свой прототип:

| Тип | Прототип |
| ----- | ----- |
| Object | Object.prototype |
| Array | Array.prototype |
| Function | Function.prototype |
| Number | Number.prototype |
| String | String.prototype |
| Boolean | Boolean.prototype |
| Date | Date.prototype |
| RegExp | RegExp.prototype |
| Map | Map.prototype |
| Set | Set.prototype |
| Promise | Promise.prototype |
| Error | Error.prototype |

Пример цепочки:  
\[\] → Array.prototype → Object.prototype → null

Как изменить встроенный прототип

⚠ **Технически возможно, но крайне не рекомендуется**  
Array.prototype.last \= function () {  
  return this\[this.length \- 1\];  
};

Риски:

* конфликты имён  
* ломает сторонние библиотеки  
* неожиданные баги  
* проблемы при обновлениях JS

📌 Допустимо:

* **полифилы стандартов**  
* методы с проверкой существования

if (\!Array.prototype.last) {  
  Array.prototype.last \= function () {};  
}

Как создать объект без прототипа

const dict \= Object.create(null);

Результат:  
dict.\_\_proto\_\_ \=== undefined;

Зачем нужен объект без прототипа

Основные причины:

1. **Чистый словарь**  
   * нет toString, constructor, \_\_proto\_\_  
2. Безопасная работа с ключами  
   dict\['\_\_proto\_\_'\] \= 'test'; // не ломает объект  
3. Быстрее и предсказуемее для map-подобных структур

📌 Часто используется для:

* словарей  
* конфигураций  
* lookup-таблиц

Методы работы с прототипами

Получить прототип  
Object.getPrototypeOf(obj);

Установить прототип

Object.setPrototypeOf(obj, proto); // дорого

Создать объект с прототипом

Object.create(proto);

Проверка принадлежности прототипу

obj instanceof Constructor;  
Constructor.prototype.isPrototypeOf(obj);

Частые вопросы на собеседовании

Почему нельзя менять prototype после создания экземпляров?

User.prototype \= {};

→ старые объекты останутся привязанными к старому прототипу

Чем отличается prototype и \_\_proto\_\_?

* prototype — свойство **функции**  
* \_\_proto\_\_ — ссылка **объекта** на его прототип

**Краткая формулировка для собеседования**

При вызове функции-конструктора через new объект связывается с F.prototype через \[\[Prototype\]\]. Методы конструктора следует размещать в prototype, чтобы избежать дублирования. Встроенные типы имеют собственные прототипы, образующие цепочку до Object.prototype. Изменять встроенные прототипы не рекомендуется, за исключением полифилов. Объекты без прототипа создаются через Object.create(null) и используются как безопасные словари.

# Классы

1. Что такое класс? Что такое конструктор класса и когда он создается? Как можно заменить класс , функцией конструктором ? (Класс)  
2. Как переопределить методы класса? Как переорпеделить конструктор? Что такое super? Как в этом участвуют прототипы? (Наследование классо)  
3. Что такое static? Могут ли быть класс, константа, функция статическими? Для чего это надо? (Статические свойства и методы)  
4. Как указать что поле приватное/защищённое? Какие выгоды это даёт? (Приватные и защищённые методы и свойства)  
5. Как происходит наследование статических методов? Middle Как расширить встроенный класс? Какое отличие наследования встроенных классов? (Расширение встроенных классов)  
6. Как проверить к какому классу принадлежит объект? Почему нельзя использовать typeOf? Как работает instanceOf ?( instanceOf)  
7. Как вынести общую логику между классами?(Примеси)

### 1\. Что такое класс? Что такое конструктор класса и когда он создается? Как можно заменить класс , функцией конструктором ? (Класс)

Что такое класс

**Класс** в JavaScript — это **синтаксический сахар** над **функциями-конструкторами и прототипным наследованием**.

* Позволяет создавать объекты с общими методами и свойствами  
* Внутри класса можно объявлять методы, геттеры/сеттеры, статические методы

class User {  
  constructor(name) {    this.name \= name; // свойство экземпляра  }  
  sayHi() {    console.log(\`Hi, ${this.name}\`);  }  
  static info() {    console.log("I am a User class");  }  
}

Конструктор класса

* Метод constructor вызывается **при создании нового экземпляра через new**  
* Используется для **инициализации свойств объекта**  
* В классе может быть **только один constructor**

const user \= new User('Alex');  
user.sayHi(); // Hi, Alex

* Если constructor не объявлен, создается **пустой конструктор по умолчанию**.

⚠ Особенности

1. constructor **не может быть вызван без new**

User(); // TypeError

2. Внутри конструктора this указывает на создаваемый экземпляр  
3. Методы класса автоматически попадают в prototype, а не в сам объект

User.prototype.sayHi \=== user.sayHi; // true

Как можно заменить класс функцией-конструктором

Класс эквивалентен функции-конструктору с прототипными методами:  
function User(name) {  this.name \= name; // аналог constructor}

// методы в prototype  
User.prototype.sayHi \= function () {  console.log(\`Hi, ${this.name}\`);};

User.info \= function () {  console.log("I am a User class");};

Использование:  
const user \= new User('Alex');  
user.sayHi(); // Hi, Alex  
User.info(); // I am a User class

Сравнение класса и функции-конструктора

| Характеристика | Класс | Функция-конструктор |
| ----- | ----- | ----- |
| Синтаксис | class | function |
| Методы | prototype | prototype |
| Статические методы | static | Присвоение функции |
| constructor | Обязательный метод | Тело функции |
| Вызов без new | ❌ TypeError | Можно, но this будет window (или undefined в strict) |
| Наследование | extends | F.prototype \= Object.create(P.prototype) |

Идеальная формулировка для собеседования

Класс в JavaScript — это синтаксический сахар над функцией-конструктором и прототипным наследованием. Метод constructor создаётся автоматически или объявляется вручную для инициализации экземпляра. Методы класса попадают в prototype, статические — в саму функцию. Любой класс можно заменить функцией-конструктором с прототипными методами и статическими свойствами, функционально поведение будет идентичным.

### 2\. Как переопределить методы класса? Как переорпеделить конструктор? Что такое super? Как в этом участвуют прототипы? (Наследование классов)

Как переопределить методы класса

При наследовании подкласс может **переопределить метод родителя**:  
class Animal {  speak() {    console.log("Animal speaks");  }}  
class Dog extends Animal {   
   speak() { // переопределение     
     console.log("Dog barks");    
   }  
}

const dog \= new Dog();  
dog.speak(); // Dog barks

* Метод с тем же именем в подклассе **замещает** метод родителя  
* Вызов через super позволяет обратиться к родительскому методу

class Dog extends Animal {  
  speak() {  
    super.speak(); // вызов родительского метода  
    console.log("Dog barks");  
  }  
}

Как переопределить конструктор

* Подкласс может объявить свой constructor  
* **Обязательно вызвать super()** перед использованием this

class Animal {  
  constructor(name) {  
    this.name \= name;  
  }  
}

class Dog extends Animal {  
  constructor(name, breed) {  
    super(name); // вызов конструктора родителя  
    this.breed \= breed;  
  }  
}

const dog \= new Dog("Max", "Bulldog");  
console.log(dog.name, dog.breed); // Max Bulldog

* Если constructor в подклассе отсутствует — создаётся автоматически и вызывает super(...) с аргументами.

Что такое super

super выполняет **две функции**:

1. В конструкторе — вызывает **конструктор родителя** и инициализирует this  
2. В методах — позволяет обратиться к **методу родителя**

class A {  hello() { console.log("A"); }}  
class B extends A {  
  hello() {   
    super.hello(); // вызывает A.hello  
    console.log("B");   
  }  
}  
Как в этом участвуют прототипы

Цепочка наследования классов реализована через **прототипы**:  
instance.\_\_proto\_\_ → SubClass.prototype → SuperClass.prototype → Object.prototype → null

Пример:  
Dog.prototype.\_\_proto\_\_ \=== Animal.prototype; // true

* Методы родителя доступны через прототипную цепочку  
* Переопределение метода в подклассе просто добавляет метод в SubClass.prototype, скрывая метод родителя в цепочке

Проверка цепочки

const dog \= new Dog("Max", "Bulldog");

dog instanceof Dog;     // true  
dog instanceof Animal;  // true

Object.getPrototypeOf(Dog.prototype) \=== Animal.prototype; // true

**Идеальная формулировка для собеседования**

Наследование классов в JavaScript реализовано через цепочку прототипов. Подкласс может переопределить методы и конструктор родителя. Конструктор подкласса должен вызывать super(...) для инициализации родительской части. В методах super.method() позволяет вызвать метод родителя. Все методы хранятся в prototype, а цепочка instance.\_\_proto\_\_ → SubClass.prototype → SuperClass.prototype → Object.prototype → null обеспечивает поиск свойств и методов.

### 3\. Что такое static? Могут ли быть класс, константа, функция статическими? Для чего это надо? (Статические свойства и методы)

Что такое static

* static — ключевое слово для объявления **методов или свойств**, которые **принадлежат классу**, а не экземпляру.  
* Такие методы/свойства **не доступны через this экземпляра**, только через сам класс.

class User {  
  static description \= "This is a User class";  
  static greet() {  
    console.log("Hello from User");  
  }  
}

console.log(User.description); // "This is a User class"  
User.greet();                 // "Hello from User"

const user \= new User();  
// user.greet(); // Error: greet is not a function

Могут ли быть класс, константа, функция статическими?

* **Класс**: нет, нельзя объявить "статический класс" в JS — класс и так декларация.  
* **Константа внутри класса**: да, можно через static  
* **Метод функции**: да, метод класса можно сделать static

Пример с константой:

class MathHelper {  
  static PI \= 3.1415;  
  static area(radius) {  
    return MathHelper.PI \* radius \*\* 2;  
  }  
}  
console.log(MathHelper.area(2)); // 12.566

Для чего нужны статические методы и свойства

Основные задачи:

1. **Хелперы и утилиты**  
   * Методы, которые не зависят от состояния экземпляра

   Math.max(1,2,3);

2. **Константы класса**  
   * Общие данные для всех экземпляров  
3. **Фабричные методы**  
   * Создание экземпляров с определёнными настройками

class User {  
  constructor(name) { this.name \= name; }  
  static createAdmin(name) { return new User(name \+ ' (admin)'); }  
}

Особенности

* static метод **не наследует this экземпляра**, но может использовать super для обращения к статическим методам родителя:  
  class Parent {  
    static greet() { console.log("Hi from Parent"); }  
  }  
    
  class Child extends Parent {  
    static greet() {   
      super.greet();   
      console.log("Hi from Child");   
    }  
  }  
    
  Child.greet();  
  // Hi from Parent  
  // Hi from Child  
* Статические методы **часто используются как вспомогательные** и не требуют создания экземпляра.

Сравнение с методами экземпляра

| Метод | Где хранится | Доступ через |
| ----- | ----- | ----- |
| Экземплярный | Class.prototype | instance.method() |
| Статический | Class | Class.method() |

**Идеальная формулировка для собеседования**

Статические методы и свойства объявляются с помощью ключевого слова static и принадлежат классу, а не экземплярам. Они используются для утилитарных функций, констант и фабричных методов. Экземпляр не имеет доступа к статическим методам через this. Статические методы могут наследоваться и использовать super для вызова методов родителя.

### 4\. Как указать что поле приватное/защищённое? Какие выгоды это даёт? (Приватные и защищённые методы и свойства)

Как указать приватное поле или метод

В **современном JavaScript (ES2022+)** приватные поля и методы объявляются с **\#**:  
class User {  
  \#password; // приватное поле  
  constructor(name, password) {  
    this.name \= name;   // публичное поле  
    this.\#password \= password;  
  }  
  \#showPassword() {     // приватный метод  
    console.log(this.\#password);  
  }  
  checkPassword(pass) {  
    return this.\#password \=== pass;  
  }  
  revealPassword() {  
    this.\#showPassword();  
  }  
}

const user \= new User("Alex", "12345");  
console.log(user.name); // Alex  
// console.log(user.\#password); // Error  
user.revealPassword(); // 12345

Особенности:

1. Приватное поле **не доступно за пределами класса**  
2. Приватные методы могут вызываться только внутри класса  
3. Нельзя обращаться через this\["\#field"\] или user.\#field извне

Защищённые поля (protected)

* В чистом JS **нет полноценного protected**, как в других языках  
* **Конвенция**: использовать \_ перед именем:

class User {  
  \_role \= "user"; // условно защищённое  
}

class Admin extends User {  
  promote() {  
    console.log(this.\_role); // доступно в наследнике  
  }  
}

* \_field доступно извне, но считается **соглашением**, что его использовать напрямую не нужно.

Выгоды приватных и защищённых полей

1. **Инкапсуляция**  
   * Скрываем внутреннее состояние объекта  
   * Контролируем доступ к данным  
2. **Безопасность**  
   * Исключаем случайное изменение важных свойств извне  
3. **Поддерживаемый API**  
   * Публичные методы управляют доступом к внутренним данным  
4. **Читаемость и соглашения**  
   * \_field и \#field показывают другим разработчикам, что поле внутреннее

Использование в наследовании

class User {  
  \#password \= "123";  
  getPassword() { return this.\#password; }  
}

class Admin extends User {  
  showPassword() {  
    // console.log(this.\#password); // Error, приватное не наследуется  
    console.log(this.getPassword()); // можно через публичный метод  
  }  
}

* Приватные поля **не наследуются**, защищённые (\_) доступны в подклассах

**Идеальная формулировка для собеседования**

Приватные поля и методы в JavaScript обозначаются символом \# и доступны только внутри класса, что обеспечивает строгую инкапсуляцию и безопасность данных. Защищённые поля можно имитировать через соглашение \_field, которое позволяет использовать их в подклассах. Преимущества: контроль доступа к данным, предотвращение случайного изменения, поддерживаемый API и читаемость кода.

### 5\. Как происходит наследование статических методов? Middle Как расширить встроенный класс? Какое отличие наследования встроенных классов? (Расширение встроенных классов)

Наследование статических методов

* **Статические методы наследуются от родителя**, как и обычные методы, но через сам класс, а не через экземпляр.

class Parent {  
  static greet() { console.log("Hello from Parent"); }  
}  
class Child extends Parent {}  
Child.greet(); // Hello from Parent

* Можно **переопределить статический метод** в подклассе:

class Child extends Parent {  
  static greet() {  
    console.log("Hello from Child");  
  }  
}

Child.greet(); // Hello from Child  
Parent.greet(); // Hello from Parent

* Цепочка статических методов работает через \[\[Prototype\]\] функции:

Object.getPrototypeOf(Child) \=== Parent; // true

Как расширить встроенный класс

Встроенные классы (Array, Map, Error, Date) **можно расширять через extends**:  
class MyArray extends Array {  
  first() {  
    return this\[0\];  
  }  
}

const arr \= new MyArray(1, 2, 3);  
console.log(arr.first()); // 1  
console.log(arr instanceof MyArray); // true  
console.log(arr instanceof Array);   // true

* Конструктор встроенного класса **нужно вызвать через super()**, иначе объект не создастся корректно:

class MyDate extends Date {  
  getYearMonth() {  
    return \`${this.getFullYear()}-${this.getMonth() \+ 1}\`;  
  }  
}  
const d \= new MyDate("2026-01-03");  
console.log(d.getYearMonth()); // 2026-1

Особенности наследования встроенных классов

1. **Собственный внутренний объект**  
   * Например, массив имеет внутренние свойства length и методы (push, pop)  
   * Если наследовать через Object.create(Array.prototype) — нельзя, нужно extends Array \+ super()  
2. **Методы встроенного класса работают корректно только через super()**  
   class MyArray extends Array {  
     constructor(...args) {  
       super(...args); // иначе this не проинициализирован  
     }  
   }  
3. **Статические методы встроенных классов наследуются**  
   class MyDate extends Date {}

console.log(MyDate.now() \=== Date.now()); // true

4. **Прототипы встроенных классов**  
   arr.\_\_proto\_\_ → MyArray.prototype → Array.prototype → Object.prototype → null

MyArray.\_\_proto\_\_ → Array

Отличие от обычного наследования

| Параметр | Обычные классы | Встроенные классы |
| ----- | ----- | ----- |
| Вызов конструктора | super() в подклассе | super() обязателен для корректной инициализации внутреннего объекта |
| Методы | Через прототип | Методы встроенного объекта работают на внутренних слотах (length, элементы массива) |
| Статические методы | Наследуются через цепочку функции | Наследуются через цепочку функций, включая встроенные |
| Инстансы | Простые объекты | Экземпляры встроенных классов имеют внутренние оптимизированные слоты и поведение |

**Идеальная формулировка для собеседования**

Статические методы класса наследуются от родителя через цепочку \[\[Prototype\]\] функций и могут быть переопределены в подклассе. Встроенные классы (Array, Map, Date и т.д.) можно расширять через extends, но важно вызывать super() в конструкторе, чтобы корректно инициализировать внутренние слоты. Отличие от обычного наследования — встроенные объекты имеют внутренние свойства, специфические методы и оптимизации, поэтому наследование без extends не работает корректно.

### 6\. Как проверить к какому классу принадлежит объект? Почему нельзя использовать typeOf? Как работает instanceOf ?( instanceOf)

Как проверить, к какому классу принадлежит объект

* Для проверки наследования и принадлежности к классу в JS используют **instanceof**:

class User {}  
class Admin extends User {}

const admin \= new Admin();

console.log(admin instanceof Admin); // true  
console.log(admin instanceof User);  // true  
console.log(admin instanceof Object); // true

* instanceof проверяет, **есть ли в цепочке прототипов объекта prototype функции-конструктора**.

Почему нельзя использовать typeof для классов/объектов

* typeof возвращает **тип данных**, а не класс или конструктор:

const obj \= {};  
console.log(typeof obj); // "object"

const arr \= \[\];  
console.log(typeof arr); // "object" — нельзя отличить массив от объекта

* То есть typeof не подходит для проверки принадлежности к конкретному классу, только для примитивов:

| Значение | typeof |
| ----- | ----- |
| 42 | "number" |
| "abc" | "string" |
| true | "boolean" |
| null | "object" (особенность JS) |
| undefined | "undefined" |
| {} | "object" |
| \[\] | "object" |
| function | "function" |

Как работает instanceof

Синтаксис:  
object instanceof Constructor

Механизм:

1. Берём Constructor.prototype  
2. Идём по цепочке прототипов объекта (\_\_proto\_\_ / \[\[Prototype\]\])  
3. Если находим Constructor.prototype в цепочке → возвращаем true  
4. Если дошли до null — false

console.log(Object.getPrototypeOf(admin) \=== Admin.prototype); // true  
console.log(Object.getPrototypeOf(Object.getPrototypeOf(admin)) \=== User.prototype); // true

Именно поэтому:

const arr \= \[\];  
console.log(arr instanceof Array);  // true  
console.log(arr instanceof Object); // true

* instanceof учитывает **прототипное наследование**, не только прямое создание экземпляра.

Особенности и нюансы

1. **Работает только для объектов**, не для примитивов напрямую  
   console.log(42 instanceof Number); // false  
   console.log(new Number(42) instanceof Number); // true  
2. **Можно переопределить поведение через Symbol.hasInstance**  
   class EvenNumber {  
     static \[Symbol.hasInstance\](obj) {  
       return typeof obj \=== 'number' && obj % 2 \=== 0;  
     }  
   }  
   console.log(2 instanceof EvenNumber); // true  
   console.log(3 instanceof EvenNumber); // false

**Идеальная формулировка для собеседования**

Чтобы проверить принадлежность объекта к классу, используют instanceof, который проверяет наличие Constructor.prototype в цепочке прототипов объекта. typeof нельзя использовать для этого, так как он возвращает только тип данных (object, function, string и т.д.) и не различает конкретные классы. instanceof учитывает наследование: если объект был создан через подкласс, instanceof вернёт true для родительского класса.

### 7\. Как вынести общую логику между классами?(Примеси)

Что такое примесь (mixin)

**Примесь** — это способ **переиспользовать общую функциональность между классами**, без использования наследования.

* Идея: берём **объект или функцию**, содержащую методы, и «подмешиваем» их в класс.  
* Применяется, когда **классы должны делить поведение**, но **не находятся в иерархии**.

Простейший пример примеси

const CanEat \= {  
  eat() {  
    console.log(\`${this.name} is eating\`);  
  }  
};  
const CanWalk \= {  
  walk() {  
    console.log(\`${this.name} is walking\`);  
  }  
};  
class Person {  
  constructor(name) {  
    this.name \= name;  
  }  
}

// Подмешиваем методы  
Object.assign(Person.prototype, CanEat, CanWalk);

const john \= new Person("John");  
john.eat();  // John is eating  
john.walk(); // John is walking

* Object.assign копирует методы из объекта в prototype класса  
* Методы становятся доступными экземплярам

Примеси через функции

Можно сделать **фабрику примеси**, которая принимает класс и возвращает расширенный класс:  
const CanFly \= (Base) \=\> class extends Base {  
  fly() {  
    console.log(\`${this.name} is flying\`);  
  }  
};  
class Animal {  
  constructor(name) { this.name \= name; }  
}  
class Bird extends CanFly(Animal) {}  
const eagle \= new Bird("Eagle");  
eagle.fly(); // Eagle is flying

* Такой подход **поддерживает цепочку наследования**, одновременно добавляя функциональность

Почему примеси полезны

1. **Переиспользование кода** без дублирования  
2. **Композиция вместо наследования**  
   * Можно комбинировать функциональность из нескольких источников  
3. **Гибкость**  
   * Не нужно строить сложную иерархию классов

Ограничения и нюансы

* Конфликты имен методов — последний в Object.assign перекрывает предыдущий  
* Сложно отследить, откуда пришёл метод при больших примесях  
* Статические методы тоже можно миксовать, но через Object.assign(Class, mixin)

**Идеальная формулировка для собеседования**

Примесь (mixin) — это способ вынести общую логику между классами без наследования. Обычно реализуется через объект или функцию, содержащую методы, которые затем «подмешиваются» в prototype класса с помощью Object.assign или через расширение класса через фабричную функцию. Примеси позволяют переиспользовать функциональность, комбинировать поведение нескольких источников и избегать жёсткой иерархии наследования.

# Обработка ошибок

1. Как обрабатывать ошибки? Как создать свою собственную ошибку? Как выполнить код после try и catch? Какие данные об ошибке мы можем получить? Какие есть глобальные обработчики ошибок ? (try catch)

### 1\. Как обрабатывать ошибки? Как создать свою собственную ошибку? Как выполнить код после try и catch? Какие данные об ошибке мы можем получить? Какие есть глобальные обработчики ошибок ? (try catch)

Как обрабатывать ошибки

В JavaScript для обработки ошибок используется конструкция **try...catch...finally**:  
try {  
  // Код, который может вызвать ошибку  
  const result \= riskyOperation();  
  console.log(result);  
} catch (error) {  
  // Блок обработки ошибок  
  console.error("Произошла ошибка:", error.message);  
} finally {  
  // Код, который выполнится в любом случае  
  console.log("Блок finally выполнен");  
}

* **try** — выполняется код, который может выбросить исключение  
* **catch** — ловит ошибку и предоставляет объект ошибки  
* **finally** — выполняется всегда, независимо от того, была ошибка или нет

Как создать собственную ошибку

Можно создать **пользовательскую ошибку**, наследуя стандартный класс Error:  
class ValidationError extends Error {  
  constructor(message) {  
    super(message);  // устанавливает message  
    this.name \= "ValidationError"; // имя ошибки  
  }  
}  
function validateAge(age) {  
  if (age \< 0\) throw new ValidationError("Возраст не может быть отрицательным");  
}  
try {  
  validateAge(-5);  
} catch (err) {  
  console.error(err.name, "-", err.message); // ValidationError \- Возраст не может быть отрицательным  
}

Какие данные об ошибке доступны

В объекте ошибки (Error) есть несколько полезных свойств:

| Свойство | Описание |
| ----- | ----- |
| message | Сообщение об ошибке |
| name | Имя ошибки (Error, TypeError, ReferenceError, пользовательское) |
| stack | Стек вызовов (где произошла ошибка) |

Пример:  
try {  
  throw new Error("Что-то пошло не так");  
} catch (err) {  
  console.log(err.message); // Что-то пошло не так  
  console.log(err.name);    // Error  
  console.log(err.stack);   // Стек вызовов  
}

Глобальные обработчики ошибок

1.  Для браузера  
* window.onerror — ловит необработанные ошибки

  window.onerror \= function(message, source, lineno, colno, error) {

    console.log("Глобальная ошибка:", message);

  };

* window.onunhandledrejection — ловит необработанные промисы

  window.onunhandledrejection \= function(event) {

    console.log("Необработанный промис:", event.reason);

  };

2.  Для Node.js  
* process.on("uncaughtException", handler) — необработанные ошибки  
* process.on("unhandledRejection", handler) — необработанные промисы

**Идеальная формулировка для собеседования**

В JavaScript ошибки обрабатываются через try...catch...finally. try выполняет потенциально опасный код, catch ловит исключение и предоставляет объект ошибки с полями message, name, stack. finally выполняется всегда. Можно создавать собственные ошибки через наследование Error. Для глобальной обработки ошибок существуют window.onerror и window.onunhandledrejection в браузере, а в Node.js — события uncaughtException и unhandledRejection. Это позволяет централизованно логировать и управлять ошибками в приложении.

# 

# Промисы

1. Что такое callback? Как обрабатывать ошибки? Как вызвать callback внутри callback? Есть ли недостатки?( Callback)  
2. Что такое Promise? Какие два состояния могут быть? Могут ли сработать оба состояния одновременно? Что делают resolve и reject? Как работать с результатом работы промиса? (Promise, Цепочка промисов)  
3. Как обрабатываются ошибки внутри промисов? Что будет если поставить then после catch? Что будет если не поставить catch? Второй аргуметр у then. (Промисы: обработка ошибок)  
4. all, allSettled, any, race, resolve, reject (Promise API)  
5. Что такое async/await? В каких функциях можно использовать await? Можно использовать await глобально? Как работает await с успешным\\отклоненым промисом? (async/await)

1\. Что такое callback? Как обрабатывать ошибки? Как вызвать callback внутри callback? Есть ли недостатки?( Callback)

Что такое callback

**Callback** — это функция, которая передаётся другой функции **для выполнения после завершения какой-либо операции**.

Пример:  
function fetchData(callback) {  
  setTimeout(() \=\> {  
    const data \= { id: 1, name: "John" };  
    callback(data);  
  }, 1000);  
}  
fetchData((result) \=\> {  
  console.log("Полученные данные:", result);  
});

* Часто используются для асинхронных операций: чтение файла, HTTP-запросы, таймеры

Как обрабатывать ошибки в callback  
В классическом стиле Node.js используется **первый аргумент callback — ошибка**:  
function fetchData(callback) {  
  setTimeout(() \=\> {  
    const error \= false;  
    if (error) {  
      callback(new Error("Произошла ошибка"));  
    } else {  
      callback(null, { id: 1, name: "John" });  
    }  
  }, 1000);  
}  
fetchData((err, data) \=\> {  
  if (err) {  
    console.error("Ошибка:", err.message);  
  } else {  
    console.log("Данные:", data);  
  }  
});

* Принцип: callback(error, result)  
* Если ошибка есть — обрабатываем, иначе используем результат

Вызов callback внутри callback (Callback Hell)

Когда нужно выполнить несколько последовательных асинхронных операций:  
getData((err, data) \=\> {  
  if (err) return console.error(err);  
  processData(data, (err, processed) \=\> {  
    if (err) return console.error(err);  
    saveData(processed, (err, saved) \=\> {  
      if (err) return console.error(err);  
      console.log("Готово:", saved);  
    });  
  });  
});

* Это приводит к **«пирамиде судьбы» (Callback Hell)**:  
  * Код становится сложно читаемым  
  * Трудно обрабатывать ошибки глобально  
  * Сложно отлаживать

Недостатки callback

1. **Трудночитаемый код при сложных цепочках**  
2. **Сложность обработки ошибок** — нужно проверять каждый callback  
3. **Нет гарантии последовательного выполнения без вложенности**  
4. **Легко забыть вызвать callback** → «висящие» операции

**Итоговая формулировка для собеседования**

Callback — это функция, передаваемая другой функции для выполнения после завершения операции. Ошибки обрабатываются через первый аргумент callback (callback(err, result)). Несколько последовательных callback-ов вызывают «Callback Hell», который снижает читаемость и усложняет обработку ошибок. Основные недостатки: трудно читать, сложно обрабатывать ошибки и управлять последовательностью выполнения.

2\. Что такое Promise? Какие два состояния могут быть? Могут ли сработать оба состояния одновременно? Что делают resolve и reject? Как работать с результатом работы промиса? (Promise, Цепочка промисов)

Что такое Promise

**Promise** — это объект, который представляет **результат асинхронной операции, который может быть доступен в будущем**.

* Позволяет избежать «callback hell»  
* Упрощает чтение и обработку ошибок

Синтаксис создания:

const promise \= new Promise((resolve, reject) \=\> {  
  // Асинхронная операция  
  const success \= true;  
  if (success) {  
    resolve("Данные получены");  
  } else {  
    reject("Произошла ошибка");  
  }  
});

Состояния Promise

Promise может быть в одном из **трёх состояний**:

1. **Pending (ожидание)** — операция ещё не завершена  
2. **Fulfilled (выполнен)** — успешно завершена, вызывается resolve  
3. **Rejected (отклонён)** — завершена с ошибкой, вызывается reject  
* **Нельзя находиться сразу в двух состояниях**  
* Как только промис завершён (fulfilled или rejected), состояние становится **финальным** и не меняется

resolve и reject

* **resolve(value)** — сообщает, что промис успешно завершён, и передаёт результат  
* **reject(reason)** — сообщает, что промис завершён с ошибкой, и передаёт причину ошибки

Пример:  
const promise \= new Promise((resolve, reject) \=\> {  
  setTimeout(() \=\> {  
    const success \= Math.random() \> 0.5;  
    success ? resolve("OK") : reject("Ошибка");  
  }, 1000);  
});

Работа с результатом промиса

Используются методы:

1. **.then()** — для обработки успешного результата (resolve)  
2. **.catch()** — для обработки ошибки (reject)  
3. **.finally()** — выполняется в любом случае

promise  
  .then((data) \=\> {  
    console.log("Результат:", data);  
    return data \+ " обработано";  
  })  
  .then((newData) \=\> {  
    console.log("Новый результат:", newData);  
  })  
  .catch((err) \=\> {  
    console.error("Ошибка:", err);  
  })  
  .finally(() \=\> {  
    console.log("Промис завершён");  
  });

* Можно строить **цепочку промисов**: результат одного .then() передаётся следующему  
* Ошибки, выброшенные в любом .then(), попадут в .catch()

**Идеальная формулировка для собеседования**

**Promise** — это объект, который представляет результат асинхронной операции в будущем. Он может находиться в состоянии **pending, fulfilled или rejected**. После перехода в fulfilled или rejected состояние становится финальным. resolve сообщает об успешном завершении промиса, reject — о завершении с ошибкой. Для работы с результатом используют .then() (успех), .catch() (ошибка) и .finally() (выполняется всегда). Цепочка .then() позволяет последовательно обрабатывать результаты нескольких асинхронных операций, улучшая читаемость и управляемость кода по сравнению с callback.

3\. Как обрабатываются ошибки внутри промисов? Что будет если поставить then после catch? Что будет если не поставить catch? Второй аргуметр у then. (Промисы: обработка ошибок)

Обработка ошибок в промисах (Promise Error Handling)

1.  Ошибки внутри промисов

Ошибки могут возникать:  
     **1.1. Явно через reject()**:  
const promise \= new Promise((resolve, reject) \=\> {  
  reject("Ошибка произошла");  
});  
     **1.2. Неявно через throw внутри executor или .then()**:  
const promise \= new Promise((resolve) \=\> {  
  throw new Error("Ошибка внутри промиса");  
});

* Любая ошибка переводит промис в состояние **rejected**  
* Можно обработать через **.catch()** или второй аргумент .then()  
2.  Обработка ошибок

2.1. Через .catch()  
promise  
  .then((data) \=\> console.log("Success:", data))  
  .catch((err) \=\> console.error("Ошибка:", err.message));

* .catch() ловит:  
  * reject()  
  * Исключения, выброшенные внутри промисов или .then()  
* После .catch() промис считается **успешно завершённым**, можно продолжать цепочку .then():

  Promise.reject("Ошибка")

    .catch(err \=\> {

      console.log(err); // "Ошибка"

      return "Исправлено";

    })

    .then(res \=\> console.log(res)); // "Исправлено"

2.2 Второй аргумент у .then()

promise.then(  
  data \=\> console.log("Success", data),  
  err \=\> console.error("Ошибка:", err)  
);

* Второй аргумент .then() **ловит reject**, но **не ловит ошибки, выброшенные внутри первого колбэка**:

  Promise.resolve()

    .then(() \=\> { throw new Error("Ошибка"); }, err \=\> console.log("Не сработает"))

    .catch(err \=\> console.log("Поймали:", err.message)); // Поймали: Ошибка

* Поэтому обычно рекомендуют использовать .catch() вместо второго аргумента .then()  
  2.3 Что будет, если не поставить .catch()  
* Ошибка в промисе **станет необработанной**  
* В браузере: вызовется unhandledrejection событие  
* В Node.js: вызовется process.on('unhandledRejection')  
* Это считается плохой практикой — ошибки могут «теряться»

  Promise.reject("Ошибка без catch");

3\. Принцип работы цепочки промисов

* Если ошибка произошла в .then(), она **передаётся вниз по цепочке**, пока не встретит .catch()  
* После .catch() промис считается **разрешённым**, цепочка продолжается с результатом .catch()

Promise.resolve()  
  .then(() \=\> { throw new Error("Ошибка 1"); })  
  .catch(err \=\> {  
    console.log(err.message); // "Ошибка 1"  
    return "Исправлено";  
  })  
  .then(res \=\> console.log(res)); // "Исправлено"

**Идеальная формулировка для собеседования**

Ошибки в промисах обрабатываются через .catch() или второй аргумент .then(). Любая ошибка (reject или throw) переводит промис в состояние **rejected**. Если .catch() отсутствует, ошибка считается необработанной и может вызвать глобальные события unhandledRejection. После .catch() промис считается успешным, и цепочка .then() продолжается. Второй аргумент у .then() ловит только reject, но не ошибки внутри колбэка .then(). Рекомендуется использовать .catch() для надёжной обработки ошибок.

4\. all, allSettled, any, race, resolve, reject (Promise API)

Promise API  
JavaScript предоставляет несколько встроенных методов для работы с множеством промисов:

1\. Promise.all(iterable)

* Принимает **массив промисов**  
* Возвращает новый промис, который:  
  * **resolved**, когда **все промисы успешно завершились**, с массивом результатов  
  * **rejected**, если хотя бы один промис завершился с ошибкой, с первым reject  
* Используется для **параллельного выполнения нескольких операций**

const p1 \= Promise.resolve(1);  
const p2 \= Promise.resolve(2);  
const p3 \= Promise.resolve(3);

Promise.all(\[p1, p2, p3\])  
  .then(results \=\> console.log(results)) // \[1, 2, 3\]  
  .catch(err \=\> console.error(err));  
2\. Promise.allSettled(iterable)

* Возвращает новый промис, который **всегда выполняется**, когда все промисы завершены, **независимо от результата**  
* Результат — массив объектов {status: 'fulfilled' | 'rejected', value?, reason?}

const p1 \= Promise.resolve(1);  
const p2 \= Promise.reject("Ошибка");  
Promise.allSettled(\[p1, p2\])  
  .then(results \=\> console.log(results));  
/\* \[  
  { status: "fulfilled", value: 1 },  
  { status: "rejected", reason: "Ошибка" }  
\]\*/

* Полезно, если нужны результаты всех операций, даже если некоторые упали

3\. Promise.race(iterable)

* Возвращает **промис, который выполнится или отклонится первым из переданных**  
* Используется для **таймаутов** или выбора самого быстрого промиса

const p1 \= new Promise(res \=\> setTimeout(() \=\> res(1), 1000));  
const p2 \= new Promise(res \=\> setTimeout(() \=\> res(2), 500));  
Promise.race(\[p1, p2\]).then(console.log); // 2  
4\. Promise.any(iterable)

* Возвращает промис, который **resolved при первом успешном промисе**  
* Если **все промисы завершились с reject**, возвращает AggregateError

const p1 \= Promise.reject("Ошибка1");  
const p2 \= Promise.resolve(2);  
const p3 \= Promise.resolve(3);  
Promise.any(\[p1, p2, p3\]).then(console.log); // 2

* Полезно, если нужен **любой успешный результат**, не обязательно первый

5\. Promise.resolve(value)

* Создаёт **уже выполненный промис** с переданным значением  
* Если аргумент уже промис, возвращает его без изменений

Promise.resolve(5).then(console.log); // 5  
6\. Promise.reject(reason)

* Создаёт **уже отклонённый промис** с указанной причиной

Promise.reject("Ошибка").catch(console.log); // "Ошибка"

**Идеальная формулировка для собеседования**

**Promise API** предоставляет методы для работы с множеством промисов.

* Promise.all ждёт завершения всех промисов, но отклоняется при любой ошибке.  
* Promise.allSettled ждёт всех промисов и возвращает массив статусов независимо от успеха или ошибки.  
* Promise.race возвращает результат **первого завершившегося промиса**.  
* Promise.any возвращает результат **первого успешно завершившегося промиса**, и выбрасывает AggregateError, если все промисы отклонены.  
* Promise.resolve создаёт уже выполненный промис, Promise.reject — отклонённый.  
  Эти методы позволяют управлять параллельными и конкурентными асинхронными операциями, обрабатывать ошибки централизованно и строить гибкие цепочки промисов.

5\. Что такое async/await? В каких функциях можно использовать await? Можно использовать await глобально? Как работает await с успешным\\отклоненым промисом? (async/await)

Что такое async/await

* **async** — ключевое слово перед функцией, которое **делает её асинхронной**  
  * Функция всегда возвращает **промис**  
  * Если функция возвращает значение — промис **fulfilled** с этим значением  
  * Если функция выбрасывает ошибку — промис **rejected** с этой ошибкой  
* **await** — ключевое слово для **ожидания выполнения промиса**  
  * Позволяет писать асинхронный код в **синхронном стиле**  
  * Работает только внутри **async-функций**

Пример:  
async function fetchData() {  
  const data \= await getDataFromAPI(); // ждем промис  
  console.log(data);  
}

* Внутри await можно использовать **любой объект, который реализует промисоподобный интерфейс (then)**

Где можно использовать await

* **Только внутри async функции**:

async function example() {  
  const result \= await Promise.resolve(42);  
  console.log(result);  
}

* **Нельзя использовать глобально** (в старых версиях JS, кроме модулей ES)  
  * В ES-модулях Node.js и современных браузерах глобальный await разрешён

Как работает await с промисом

1.  Успешный промис (fulfilled)  
   async function test() {  
     const result \= await Promise.resolve(10);  
     console.log(result); // 10  
   }  
* await **«разворачивает» промис**, возвращая значение, которое он resolved  
2.  Отклонённый промис (rejected)  
   async function test() {  
     try {  
       const result \= await Promise.reject(new Error("Ошибка\!"));  
     } catch (err) {  
       console.error(err.message); // Ошибка\!  
     }  
   }  
* Если промис rejected — await **генерирует исключение**, которое можно поймать через try/catch

Особенности и рекомендации

1. await **останавливает выполнение текущей async-функции**, но **не блокирует весь поток** (не замораживает Event Loop)  
2. Можно использовать несколько await последовательно:  
   async function getAllData() {  
     const a \= await fetchA();  
     const b \= await fetchB();  
     return a \+ b;  
   }  
* Если нужно **параллельное выполнение** — лучше использовать Promise.all:  
  const \[a, b\] \= await Promise.all(\[fetchA(), fetchB()\]);  
3. Все ошибки в async-функции можно ловить через один try/catch:  
   async function example() {  
     try {  
       const data \= await fetchData();  
       console.log(data);  
     } catch (err) {  
       console.error("Ошибка:", err);  
     }  
   }

**Идеальная формулировка для собеседования**

async/await — синтаксический сахар над промисами, позволяющий писать асинхронный код в **синхронном стиле**. async делает функцию возвращающей промис, await приостанавливает выполнение функции до завершения промиса. await работает только внутри async функций, глобальный await разрешён в ES-модулях. При успешном промисе await возвращает значение, при отклонённом — выбрасывает исключение, которое можно обработать через try/catch. Рекомендуется использовать Promise.all для параллельного выполнения нескольких промисов.

# Генераторы

1. Зачем нужны генераторы? Какие методы генераторов? Где они используются? (Генераторы)  
2. Какие отличия от обычных? (Асинхронные итераторы и генераторы)

### 1\. Зачем нужны генераторы? Какие методы генераторов? Где они используются? (Генераторы)

Что такое генератор

* Генератор — это **специальная функция**, выполнение которой можно **приостанавливать и возобновлять**.  
* Объявляется с помощью function\* и использует yield для выдачи значений.  
* При вызове генератор **не выполняется полностью**, а возвращает **итератор**.

Пример:  
function\* numbers() {  
  yield 1;  
  yield 2;  
  yield 3;  
}

const gen \= numbers();  
console.log(gen.next()); // { value: 1, done: false }  
console.log(gen.next()); // { value: 2, done: false }  
console.log(gen.next()); // { value: 3, done: false }  
console.log(gen.next()); // { value: undefined, done: true }

Зачем нужны генераторы

Генераторы позволяют:

1. **Создавать ленивые последовательности (lazy evaluation)**  
   * Не нужно заранее генерировать весь массив, можно выдавать элементы по мере необходимости  
2. **Обрабатывать большие или бесконечные потоки данных**  
3. **Реализовывать итераторы вручную**  
4. **Упрощать асинхронный код** (раньше генераторы с yield использовали для асинхронного программирования до появления async/await)

Пример ленивого диапазона:

function\* range(start, end) {  
  for (let i \= start; i \<= end; i++) {  
    yield i;  
  }  
}  
for (const n of range(1, 5)) {  
  console.log(n); // 1 2 3 4 5  
}  
Методы генераторов

Генератор возвращает **итератор**, у которого есть методы:

1. **next(value?)**  
   * Продвигает генератор до следующего yield  
   * Можно передавать значение, которое возвращается внутри генератора  
2. **throw(error)**  
   * Позволяет **вбросить исключение внутрь генератора** в месте последнего yield  
3. **return(value?)**  
   * Преждевременно завершает генератор  
   * Возвращает объект { value, done: true }

Пример:  
function\* gen() {  
  try {  
    yield 1;  
    yield 2;  
  } catch (e) {  
    console.log("Поймана ошибка:", e);  
  }  
}  
const g \= gen();  
console.log(g.next());         // { value: 1, done: false }  
console.log(g.throw("Ошибка")); // Поймана ошибка: Ошибка  
console.log(g.next());         // { value: undefined, done: true }

Где используются генераторы

1. **Ленивые коллекции и последовательности**  
   * Генерация диапазонов, потоков данных, бесконечных последовательностей  
2. **Итераторы и кастомные объекты с Symbol.iterator**  
3. **Асинхронное программирование** (раньше, до async/await)  
4. **Обработка больших данных**, когда не хочется хранить всё в памяти

Пример бесконечного генератора:  
function\* idGenerator() {  
  let id \= 1;  
  while (true) {    yield id++;  }  
}  
const ids \= idGenerator();  
console.log(ids.next().value); // 1  
console.log(ids.next().value); // 2

* Здесь память не расходуется на хранение всех значений, генератор выдаёт их по требованию.

**Идеальная формулировка для собеседования**

Генератор — это функция, выполнение которой можно приостанавливать и возобновлять с помощью yield. Возвращает итератор с методами next(), throw() и return(). Генераторы полезны для ленивой генерации последовательностей, создания бесконечных потоков данных, реализации кастомных итераторов и упрощения асинхронного кода. Они позволяют экономить память и управлять вычислениями по мере необходимости.

### 2\. Какие отличия от обычных? (Асинхронные итераторы и генераторы)

### Асинхронные генераторы и итераторы (Async Generators / Async Iterators)

Отличие от обычных генераторов

| Характеристика | Обычные генераторы (function\*) | Асинхронные генераторы (async function\*) |
| ----- | ----- | ----- |
| Тип возвращаемого значения | Синхронный итератор (Iterator) | Асинхронный итератор (AsyncIterator) |
| Метод next() | Возвращает { value, done } | Возвращает промис { value, done } |
| Поддержка await внутри | Нет | Да — можно await асинхронные операции |
| Использование в цикле | for...of | for await...of |
| Применение | Синхронные последовательности | Асинхронные потоки данных (API, таймеры, БД) |

Синтаксис

async function\* asyncGen() {  
  const urls \= \["url1", "url2"\];  
  for (const url of urls) {  
    const data \= await fetch(url).then(res \=\> res.json()); // await внутри генератора  
    yield data;  
  }  
}  
(async () \=\> {  
  for await (const item of asyncGen()) {  
    console.log(item);  
  }  
})();

* async function\* — ключевое слово для **асинхронного генератора**  
* yield — выдаёт значения **асинхронно**, возвращая **промис**  
* Цикл for await...of **ждёт завершения промиса**, прежде чем перейти к следующему значению

Применение

1. **Постепенная обработка больших потоков данных с асинхронными операциями**  
   * API-запросы, чтение файлов, WebSocket-сообщения  
2. **Комбинация с асинхронными итераторами** для ленивой загрузки  
3. **Экономия памяти**: не нужно хранить весь массив результатов

Пример с API:  
async function\* fetchPages(pages) {  
  for (let i \= 1; i \<= pages; i++) {  
    const data \= await fetch(\`https://api.example.com/page/${i}\`).then(r \=\> r.json());  
    yield data;  
  }  
}  
(async () \=\> {  
  for await (const page of fetchPages(5)) {  
    console.log(page);  
  }  
})();

Методы асинхронных генераторов

* **next()** → возвращает **промис** { value, done }  
* **return(value?)** → завершает генератор, возвращая промис  
* **throw(error)** → выбрасывает ошибку внутрь генератора, возвращает промис

const ag \= asyncGen();  
ag.next().then(console.log); // { value: {...}, done: false }

Отличие в обработке ошибок

* Ошибки внутри асинхронного генератора **оборачиваются в rejected промис**, их можно ловить через .catch() или try/catch внутри for await...of

(async () \=\> {  
  try {  
    for await (const item of asyncGen()) {  
      console.log(item);  
    }  
  } catch (err) {  
    console.error("Ошибка генератора:", err);  
  }  
})();

Идеальная формулировка для собеседования

Асинхронный генератор (async function\*) — это генератор, который может выполнять асинхронные операции внутри и выдавать значения через yield в виде промисов. В отличие от обычных генераторов, методы next(), return(), throw() возвращают **промисы**, а для итерации используется for await...of. Асинхронные генераторы применяются для ленивой загрузки данных, обработки больших или бесконечных потоков с асинхронными операциями, экономя память и улучшая читаемость кода.

# 

# Общее (память\\событийный цикл)

1. Как JavaScript понимает, что пора очищать память? Принцип достижимости (Сборка мусора)  
2. В чем отличие от обычных Map и Set ? Для чего нужны ? (WeakMap и WeakSet)  
3. Что такое микрозадачи? Как работает очередь микрозадач? (Микрозадачи)  
4. В каком порядке выполняются задачи? Какие отличия микрозадач от макрозадач? (Событийный цикл)

### 1\. Как JavaScript понимает, что пора очищать память? Принцип достижимости (Сборка мусора)

Как JavaScript понимает, что пора очищать память

JavaScript использует **автоматическую сборку мусора (Garbage Collection)**.  
Разработчик **не управляет памятью вручную** — движок (V8, SpiderMonkey и др.) сам решает, когда объект можно удалить.  
Основной принцип — **достижимость (reachability)**.

Принцип достижимости (Reachability)

**Значение считается достижимым, если к нему можно получить доступ из “корней” (roots).**  
Корни (roots):

* Глобальные переменные  
* Локальные переменные текущих функций  
* Параметры функций  
* Переменные, находящиеся в замыканиях  
* Объекты, на которые есть ссылки из других достижимых объектов

Пример:

let user \= {  
  name: "Alex"  
};

* user достижим → объект в памяти

user \= null;

* Ссылка удалена  
* Объект "Alex" **становится недостижимым**  
* Сборщик мусора может удалить его

Как работает сборщик мусора (упрощённо)

Алгоритм Mark-and-Sweep (используется в современных движках):

1. Движок помечает все **достижимые объекты**  
2. Все непомеченные считаются **мусором**  
3. Память освобождается

Корни → достижимые объекты → помечены  
Недостижимые → удалены

Связь с событиями и асинхронностью

Объекты **не удаляются**, пока:

* на них есть ссылка  
* они участвуют в замыкании  
* на них ссылается callback таймера / события

Пример утечки памяти:

let hugeData \= new Array(1e6);  
setTimeout(() \=\> {  
  console.log(hugeData);  
}, 10000);

* hugeData **не будет удалён**, пока таймер не выполнится  
* потому что callback удерживает ссылку

Частые причины утечек памяти

1. **Глобальные переменные**

data \= { big: true }; // без let/const

2. **Замыкания**  
   function createHandler() {  
     const big \= new Array(1e6);  
     return () \=\> console.log(big);

}

3. **Неочищенные таймеры и подписки**

setInterval(() \=\> {}, 1000); // без clearInterval

4. **DOM-ссылки**

let el \= document.getElementById("app");  
// если элемент удалён из DOM, но ссылка осталась → утечка

Что НЕ удаляется сборщиком мусора

* Объекты, на которые есть хотя бы **одна активная ссылка**  
* Данные, используемые в текущем стеке выполнения  
* Данные, захваченные замыканиями

**Идеальная формулировка для собеседования**

JavaScript использует автоматическую сборку мусора на основе принципа достижимости. Значение считается достижимым, если к нему можно получить доступ из корней — глобальных переменных, локальных переменных функций или замыканий. Современные движки используют алгоритм mark-and-sweep: сначала помечают все достижимые объекты, затем удаляют недостижимые. Объекты не очищаются, пока на них есть ссылки, например из замыканий, таймеров или обработчиков событий, что может приводить к утечкам памяти.

### 2\. В чем отличие от обычных Map и Set ? Для чего нужны ? (WeakMap и WeakSet)

Что такое WeakMap и WeakSet

**WeakMap** и **WeakSet** — это специальные коллекции, которые хранят **слабые ссылки** на объекты.

* Они **не мешают сборщику мусора** удалять объекты  
* Используются для хранения **вспомогательных, “привязанных” к объекту данных**

Отличие от обычных Map и Set

1 Map vs WeakMap

| Характеристика | Map | WeakMap |
| ----- | ----- | ----- |
| Тип ключей | Любые (примитивы и объекты) | **Только объекты** |
| Удерживает объект в памяти | Да | **Нет (слабая ссылка)** |
| Итерация (keys, values) | Да | ❌ Нет |
| size | Есть | ❌ Нет |
| Использование GC | Ключи мешают GC | **GC может удалить ключи** |

let obj \= {};  
const map \= new Map();  
map.set(obj, "data");

obj \= null;  
// объект НЕ удалится, пока есть map

let obj \= {};  
const wmap \= new WeakMap();  
wmap.set(obj, "data");

obj \= null;  
// объект может быть удалён сборщиком мусора

2 Set vs WeakSet

| Характеристика | Set | WeakSet |
| ----- | ----- | ----- |
| Тип значений | Любые | **Только объекты** |
| Итерация | Да | ❌ Нет |
| Хранит сильную ссылку | Да | **Слабая ссылка** |

Почему WeakMap / WeakSet нельзя перебирать

* Ключ или значение **может быть удалено GC в любой момент**  
* Итерация была бы **недетерминированной**  
* Поэтому:  
  * нет forEach  
  * нет keys(), values()  
  * нет size

Для чего нужны WeakMap и WeakSet

1 Хранение приватных данных

const privateData \= new WeakMap();

class User {  
  constructor(name, password) {  
    privateData.set(this, { password });  
  }

  checkPassword(pass) {  
    return privateData.get(this).password \=== pass;  
  }  
}

* Данные автоматически удалятся, когда объект уничтожен

2 Кеширование, связанное с объектом

const cache \= new WeakMap();

function process(obj) {  
  if (cache.has(obj)) return cache.get(obj);  
  const result \= heavyCalculation(obj);  
  cache.set(obj, result);  
  return result;  
}

3 Отметка объектов (WeakSet)

const visited \= new WeakSet();

function visit(obj) {  
  if (visited.has(obj)) return;  
  visited.add(obj);  
}

Когда НЕ стоит использовать

* Когда нужно:  
  * перебирать элементы  
  * хранить примитивы  
  * знать количество элементов  
* Для обычных коллекций → **Map / Set**

**Идеальная формулировка для собеседования**

WeakMap и WeakSet — это коллекции со слабыми ссылками на объекты. В отличие от Map и Set, они не препятствуют сборке мусора и автоматически очищаются, когда объект становится недостижимым. WeakMap хранит пары ключ–значение, где ключом может быть только объект, WeakSet хранит только объекты. Эти структуры используются для приватных данных, кешей и вспомогательных меток, привязанных к жизненному циклу объектов.

### 3\. Что такое микрозадачи? Как работает очередь микрозадач? (Микрозадачи)

Что такое микрозадачи (Microtasks)

**Микрозадачи** — это задачи с **высоким приоритетом**, которые выполняются:

* **сразу после завершения текущего синхронного кода**  
* **до рендера**  
* **до обработки макрозадач**

Основная цель — **гарантированно выполнить критичный асинхронный код как можно раньше**.  
Очередь микрозадач (Microtask Queue)

В JavaScript существует **отдельная очередь микрозадач**, отличная от очереди макрозадач.  
Алгоритм работы:

1. Выполняется текущий синхронный код (call stack)  
2. **Полностью очищается очередь микрозадач**  
3. Происходит рендер (если требуется)  
4. Берётся **одна** макрозадача  
5. Повтор цикла

Ключевой момент:  
**очередь микрозадач очищается полностью за один тик event loop**

Источники микрозадач

К микрозадачам относятся:

* Promise.then / catch / finally  
* queueMicrotask()  
* MutationObserver  
* await (внутри async-функций)

Promise.resolve().then(() \=\> console.log('microtask'));

Отличие от макрозадач

| Критерий | Микрозадачи | Макрозадачи |
| ----- | ----- | ----- |
| Очередь | Microtask Queue | Task Queue |
| Приоритет | Высокий | Ниже |
| Выполнение | После sync-кода, **до рендера** | После микрозадач |
| Примеры | Promise.then | setTimeout, setInterval, events |

Пример порядка выполнения

console.log(1);  
setTimeout(() \=\> console.log(2), 0);  
Promise.resolve().then(() \=\> console.log(3));  
console.log(4);

**Результат:**  
1  
4  
3  
2

Почему:

* 1, 4 — синхронно  
* 3 — микрозадача  
* 2 — макрозадача

Микрозадачи и async / await

async function test() {  
  console.log(1);  
  await Promise.resolve();  
  console.log(2);  
}  
console.log(3);  
test();  
console.log(4);

**Результат:**  
3  
1  
4  
2

Пояснение:

* await ставит продолжение функции в очередь микрозадач

Важный нюанс (часто спрашивают)

Может ли микрозадача заблокировать рендер?  
**Да.**  
function loop() {  
  Promise.resolve().then(loop);  
}  
loop();

* Очередь микрозадач **никогда не опустеет**  
* Браузер не сможет выполнить рендер  
* UI будет зависшим

queueMicrotask

queueMicrotask(() \=\> {  
  console.log('micro');  
});

* Явное добавление микрозадачи  
* Без создания Promise  
* Используется внутри библиотек

**Идеальный ответ на собеседовании (кратко)**

Микрозадачи — это асинхронные задачи с более высоким приоритетом, чем макрозадачи. После завершения текущего синхронного кода JavaScript полностью очищает очередь микрозадач, и только потом берёт следующую макрозадачу и выполняет рендер. К микрозадачам относятся Promise.then, async/await, queueMicrotask и MutationObserver.

### 4\. В каком порядке выполняются задачи? Какие отличия микрозадач от макрозадач? (Событийный цикл)

Общий порядок выполнения задач в Event Loop  
JavaScript выполняет код в **одном потоке**, используя **событийный цикл (Event Loop)**.  
Один тик Event Loop выглядит так:

1. **Call Stack** — выполняется весь синхронный код  
2. **Microtask Queue** — полностью очищается очередь микрозадач  
3. **Render** — браузер выполняет перерисовку (если требуется)  
4. **Macrotask Queue** — берётся **одна** макрозадача  
5. Повтор цикла

Ключевой момент:  
**Микрозадачи выполняются раньше макрозадач и очищаются полностью**

Микрозадачи (Microtasks)

Что это  
Микрозадачи — это задачи с **высшим приоритетом**, предназначенные для немедленного продолжения асинхронной логики.  
Источники микрозадач

* Promise.then / catch / finally  
* async / await (после await)  
* queueMicrotask  
* MutationObserver

Характеристики

* Выполняются **сразу после синхронного кода**  
* Выполняются **до рендера**  
* Очередь очищается **полностью за один тик**  
* Могут блокировать UI при зацикливании

Макрозадачи (Macrotasks / Tasks)

Что это  
Макрозадачи — это задачи общего назначения, которые выполняются **по одной за тик**.  
Источники макрозадач

* setTimeout  
* setInterval  
* setImmediate (Node.js)  
* DOM-события (click, scroll)  
* I/O операции  
* requestAnimationFrame (особый случай — перед рендером)

Характеристики

* Выполняются **после микрозадач**  
* Между задачами браузер может выполнять рендер  
* Не блокируют интерфейс так агрессивно

Ключевые отличия микрозадач и макрозадач

| Критерий | Микрозадачи | Макрозадачи |
| ----- | ----- | ----- |
| Очередь | Microtask Queue | Task Queue |
| Приоритет | Высокий | Ниже |
| Очистка очереди | Полностью | По одной |
| Выполнение | До рендера | После рендера |
| Примеры | Promise.then | setTimeout, events |

Классический пример

console.log(1);  
setTimeout(() \=\> console.log(2), 0);  
Promise.resolve().then(() \=\> console.log(3));  
console.log(4);

**Результат:**  
1  
4  
3  
2

Пример с async / await

async function f() {  
  console.log(1);  
  await null;  
  console.log(2);  
}  
console.log(3);  
f();  
console.log(4);

**Результат:**  
3  
1  
4  
2

await ставит продолжение функции в очередь микрозадач.

Важный нюанс (часто спрашивают)

Почему setTimeout(fn, 0\) не выполняется сразу?

* 0 — это **минимальная задержка**  
* Колбэк попадает в очередь макрозадач  
* Он выполнится **после синхронного кода и микрозадач**

Может ли Promise выполниться раньше события?

**Да.**  
button.addEventListener('click', () \=\> {  
  Promise.resolve().then(() \=\> console.log('promise'));  
  console.log('handler');  
});

Результат:

handler  
promise

**Итоговый ответ на собеседовании (коротко)**

JavaScript сначала выполняет весь синхронный код, затем полностью очищает очередь микрозадач. После этого браузер может выполнить рендер, и только затем берётся одна макрозадача. Микрозадачи имеют более высокий приоритет и используются для немедленного продолжения асинхронного кода, тогда как макрозадачи выполняются по одной за цикл.

# Общее (доп.)

1. Как импортировать всё из модуля? Почему так делать не правильно? Как импортировать и экспортировать с другим названием? Что такое экспорт по умолчанию? Чем отличается и какие проблемы есть? (Экспорт и импорт)  
2. Как вывести текст в консоль? Как вывести предупреждение, ошибку? Как отобразить данные в виде таблицы? Как с помощью консоли засечь таймер ? (Console)  
3. Работа с модулем URL. Работа с модулем URLSearchParams. Какие методы для работы с модулями ? Для чего нужны ? (URL API)  
4. Как работает ? File и FileReader Middle Какие методы предоставляет и зачем? Как работать с датой , числами , строками ? Какие методы могут работать с параметрами как в Intl? (Intl)

### 1\. Как импортировать всё из модуля? Почему так делать не правильно? Как импортировать и экспортировать с другим названием? Что такое экспорт по умолчанию? Чем отличается и какие проблемы есть? (Экспорт и импорт)

Как импортировать всё из модуля

import \* as utils from './utils.js';

Использование:  
utils.sum();  
utils.formatDate();

Что происходит

* Все **именованные экспорты** собираются в **один объект**  
* default экспорт доступен как utils.default

Почему import \* as — плохая практика

Основные проблемы

1\. Потеря явных зависимостей  
import \* as api from './api';

Невозможно быстро понять:

* какие функции реально используются  
* что именно влияет на файл

Плохо для:

* поддержки  
* code review  
* анализа зависимостей

2\. Tree Shaking работает хуже

Бандлеру сложнее удалить неиспользуемый код, потому что:  
api.someDynamicCall()

может использовать что угодно внутри объекта.

3\. Конфликты имён и неявный API

* Увеличивается поверхность API  
* Легко использовать лишнее  
* Трудно контролировать изменения модуля

4\. Производительность и масштабируемость

* При росте модуля подход становится неуправляемым  
* Нарушает принцип явных зависимостей

Когда допустимо

* Генераторы  
* Утилитарные namespace-модули  
* Тесты  
* Миграционный код

Импорт и экспорт с другим названием (алиасы)

Экспорт с алиасом  
export { fetchData as loadData };  
Импорт с алиасом  
import { fetchData as loadData } from './api.js';  
Зачем нужно

* Избежать конфликтов имён  
* Повысить читаемость  
* Подстроить API под контекст файла

Что такое экспорт по умолчанию (default export)

export default function sum(a, b) {  
  return a \+ b;  
}

Импорт:  
import sum from './sum.js';

Ключевая особенность

* **Имя не фиксировано**  
* Импортёр сам выбирает название

Отличие default export от именованных

| Критерий | Named export | Default export |
| ----- | ----- | ----- |
| Количество | Много | Только один |
| Имя | Обязательно | Произвольное |
| Tree shaking | Отличный | Хуже |
| Автодополнение | Лучше | Хуже |
| Рефакторинг | Безопаснее | Опаснее |

Основные проблемы default export

1\. Потеря единого имени

import a from './service';  
import b from './service';

* Один и тот же модуль под разными именами  
* Сложнее искать использование

2\. Сложнее рефакторить

* Переименование функции не отражается в импортах  
* IDE хуже отслеживает связи

3\. Плохая масштабируемость

При добавлении второго экспорта:  
export default class User {}  
export function validate() {}

Импорт становится смешанным и неочевидным:  
import User, { validate } from './user';

Когда default export оправдан

* React-компоненты (один компонент — один файл)  
* Entry-point модули  
* Обёртки / фасады  
* Конфигурации

Переэкспорт (re-export)

export { fetchData } from './api.js';  
export \* from './utils.js';

Или с алиасом:  
export { fetchData as loadData } from './api.js';

Используется для:

* barrel-файлов (index.js)  
* публичного API пакета

Частая ошибка на собеседовании

❌ Так нельзя:  
export default const a \= 1;

✔ Правильно:  
const a \= 1;  
export default a;

**Краткий ответ для интервью**

import \* as собирает все именованные экспорты в объект, но ухудшает читаемость, tree shaking и контроль зависимостей. Алиасы позволяют избегать конфликтов имён. Default export — это один экспорт без фиксированного имени, удобный для простых модулей, но он усложняет масштабирование, рефакторинг и анализ зависимостей.

### 2\. Как вывести текст в консоль? Как вывести предупреждение, ошибку? Как отобразить данные в виде таблицы? Как с помощью консоли засечь таймер ? (Console)

Как вывести текст в консоль

console.log('Hello');

* Основной метод логирования  
* Может принимать несколько аргументов  
* Поддерживает форматирование

console.log('User:', user);

Как вывести предупреждение  
console.warn('Deprecated API');

* Отображается как предупреждение  
* Используется для потенциальных проблем  
* Не прерывает выполнение кода

Как вывести ошибку  
console.error('Something went wrong');

* Логирует ошибку  
* В DevTools подсвечивается красным  
* Стек вызовов выводится автоматически для Error

console.error(new Error('Fail'));

Как отобразить данные в виде таблицы

console.table(users);

* Удобно для массивов объектов  
* Ключи объекта → колонки  
* Значения → строки

console.table(users, \['id', 'name'\]);  
(вывод только выбранных полей)

Как засечь время выполнения кода

Через console.time / console.timeEnd  
console.time('load');  
// код  
console.timeEnd('load');

* Метка должна совпадать  
* Выводит время выполнения

Дополнительно: промежуточные замеры

console.time('process');  
step1();  
console.timeLog('process');  
step2();  
console.timeEnd('process');

Полезные методы консоли (часто спрашивают)

console.clear();   // очистить консоль  
console.dir(obj); // показать структуру объекта  
console.group('Title');  
console.groupEnd();  
console.assert(condition, 'Message');

**Краткий ответ для собеседования**

Для логирования используется console.log, для предупреждений — console.warn, для ошибок — console.error. Для визуализации структурированных данных есть console.table. Замер времени выполнения осуществляется через console.time и console.timeEnd, что удобно для профилирования кода.

### 3\. Работа с модулем URL. Работа с модулем URLSearchParams. Какие методы для работы с модулями ? Для чего нужны ? (URL API)

URL API (URL, URLSearchParams)  
Для чего нужен URL API

URL API предоставляет **стандартизированный способ**:

* парсить URL  
* безопасно работать с его частями  
* изменять query-параметры  
* корректно кодировать/декодировать данные

Работает одинаково в **браузере и Node.js**.

Класс URL  
Создание URL  
const url \= new URL('https://example.com:8080/path?x=1\#hash');  
или с базовым URL:  
new URL('/users', 'https://api.site.com');

Основные свойства URL

url.href      // полный URL  
url.protocol  // 'https:'  
url.host      // 'example.com:8080'  
url.hostname  // 'example.com'  
url.port      // '8080'  
url.pathname  // '/path'  
url.search    // '?x=1'  
url.hash      // '\#hash'  
url.origin    // 'https://example.com:8080'

Изменение URL

url.pathname \= '/profile';  
url.hash \= '\#top';

Все изменения **автоматически отражаются в href**.

URLSearchParams  
URLSearchParams предназначен для **работы с query-параметрами** (?key=value).  
const params \= new URLSearchParams('?page=2\&sort=asc');  
Или из URL:  
url.searchParams

Основные методы URLSearchParams  
Получение значений  
params.get('page');        // '2'  
params.getAll('filter');  // \['a', 'b'\]  
params.has('sort');       // true

Установка и изменение  
params.set('page', 3);  
params.append('filter', 'new');

Удаление  
params.delete('sort');

Итерация  
params.forEach((value, key) \=\> {});  
params.keys();  
params.values();  
params.entries();  
Поддерживает for...of.

Преобразование в строку  
params.toString(); // 'page=3\&filter=new'

Связь URL и URLSearchParams  
url.searchParams.set('q', 'js');  
url.toString();  
Изменения searchParams **сразу обновляют URL**.

Кодирование  
URL API **автоматически кодирует** спецсимволы:  
params.set('q', 'hello world');  
→ q=hello+world

Когда использовать URL API

* Работа с query-параметрами  
* Формирование API-запросов  
* Избежание ручного парсинга строк  
* Корректное кодирование данных

Чего не стоит делать

❌ Ручной парсинг строк:

location.search.split('&')

**Краткий ответ для собеседования**

URL API используется для парсинга и безопасного изменения URL. Класс URL позволяет работать со всеми частями адреса, а URLSearchParams — удобно управлять query-параметрами. API автоматически кодирует значения, поддерживает итерацию и работает одинаково в браузере и Node.js.

### 

### 4\. Как работает ? File и FileReader Middle Какие методы предоставляет и зачем? Как работать с датой , числами , строками ? Какие методы могут работать с параметрами как в Intl? (Intl)

File и FileReader / Intl API  
File и FileReader

Что такое File  
File — это объект, представляющий **файл на стороне клиента**.  
Является наследником Blob.

Используется при:

* загрузке файлов через \<input type="file"\>  
* drag & drop  
* работе с локальными файлами в браузере

input.files\[0\] instanceof File // true

Основные свойства File

file.name      // имя файла  
file.size      // размер в байтах  
file.type      // MIME-тип  
file.lastModified

FileReader

FileReader позволяет **асинхронно читать содержимое файла** в браузере.  
Работает **только в браузере**.

Основные методы FileReader  
reader.readAsText(file)       // текст  
reader.readAsDataURL(file)    // base64 (img, preview)  
reader.readAsArrayBuffer(file)  
reader.readAsBinaryString()  // устаревший

События FileReader  
reader.onload  
reader.onerror  
reader.onprogress  
reader.onloadend

Чтение **асинхронное** → всегда через события или Promise-обёртку.

Пример

const reader \= new FileReader();  
reader.onload \= () \=\> console.log(reader.result);  
reader.readAsText(file);

Зачем использовать File / FileReader

* предпросмотр изображений  
* валидация файлов до отправки  
* чтение CSV / JSON  
* загрузка документов без сервера

Intl API  
Что такое Intl

Intl — это **API интернационализации**, которое позволяет:

* форматировать даты  
* числа  
* валюты  
* строки  
  в зависимости от **локали и правил страны**.

Работает в браузере и Node.js.

Intl для дат

Intl.DateTimeFormat  
new Intl.DateTimeFormat('ru-RU', {  
  dateStyle: 'full',  
  timeStyle: 'short'  
}).format(new Date());

Intl для чисел

Intl.NumberFormat  
new Intl.NumberFormat('de-DE').format(123456.78);  
// 123.456,78

Валюта

new Intl.NumberFormat('en-US', {  
  style: 'currency',  
  currency: 'USD'  
}).format(1000);

Intl для строк

Intl.Collator  
Корректное сравнение строк:  
new Intl.Collator('ru').compare('ё', 'е');  
Используется для **правильной сортировки**.

Методы Intl с параметрами

| API | Для чего |
| ----- | ----- |
| Intl.DateTimeFormat | даты и время |
| Intl.NumberFormat | числа, валюта |
| Intl.Collator | сравнение строк |
| Intl.PluralRules | множественные формы |
| Intl.RelativeTimeFormat | "2 дня назад" |
| Intl.ListFormat | списки |
| Intl.DisplayNames | названия стран, языков |

Пример RelativeTimeFormat

new Intl.RelativeTimeFormat('ru').format(-1, 'day');  
// "вчера"

Почему не писать вручную

* разные форматы дат  
* разные правила валют  
* языковые нюансы  
* ошибки локализации

**Краткий ответ для собеседования**

File представляет файл на стороне клиента, а FileReader позволяет асинхронно читать его содержимое. Intl API используется для форматирования дат, чисел и строк с учётом локали. Оно предоставляет классы DateTimeFormat, NumberFormat, Collator и другие, что позволяет корректно работать с интернационализацией без ручной логики.

# 

# Запросы и хранение данных

1. Для чего используется? Какие могут быть методы запросов? Какие могут быть статусы ответа? Возможные форматы body и ответа. Как работать с заголовками ? Как понять в какой тип парсить содержимое ответа ? (Fetch)  
2. Как устроен ? Для чего нужен? (CORS)   
3. Почему файлы отправляются этим форматом? Предоставляемые методы.(FormData)  
4. Как прервать зарос? Прерывание запроса Junior+ Как работать с localStorage, sessionStorage ? В чем между ними разница?( localStorage, sessionStorage)  
5. Как работать с куками ? Как удалить куку? (Куки)

### 1\. Для чего используется? Какие могут быть методы запросов? Какие могут быть статусы ответа? Возможные форматы body и ответа. Как работать с заголовками ? Как понять в какой тип парсить содержимое ответа ? (Fetch)

Fetch API  
Для чего используется fetch

fetch — это **стандартный Web API** для выполнения **HTTP-запросов** из браузера (и Node.js).  
Используется для:

* получения данных с сервера  
* отправки форм  
* работы с REST / GraphQL API  
* загрузки и отправки файлов

Возвращает **Promise**, который резолвится в объект Response.

Методы HTTP-запросов  
Наиболее используемые:

| Метод | Назначение |
| ----- | ----- |
| GET | Получение данных |
| POST | Создание ресурса |
| PUT | Полное обновление |
| PATCH | Частичное обновление |
| DELETE | Удаление |
| HEAD | Заголовки без тела |
| OPTIONS | Проверка возможностей (CORS) |

Пример:  
fetch('/api/users', { method: 'POST' });  
Статусы ответа (HTTP Status)

Основные группы:

| Диапазон | Значение |
| ----- | ----- |
| 2xx | Успех |
| 3xx | Редиректы |
| 4xx | Ошибка клиента |
| 5xx | Ошибка сервера |

Часто спрашиваемые:

* 200 OK  
* 201 Created  
* 204 No Content  
* 400 Bad Request  
* 401 Unauthorized  
* 403 Forbidden  
* 404 Not Found  
* 500 Internal Server Error

⚠️ **fetch не кидает ошибку на 4xx/5xx**, нужно проверять вручную:

if (\!response.ok) throw new Error(response.status);

Форматы body запроса

Основные варианты:

| Тип | Как передать |
| ----- | ----- |
| JSON | JSON.stringify() |
| FormData | new FormData() |
| Text | строка |
| Blob / File | файлы |
| URLSearchParams | query-подобный формат |

Пример JSON:

fetch('/api', {  
  method: 'POST',  
  headers: {  
    'Content-Type': 'application/json'  
  },  
  body: JSON.stringify({ name: 'John' })  
});

Форматы ответа

Обрабатываются через методы Response:  
response.json()  
response.text()  
response.blob()  
response.arrayBuffer()  
response.formData()

Как понять, в какой тип парсить ответ  
По заголовку **Content-Type**:  
const type \= response.headers.get('content-type');  
if (type.includes('application/json')) {  
  return response.json();  
}

Сервер **обязан** указать формат ответа.

Работа с заголовками  
Передача заголовков  
headers: {  
  'Authorization': 'Bearer token',  
  'Accept': 'application/json'  
}

Чтение заголовков ответа

response.headers.get('Content-Type');  
Headers — итерируемый объект.

Response объект  
Основные свойства:  
response.ok        // true если 2xx  
response.status    // код статуса  
response.statusText  
response.url

⚠️ Тело можно прочитать **только один раз**.

Обработка ошибок (корректно)

fetch(url)  
  .then(res \=\> {  
    if (\!res.ok) throw new Error(res.status);  
    return res.json();  
  })  
  .catch(err \=\> console.error(err));  
**Краткий ответ для собеседования**

Fetch используется для выполнения HTTP-запросов. Он поддерживает все основные методы, возвращает Promise с объектом Response и не выбрасывает ошибку при 4xx/5xx — это нужно проверять вручную. Формат тела запроса и ответа зависит от Content-Type. Для работы используются заголовки, а парсинг ответа выполняется методами json, text, blob и другими.

### 2\. Как устроен ? Для чего нужен? (CORS) 

CORS (Cross-Origin Resource Sharing)  
Для чего нужен CORS

**CORS — это механизм безопасности браузера**, который ограничивает **HTTP-запросы между разными origin**.  
Origin \=scheme (protocol) \+ host \+ port  
Пример разных origin:

* https://site.com  
* http://site.com  
* https://api.site.com  
* https://site.com:3000

Без CORS браузер **блокирует доступ к ответу**, даже если сервер его отправил.

Зачем он нужен

* Защита от **XSS и CSRF**  
* Предотвращение чтения данных с чужих сайтов  
* Контроль того, **кто может обращаться к API**

⚠️ **CORS — это защита браузера, не сервера**

Как работает CORS

1. Браузер отправляет запрос  
2. Сервер отвечает **с CORS-заголовками**  
3. Браузер проверяет заголовки  
4. Если правила не совпадают — **ответ блокируется**

Основные CORS-заголовки  
**Access-Control-Allow-Origin**  
Access-Control-Allow-Origin: https://example.com  
или  
Access-Control-Allow-Origin: \*

**Access-Control-Allow-Methods**  
Access-Control-Allow-Methods: GET, POST, PUT

**Access-Control-Allow-Headers**

Access-Control-Allow-Headers: Content-Type, Authorization

**Access-Control-Allow-Credentials**

Access-Control-Allow-Credentials: true

Позволяет отправлять:

* cookies  
* authorization headers

⚠️ Нельзя использовать \* с credentials

Простые и сложные запросы

Simple request  
Без preflight:

* методы: GET, POST, HEAD  
* стандартные заголовки  
* Content-Type:  
  text/plain, application/x-www-form-urlencoded, multipart/form-data

Preflight (OPTIONS)  
Если запрос **не простой**, браузер:

1. Отправляет OPTIONS  
2. Проверяет разрешения  
3. Только потом отправляет основной запрос

Что такое preflight

OPTIONS /api HTTP/1.1  
Origin: https://site.com  
Access-Control-Request-Method: POST  
Сервер отвечает, разрешён ли запрос.

Типичная ошибка  
Сервер вернул данные, но браузер их не отдаёт JS  
Это **CORS**, а не ошибка сервера.

Как исправляют CORS  
На сервере:

* добавить нужные заголовки  
* настроить proxy  
* использовать middleware (cors в Express)

На фронте:

* прокси через dev-сервер  
* same-origin запросы  
* избегать credentials без нужды

Частый вопрос: почему Postman работает?  
Postman **не браузер** → CORS на него не действует.

**Краткий ответ для собеседования**

CORS — это браузерный механизм безопасности, который ограничивает кросс-доменные HTTP-запросы. Он работает через специальные заголовки сервера и может требовать preflight-запрос OPTIONS. CORS проверяется браузером, а не сервером, и используется для защиты данных.

### 3\. Почему файлы отправляются этим форматом? Предоставляемые методы.(FormData)

FormData  
Почему файлы отправляются через FormData  
Файлы отправляются в формате **multipart/form-data**, потому что:

1. **Файл — бинарные данные**, их нельзя корректно передать в JSON  
2. multipart/form-data позволяет:  
   * передавать **файлы и обычные поля вместе**  
   * не кодировать файл в base64 (экономия трафика)  
   * корректно передавать **большие объёмы данных**  
3. Это **стандарт HTML-форм**, поддерживаемый всеми серверами

При использовании FormData браузер:

* сам формирует границы (boundary)  
* сам выставляет Content-Type

⚠️ **Нельзя вручную задавать Content-Type** при FormData

Для чего используется FormData

* отправка файлов  
* отправка форм с файлами  
* multipart-запросы  
* загрузка изображений, документов, видео

Как создать FormData  
const formData \= new FormData();

Из формы:  
const formData \= new FormData(formElement);

Основные методы FormData  
append(name, value, filename?)  
Добавляет значение (не затирает существующее)  
formData.append('file', file);

set(name, value, filename?)  
Устанавливает или перезаписывает значение  
formData.set('name', 'John');

get(name)  
Получить первое значение  
formData.get('file');

getAll(name)  
Получить все значения по ключу  
formData.getAll('images');

has(name)  
Проверка существования поля  
formData.has('file');

delete(name)  
Удалить поле  
formData.delete('file');  
Итерация по FormData

for (const \[key, value\] of formData.entries()) {  
  console.log(key, value);  
}

Методы:

* entries()  
* keys()  
* values()

Отправка через fetch

fetch('/upload', {  
  method: 'POST',  
  body: formData  
});

Почему не JSON для файлов

| JSON | FormData |
| ----- | ----- |
| Нет бинарных данных | Поддерживает бинарные |
| Нужно base64 | Отправка напрямую |
| Увеличивает размер | Оптимальный размер |
| Ручной Content-Type | Автоматический |

**Краткий ответ для собеседования**

Файлы отправляются через FormData, потому что используется формат multipart/form-data, который поддерживает бинарные данные и передачу файлов без кодирования. FormData предоставляет методы append, set, get, delete и позволяет отправлять файлы и поля формы вместе, при этом браузер сам формирует заголовки.

### 4\. Как прервать зарос? Прерывание запроса Junior+ Как работать с localStorage, sessionStorage ? В чем между ними разница?( localStorage, sessionStorage)

Прерывание запроса (AbortController)  
Как прервать запрос

Для прерывания HTTP-запросов (в частности fetch) используется **AbortController**.  
Как работает

1. Создаётся AbortController  
2. Его signal передаётся в fetch  
3. Вызов abort() прерывает запрос

const controller \= new AbortController();  
fetch(url, { signal: controller.signal });  
controller.abort();  
Что происходит при прерывании

* fetch отклоняет Promise  
* выбрасывается ошибка AbortError  
* запрос фактически останавливается браузером

try {  
  await fetch(url, { signal });  
} catch (e) {  
  if (e.name \=== 'AbortError') {  
    console.log('Request aborted');  
  }  
}

Зачем прерывать запросы

* отмена предыдущих запросов (search input)  
* предотвращение race conditions  
* оптимизация ресурсов  
* уход со страницы / размонтирование компонента

Прерывание запросов — Junior+ вопрос

⚠️ setTimeout **не может** прервать fetch  
⚠️ Нужно именно AbortController

localStorage и sessionStorage  
Что это

localStorage и sessionStorage — это **Web Storage API**  
Используются для хранения данных **в браузере** в формате ключ: значение.

localStorage

* Хранится **постоянно**  
* Не очищается при закрытии вкладки  
* Общий для всех вкладок одного origin

localStorage.setItem('token', '123');  
localStorage.getItem('token');  
localStorage.removeItem('token');  
localStorage.clear();

sessionStorage

* Живёт **только в рамках вкладки**  
* Удаляется при закрытии вкладки  
* Не доступен между вкладками

sessionStorage.setItem('step', '1');

Отличия localStorage vs sessionStorage

| Характеристика | localStorage | sessionStorage |
| ----- | ----- | ----- |
| Время жизни | Бессрочно | До закрытия вкладки |
| Область | Все вкладки | Одна вкладка |
| Размер | \~5–10 МБ | \~5 МБ |
| Тип данных | Только строки | Только строки |

Работа с объектами

Нужно сериализовать:  
localStorage.setItem('user', JSON.stringify(user));  
JSON.parse(localStorage.getItem('user'));

Ограничения Web Storage

* Только строки  
* Синхронный API (может блокировать UI)  
* Нет безопасности (доступен JS)  
* Не подходит для чувствительных данных

**Краткий ответ для собеседования**

Для прерывания запросов используется AbortController, который передаёт сигнал в fetch и позволяет отменить запрос. localStorage и sessionStorage — это браузерное хранилище ключ-значение. localStorage хранит данные бессрочно, а sessionStorage — только в рамках одной вкладки.

### 5\. Как работать с куками ? Как удалить куку? (Куки)

Cookies (Куки)  
Что такое cookies

**Cookies** — это небольшие данные, которые браузер:

* хранит на клиенте  
* автоматически отправляет на сервер с каждым HTTP-запросом  
* привязаны к **домену и пути**

Используются для:

* авторизации  
* хранения сессий  
* аналитики  
* персонализации

Как работать с куками в JavaScript

Чтение cookies	document.cookie  
Возвращает **строку**:		key1=value1; key2=value2  
Нужно парсить вручную.

Установка cookie

document.cookie \= "token=abc123; path=/; max-age=3600";

Основные атрибуты cookie

| Атрибут | Назначение |
| ----- | ----- |
| expires | Дата истечения |
| max-age | Время жизни (секунды) |
| path | Путь |
| domain | Домен |
| secure | Только HTTPS |
| samesite | CSRF-защита |
| httponly | Недоступна JS |

Пример полной cookie

document.cookie \= "session=1; path=/; secure; samesite=strict";

Как удалить cookie  
Cookie **нельзя удалить напрямую**.  
Её удаляют, установив **с истёкшим сроком**.

Способ 1: через max-age  
document.cookie \= "token=; max-age=0; path=/";

Способ 2: через expires

document.cookie \= "token=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";

⚠️ path и domain должны совпадать с оригинальными.

HttpOnly cookies

* Недоступны через JS  
* Защищают от XSS  
* Используются для сессий

Set-Cookie: sessionId=abc; HttpOnly;

Cookies и fetch  
Чтобы отправлять cookies:  
fetch(url, {  
  credentials: 'include'  
});

Ограничения cookies

* Размер \~4KB  
* Отправляются с каждым запросом  
* Медленнее localStorage  
* Уязвимы без HttpOnly и SameSite

**Краткий ответ для собеседования**

Cookies — это клиентское хранилище, которое автоматически отправляется на сервер. В JavaScript с ними работают через document.cookie. Удаление cookie выполняется установкой пустого значения с истёкшим сроком действия. Для безопасности используются атрибуты HttpOnly, Secure и SameSite.

# Регулярки

1. Какие есть флаги? Как работает сивол границы слова с нелатиницей? (Шаблоны и флаги, Символьные классы, Граница слова)  
2. Символы для начала и конца строки. Отличия для многострочного режима (Якоря и многострочный режим)  
3. Как работает диапазон? Исключающий режим. Ветвления. (Спец символы, Наборы и диапазоны, Альтернация)  
4. Какие квантификаторы есть? Режимы работы (Квантификаторы, жадные и ленивые)   
5. Как получить все скобочные группы? Как получить конкретную? Ссылки на скобочные группы. (Скобочные группы, Обратные ссылки)  
6. Как указываются и зачем нужны? (Опережающие и ретроспективные проверки)  
7. Какие методы могут работать используя регулярные выражения ? (Методы RegExp и String)

### 1\. Какие есть флаги? Как работает сивол границы слова с нелатиницей? (Шаблоны и флаги, Символьные классы, Граница слова)

Регулярные выражения (RegExp)  
Какие есть флаги

Флаги управляют поведением регулярного выражения.

| Флаг | Назначение |
| ----- | ----- |
| g | Глобальный поиск (все совпадения) |
| i | Игнорировать регистр |
| m | Многострочный режим (^ и $) |
| s | . захватывает перенос строки |
| u | Unicode режим |
| y | Липкий поиск (с позиции lastIndex) |

Пример:  
/word/gi

Шаблоны и символьные классы  
Основные символьные классы

| Класс | Значение |
| ----- | ----- |
| \\d | цифра (\[0-9\]) |
| \\w | буква, цифра или \_ *(латиница)* |
| \\s | пробельный символ |
| \\D \\W \\S | отрицания |

⚠️ \\w **не включает кириллицу**

Кастомные классы

/\[a-zA-Zа-яА-Я0-9\_\]/u

Граница слова \\b

Что такое \\b  
\\b — это **граница между \\w и \\W**  
\\w | \\W

Проблема с нелатиницей

\\w включает **только латиницу**, цифры и \_  
👉 **Кириллица считается \\W**  
'привет'.match(/\\bпривет\\b/) // ❌ null  
Почему так происходит  
Потому что:  
\\b \= граница ( \\w ↔ \\W )  
А кириллица не входит в \\w.

Как корректно работать с нелатиницей

Использовать Unicode-классы (\\p{})  
/\\b\\p{L}+\\b/gu  
или явно:  
/(^|\\s)привет(\\s|$)/u

Unicode-флаг u

Позволяет:

* корректно работать с суррогатными парами  
* использовать \\p{L}, \\p{N} и т.д.

/\\p{L}+/u

Частая ошибка на собеседовании

❌ Ожидать, что \\b работает с кириллицей  
✅ Понимать, что \\b привязан к \\w

**Краткий ответ для собеседования**

В JavaScript регулярные выражения поддерживают флаги g, i, m, s, u и y. Символьный класс \\w и граница слова \\b работают только с латиницей. Для корректной работы с нелатиницей необходимо использовать Unicode-флаг u и классы \\p{L} либо задавать границы вручную.

### 2\. Символы для начала и конца строки. Отличия для многострочного режима (Якоря и многострочный режим)

Якоря начала и конца строки (^ и $)  
Какие символы используются

В регулярных выражениях:

* ^ — **начало строки**  
* $ — **конец строки**

Они называются **якорями** и не сопоставляются с символами, а с позициями.

Как работают без многострочного режима

По умолчанию (m **не указан**):  
/^abc$/.test("abc")      // true  
/^abc$/.test("abc\\n")   // false  
/^abc$/.test("xabc")    // false

* ^ — начало **всей строки**  
* $ — конец **всей строки**

Многострочный режим (m)

Флаг m меняет поведение ^ и $.  
/^abc$/m.test("abc\\ndef") // true

В режиме m:

* ^ — начало **каждой строки**  
* $ — конец **каждой строки**

Разделителем строки считается \\n.

Пример сравнения

const text \= "one\\ntwo\\nthree";  
text.match(/^two$/);   // null  
text.match(/^two$/m);  // \["two"\]

Отличие m от s

| Флаг | Влияние |
| ----- | ----- |
| m | меняет ^ и $ |
| s | делает . совпадающим с \\n |

Частая ошибка

Ожидать, что:  
^ и $ работают построчно по умолчанию  
Это **не так**, для этого нужен m.

**Краткий ответ для собеседования**

В регулярных выражениях ^ и $ — это якоря начала и конца строки. Без флага m они применяются ко всей строке. В многострочном режиме m они работают для каждой строки отдельно, ограниченной символом перевода строки.

### 3\. Как работает диапазон? Исключающий режим. Ветвления. (Спец символы, Наборы и диапазоны, Альтернация)

Наборы, диапазоны и альтернация в RegExp  
Как работают наборы символов \[\]

Набор \[\] означает:  
**совпадение с одним символом из перечисленных**  
/\[abc\]/   // a или b или c  
Диапазоны символов  
Синтаксис  
\[a-z\]  
\[0-9\]  
\[A-Z\]  
Означает:  
любой символ в указанном диапазоне по Unicode-коду  
Комбинирование диапазонов  
\[a-zA-Z0-9\_\]

Важный момент  
Диапазон зависит от **кода символов**, а не алфавита языка.  
Для кириллицы требуется флаг u:  
/\[а-яё\]/u

Исключающий (отрицательный) набор \[^ \]  
Если первый символ внутри \[\] — ^, набор становится **отрицательным**.  
/\[^0-9\]/   // любой символ, кроме цифры

⚠️ Работает **только в начале набора**

Пример

/\[^a-z\]/i  
Совпадёт с:

* цифрами  
* пробелами  
* спецсимволами

Специальные символы внутри наборов

| Символ | Значение |
| ----- | ----- |
| \- | диапазон |
| ^ | отрицание (только первым) |
| \\ | экранирование |
| \] | конец набора |

Пример экранирования:  
/\[\\-\\\]\]/  
Альтернация (ветвление) |

| означает **ИЛИ**.  
/cat|dog/

Приоритет |  
| имеет **низкий приоритет**, поэтому часто нужны скобки:  
/gr(e|a)y/  
Отличие от набора

| Набор | Альтернация |
| ----- | ----- |
| \[ab\] | a или b (1 символ) |
| \`ab | cd\` |

Комбинирование

/(https?|ftp):\\/\\//  
Частые ошибки

❌ \[cat|dog\]  
✔ cat|dog  
❌ \[^a-z^\]  
✔ \[^a-z\]

**Краткий ответ для собеседования**

Диапазоны в регулярных выражениях задаются внутри квадратных скобок и соответствуют диапазону Unicode-кодов. Исключающий набор создаётся с помощью ^ в начале набора. Альтернация | используется для ветвлений и выбирает одно из выражений, при этом часто требует группировки скобками из\-за низкого приоритета.

### 4\. Какие квантификаторы есть? Режимы работы (Квантификаторы, жадные и ленивые) 

Квантификаторы в регулярных выражениях  
Что такое квантификаторы

Квантификаторы определяют **сколько раз** предыдущий токен (символ, класс, группа) должен повториться.  
Основные квантификаторы

| Квантификатор | Значение |
| ----- | ----- |
| \* | 0 или более |
| \+ | 1 или более |
| ? | 0 или 1 |
| {n} | ровно n |
| {n,} | n или более |
| {n,m} | от n до m |

Примеры

/a\*/     // "", "a", "aaa"  
/a+/     // "a", "aaa"  
/a?/     // "" или "a"  
/a{3}/   // "aaa"  
/a{2,4}/ // "aa", "aaa", "aaaa"

Квантификаторы применяются к:

1\. Одному символу	/\\d+/  
2\. Классу символов	/\[a-z\]{3,5}/  
3\. Группе	/(ab)+/

Жадный (Greedy) режим — по умолчанию

**Жадные квантификаторы** захватывают **максимально возможное** количество символов, при котором выражение остаётся валидным.	".\*"  
На строке:	"a" "b" "c"  
Результат:	"a" "b" "c"  
Ленивый (Lazy / Reluctant) режим

Добавление ? после квантификатора делает его **ленивым** — он захватывает **минимально возможное** количество символов.	".\*?"

Пример

const str \= '\<div\>text\</div\>';  
str.match(/\<.\*\>/);   // "\<div\>text\</div\>"  
str.match(/\<.\*?\>/);  // "\<div\>"  
Сравнение жадного и ленивого режимов

| Режим | Поведение |
| ----- | ----- |
| Жадный | Максимальный захват |
| Ленивый | Минимальный захват |

Почему возникают проблемы с жадностью	/\<.+\>/  
Захватит:	\<div\>text\</div\>  
Хотя ожидали:	\<div\>  
Квантификатор ? — двойное значение

| Контекст | Значение |
| ----- | ----- |
| a? | 0 или 1 |
| \*?, \+?, {n,m}? | ленивый режим |

Ленивыми могут быть

\*?  
\+?  
??  
{n,m}?  
Важно знать (Middle)

* Квантификаторы **всегда относятся к предыдущему токену**  
* Ленивость не означает «медленнее», а «минимальный захват»  
* Для сложных парсингов HTML RegExp — плохой инструмент

**Краткий ответ для собеседования**

В регулярных выражениях используются квантификаторы \*, \+, ? и фигурные формы {n,m} для задания количества повторений. По умолчанию они работают в жадном режиме и захватывают максимальное количество символов. Добавление ? после квантификатора переводит его в ленивый режим, при котором захват минимален и останавливается при первом успешном совпадении.

### 5\. Как получить все скобочные группы? Как получить конкретную? Ссылки на скобочные группы. (Скобочные группы, Обратные ссылки)

Скобочные группы (Capturing Groups)  
Что такое скобочная группа

Скобочная группа — это часть регулярного выражения, заключённая в (), которая:

1. **Группирует** выражение  
2. **Запоминает** (capture) совпавшую подстроку  
3. Может быть использована повторно (обратные ссылки)

/(ab)+/

Как получить все скобочные группы

1\. Через String.match()  
const str \= '2025-01-09';  
const result \= str.match(/(\\d{4})-(\\d{2})-(\\d{2})/);  
Результат:  
\[  
  "2025-01-09", // полное совпадение  
  "2025",       // группа 1  
  "01",         // группа 2  
  "09"          // группа 3  
\]

* result\[0\] — полное совпадение  
* result\[1...\] — скобочные группы

2\. Через RegExp.exec()

const regex \= /(\\d{4})-(\\d{2})-(\\d{2})/;  
const res \= regex.exec('2025-01-09');  
Работает аналогично match.

3\. Именованные группы (groups)

const res \= '2025-01-09'.match(  
  /(?\<year\>\\d{4})-(?\<month\>\\d{2})-(?\<day\>\\d{2})/  
);

res.groups.year;  // "2025"  
res.groups.month; // "01"  
res.groups.day;   // "09”

Как получить конкретную группу

| Способ | Пример |
| ----- | ----- |
| По индексу | result\[1\] |
| По имени | result.groups.name |

Некаптурирующие группы

(?:...)

* Группируют выражение  
* **НЕ сохраняются** в результат

/(?:ab)+/  
Используются для оптимизации и читаемости.  
Обратные ссылки (Backreferences)  
Что такое обратная ссылка  
Обратная ссылка — это обращение к **уже захваченной группе**.  
Обратные ссылки в шаблоне

По номеру	/(a)(b)\\2\\1/  
Совпадёт с:	abba  
Пример: повторяющееся слово	/\\b(\\w+)\\s+\\1\\b/  
Совпадёт:	hello hello  
Именованные обратные ссылки	/(?\<word\>\\w+)\\s+\\k\<word\>/  
Обратные ссылки в замене (replace)

'John Smith'.replace(/(\\w+)\\s+(\\w+)/, '$2 $1');  
// "Smith John"

| Синтаксис | Значение |
| ----- | ----- |
| $1 | группа 1 |
| $2 | группа 2 |
| $\<name\> | именованная группа |

Частые ошибки  
❌ Использовать номер группы после некаптурирующей  
❌ Забывать, что группы считаются **слева направо**  
❌ Использовать группы, когда нужны ?:

Когда использовать группы

* Парсинг структурированных строк  
* Валидация форматов  
* Повторяющиеся шаблоны  
* Переиспользование частей шаблона

**Краткий ответ для собеседования**

Скобочные группы позволяют захватывать части совпадения. Получить их можно через match или exec: полное совпадение находится в result\[0\], а группы — начиная с result\[1\]. Также существуют именованные группы, доступные через result.groups. Обратные ссылки позволяют ссылаться на ранее захваченные группы — по номеру \\1 или по имени \\k\<name\> — и используются для поиска повторяющихся фрагментов или при замене.

### 6\. Как указываются и зачем нужны? (Опережающие и ретроспективные проверки)

Опережающие и ретроспективные проверки (Lookaround)  
Что это такое

**Lookaround** — это специальные конструкции регулярных выражений, которые:

* **проверяют условие**  
* **не захватывают символы**  
* **не включают их в результат совпадения**

Иными словами: *«совпадает, если рядом есть / нет что-то»*.

Зачем нужны  
Используются, когда необходимо:

* проверить контекст **до или после** совпадения  
* **не включать** этот контекст в результат  
* выполнять сложную валидацию без лишних групп

Виды lookaround

| Тип | Название | Синтаксис |
| ----- | ----- | ----- |
| (?=...) | Положительный опережающий | lookahead |
| (?\!...) | Отрицательный опережающий | lookahead |
| (?\<=...) | Положительный ретроспективный | lookbehind |
| (?\<\!...) | Отрицательный ретроспективный | lookbehind |

Опережающая проверка (Lookahead)  
Проверяет, **что находится справа**, не захватывая это.  
Положительная (?=...)	/\\d(?=px)/  
Совпадёт с:	10px → 0

* цифра есть  
* **после неё px**  
* px в результат не входит

Отрицательная (?\!...)		/\\d(?\!px)/  
Совпадёт с:	10em → 0  
НЕ совпадёт с:	10px  
Ретроспективная проверка (Lookbehind)  
Проверяет, **что находится слева** от совпадения.  
Положительная (?\<=...)	/(?\<=\\$)\\d+/  
Совпадёт:	$100 → 100

* $ есть слева  
* $ не входит в результат

Отрицательная (?\<\!...)	/(?\<\!\\$)\\d+/  
Совпадёт:	100  
НЕ совпадёт:	$100  
Примеры реальных задач  
Найти слово, после которого стоит \!	/\\w+(?=\!)/  
Найти число без знака валюты	/(?\<\!\\$)\\d+/  
Проверка пароля	/^(?=.\*\\d)(?=.\*\[A-Z\]).{8,}$/  
Здесь:

* (?=.\*\\d) — есть цифра  
* (?=.\*\[A-Z\]) — есть заглавная буква  
* основное совпадение — длина

Отличие от скобочных групп

| Скобки | Lookaround |
| ----- | ----- |
| Захватывают | Не захватывают |
| Попадают в результат | Не попадают |
| Можно ссылаться | Нельзя |

Ограничения

* Lookbehind **должен быть фиксированной длины** (в JS)  
* Не поддерживается в старых браузерах  
* Может снижать производительность

Частые ошибки  
❌ Ожидать, что lookaround появится в match  
❌ Использовать группы вместо lookaround  
❌ Делать сложный lookbehind с переменной длиной

Краткий ответ для собеседования  
Lookahead и lookbehind — это проверки контекста в регулярных выражениях. Они позволяют проверить, что справа или слева от совпадения есть или нет определённый шаблон, не включая его в результат. Используются для валидации и точного поиска без захвата лишних символов. Синтаксис: (?=...), (?\!...), (?\<=...), (?\<\!...).

### 7\. Какие методы могут работать используя регулярные выражения ? (Методы RegExp и String)

Методы, работающие с регулярными выражениями  
В JavaScript с регулярными выражениями работают **два набора методов**:

1. **Методы объекта RegExp**  
2. **Методы строк (String)**, принимающие RegExp

1\. Методы RegExp

regexp.test(str)  
**Назначение:** проверить, есть ли совпадение  
**Возвращает:** true | false  
/\\d+/.test("abc123"); // true

* Быстрый  
* Часто используется в if  
* Меняет lastIndex при флаге g

regexp.exec(str)  
**Назначение:** найти совпадение  
**Возвращает:** Array | null  
/\\d+/.exec("abc123");

Результат:  
\[  
  "123",  
  index: 3,  
  input: "abc123",  
  groups: undefined  
\]

Особенности:

* Работает пошагово с флагом g  
* Возвращает группы захвата  
* Используется для сложного парсинга

2\. Методы String, принимающие RegExp

str.match(regexp)  
**Назначение:** получить совпадения  
"abc123def456".match(/\\d+/g);  
// \["123", "456"\]

Поведение:

* без g → как exec  
* с g → массив совпадений **без групп**

str.matchAll(regexp)  
**Назначение:** получить **все совпадения с группами**  
**Возвращает:** Iterator  
\[..."a1 b2".matchAll(/(\\w)(\\d)/g)\];  
Каждый элемент:

* полное совпадение  
* группы  
* index  
* input

⚠️ **Требует флаг g**

str.search(regexp)  
**Назначение:** найти индекс первого совпадения  
**Возвращает:** number | \-1  
"abc123".search(/\\d+/); // 3

* Флаг g игнорируется  
* Аналог indexOf, но с RegExp

str.replace(regexp, replacement)  
**Назначение:** замена		"abc123".replace(/\\d+/g, "\#"); // "abc\#"  
replacement может быть:

* строкой ($&, $1, $\<name\>)  
* функцией

"10px".replace(/\\d+/, n \=\> n \* 2);	// "20px"  
str.replaceAll(regexp, replacement)

* Заменяет **все совпадения**  
* Регулярка **обязана иметь флаг g**

"a1b2".replaceAll(/\\d/g, "\_");		// "a\_b\_"  
str.split(regexp)  
**Назначение:** разбить строку  
"a, b; c".split(/\[,;\]/);	// \["a", " b", " c"\]

* Можно использовать группы  
* Часто применяется для парсинга

Сводная таблица

| Метод | Где | Возвращает | Назначение |
| ----- | ----- | ----- | ----- |
| test | RegExp | boolean | Проверка |
| exec | RegExp | Array / null | Поиск \+ группы |
| match | String | Array / null | Совпадения |
| matchAll | String | Iterator | Все совпадения \+ группы |
| search | String | number | Индекс |
| replace | String | string | Замена |
| replaceAll | String | string | Замена всех |
| split | String | Array | Разделение |

Частые вопросы на собеседовании

Почему match и exec ведут себя по-разному?

* match с g **не возвращает группы**  
* exec всегда возвращает группы

Когда использовать matchAll?

* Когда нужны **все совпадения \+ группы**  
* При парсинге сложных структур

Почему test иногда даёт странные результаты?

* Из-за флага g и lastIndex

const r \= /\\d/g;  
r.test("1"); // true  
r.test("1"); // false

**Краткий ответ для собеседования**

В JavaScript с регулярными выражениями работают методы RegExp — test, exec, и методы строк — match, matchAll, search, replace, replaceAll, split. Методы строк принимают RegExp и позволяют искать, заменять и разбивать строки, а RegExp-методы используются для проверки и пошагового парсинга с доступом к группам.

# TypeScript

1. Какие основные типы есть? Что такое enum, void, any, never, tuples, unknown? Почему нужно избегать использование any? (Основные типы)  
2. Что такое интерфейс? Как указать опциональные параметры? Как указать параметры только для чтения? Как расширить существующий интерфейс? В чем отличие от типа? (Интерфейс)  
3. Для чего нужны ? Как использовать? Как обьединение нескольких интерфейсов сузить до одного интерфейса ? (Защитники типа)  
4. Как убрать определенные свойства из интерфейса? Как использовать только некоторые свойства из интерфейса? Как сделать все поля необязательными и наоборот? (Unitily типы)  
5. Какие модификаторы доступа существуют? Как происходит наследование? (Классы)  
6. Типизация параметров, опциональные параметры, возвращаемый тип. (Больше о функциях)   
7. Как у функции указать динамический тип? Зачем это нужно? Как указать что динамический тип должен иметь определнные свойства ? Динамический тип по умолчанию ? (Дженерики)  
   

### 1\. Какие основные типы есть? Что такое enum, void, any, never, tuples, unknown? Почему нужно избегать использование any? (Основные типы)

Основные типы TypeScript

Примитивные типы:string, number, boolean  
Дополнительно:null, undefined  
Специальные типы:any  
**Что это:** отключает проверку типов  
let value: any \= 5;  
value.foo.bar(); // допустимо  
**Почему избегаем:**

* ломает типовую безопасность  
* ошибки переносятся в runtime  
* ухудшает автодополнение  
* делает код неотличимым от JS

**Использовать только:**

* при миграции старого JS  
* для временных заглушек

unknown  
**Безопасная альтернатива any**  
let value: unknown;  
value.toUpperCase(); // ошибка  
Можно использовать **только после проверки типа**:  
if (typeof value \=== "string") {  
  value.toUpperCase();  
}

void

**Функция ничего не возвращает**  
function log(): void {  
  console.log("hello");  
}

* фактически возвращает undefined  
* используется в функциях и callbacks

never

**Функция никогда не завершится корректно**  
function throwError(): never {  
  throw new Error("Error");  
}

Используется:

* бесконечные циклы  
* throw  
* проверка исчерпывающих switch

Составные типы  
array  
number\[\]  
Array\<string\>  
tuple  
**Массив с фиксированной структурой**  
const user: \[number, string\] \= \[1, "Anna"\];

* порядок и типы строго заданы  
* удобны для return значений

Объектные типы  
object  
{}  
Record\<K, V\>  
enum  
**Набор именованных констант**  
enum Status {  
  Pending,  
  Success,  
  Error  
}  
Можно задавать значения:  
enum Role {  
  Admin \= "ADMIN",  
  User \= "USER"  
}

Особенности:

* компилируется в JS  
* можно использовать как тип и как значение

⚠️ В новых проектах часто заменяют:

type Role \= "ADMIN" | "USER";

Сравнение ключевых типов

| Тип | Назначение |
| ----- | ----- |
| any | Полное отключение типизации |
| unknown | Безопасный входной тип |
| void | Отсутствие возвращаемого значения |
| never | Код недостижим |
| tuple | Фиксированный массив |
| enum | Именованные константы |

**Короткий ответ для собеседования**

TypeScript расширяет JavaScript статической типизацией. Помимо примитивов string, number, boolean, есть специальные типы: any — отключает проверки и потому нежелателен; unknown — безопасная альтернатива; void — для функций без возвращаемого значения; never — для функций, которые никогда не завершаются. Также используются tuple для массивов с фиксированной структурой и enum для наборов именованных констант.

### 2\. Что такое интерфейс? Как указать опциональные параметры? Как указать параметры только для чтения? Как расширить существующий интерфейс? В чем отличие от типа? (Интерфейс)

Что такое интерфейс (interface)?

**Interface** — это контракт структуры объекта.  
Он описывает **какие поля и методы должен иметь объект**, не задавая реализацию.  
interface User {  
  id: number;  
  name: string;  
}

Используется для:

* объектов  
* параметров функций  
* классов  
* публичных API

Как указать опциональные параметры?

Используется ? после имени свойства:  
interface User {  
  id: number;  
  email?: string;  
}

* поле может отсутствовать  
* тип будет string | undefined

Как указать параметры только для чтения?

Используется ключевое слово readonly:  
interface User {  
  readonly id: number;  
  name: string;  
}  
user.id \= 5; // ❌ ошибка

* защита от изменения  
* удобно для id, токенов, конфигураций

Как расширить существующий интерфейс?

Используется extends:  
interface Person {  
  name: string;  
}

interface User extends Person {  
  id: number;  
}  
Можно расширять **несколько интерфейсов**:  
interface User extends Person, Timestamped {}  
В чем отличие interface от type?  
Главное различие

| Критерий | interface | type |
| ----- | ----- | ----- |
| Расширение | extends | & (intersection) |
| Объединение | ❌ | \` |
| Declaration merging | ✅ | ❌ |
| Использование для примитивов | ❌ | ✅ |
| Использование для функций | ✅ | ✅ |

Declaration Merging (ключевое отличие)  
interface User {  
  name: string;  
}

interface User {  
  age: number;  
}

➡️ **Объединятся автоматически**

User {  
  name: string;  
  age: number;  
}  
С type так **нельзя**.

Когда использовать interface, а когда type?

Используй interface, если:

* описываешь объекты  
* проектируешь публичный API  
* работаешь с классами  
* важна расширяемость

Используй type, если:

* нужны union или tuple  
* описываешь примитивы  
* комбинируешь сложные типы

**Короткий ответ для собеседования**

Interface в TypeScript — это контракт структуры объекта. Опциональные свойства задаются через ?, свойства только для чтения — через readonly. Интерфейсы расширяются с помощью extends и поддерживают declaration merging. В отличие от type, интерфейсы нельзя использовать для union-типов, но они лучше подходят для описания объектов и публичных API.

### 3\. Для чего нужны ? Как использовать? Как объединение нескольких интерфейсов сузить до одного интерфейса ? (Защитники типа)

Для чего нужны защитники типов (Type Guards)?

**Type Guards** используются для **уточнения (сужения) типа значения во время выполнения**, чтобы TypeScript понимал, **с каким конкретным типом мы работаем** внутри блока кода.  
Они решают проблему работы с:

* union типами (A | B)  
* unknown  
* any (частично)  
* сложными объектами

Как использовать защитники типов?  
1\. typeof — для примитивов  
function log(value: string | number) {  
  if (typeof value \=== "string") {  
    value.toUpperCase(); // string  
  }  
}  
2\. instanceof — для классов  
class User {}  
class Admin {}

function check(user: User | Admin) {  
  if (user instanceof Admin) {    // Admin  }  
}

3\. Проверка наличия свойства (in)

type User \= { name: string };  
type Admin \= { role: string };  
function check(person: User | Admin) {  
  if ("role" in person) {    // Admin  }  
}

4\. Пользовательский type guard (is)

type User \= { name: string };  
type Admin \= { name: string; role: string };  
function isAdmin(p: User | Admin): p is Admin {  return "role" in p;}  
function handle(p: User | Admin) {  
  if (isAdmin(p)) {    p.role; // Admin  }  
}

➡️ **Это самый мощный и правильный способ**

Как объединение нескольких интерфейсов сузить до одного?  
Используется **type guard**, который проверяет уникальные признаки интерфейса.

Пример

interface Car {  speed: number;}  
interface Plane {  altitude: number;}  
function isPlane(v: Car | Plane): v is Plane {  return "altitude" in v;}

function move(v: Car | Plane) {  
  if (isPlane(v)) {  
    v.altitude;  
  } else {    v.speed;  }  
}

Встроенные защитники типов

* Array.isArray(value)  
* value instanceof Class  
* typeof value \=== "string"  
* value \!== null

Важное замечание (Middle+)

Type guards:

* работают **во время выполнения**  
* влияют на **типизацию на этапе компиляции**  
* не меняют реальный тип объекта

**Короткий ответ для собеседования**

Type guards нужны для сужения union-типов во время выполнения. Они позволяют TypeScript точно понимать тип внутри блока кода. Используются typeof, instanceof, in, а также пользовательские функции с предикатом value is Type. Это основной способ сузить несколько интерфейсов до одного.

### 4\. Как убрать определенные свойства из интерфейса? Как использовать только некоторые свойства из интерфейса? Как сделать все поля необязательными и наоборот? (Unitily типы)

Как убрать определённые свойства из интерфейса?

Используется Omit\<T, K\> — **исключает поля из типа**.  
interface User {  
  id: number;  
  name: string;  
  password: string;  
}  
type PublicUser \= Omit\<User, "password"\>;

➡️ Удаляет одно или несколько свойств.

Как использовать только некоторые свойства из интерфейса?  
Используется Pick\<T, K\> — **выбирает нужные поля**.  
type UserPreview \= Pick\<User, "id" | "name"\>;

Как сделать все поля необязательными?  
Используется Partial\<T\>:  
type UpdateUser \= Partial\<User\>;  
Все свойства становятся ?.

Как сделать все поля обязательными?

Используется Required\<T\>:  
type FullUser \= Required\<Partial\<User\>\>;

Часто используемые Utility Types  
Readonly\<T\>  
Запрещает изменение свойств:  type ReadonlyUser \= Readonly\<User\>;

Record\<K, T\>  
Создаёт объект с заданными ключами:  type Roles \= Record\<"admin" | "user", boolean\>;

Exclude\<T, U\>  
Исключает типы из union:  
type Status \= "success" | "error" | "loading";  
type Visible \= Exclude\<Status, "loading"\>;

Extract\<T, U\>  
Оставляет пересечение типов:  type Visible \= Extract\<Status, "error" | "loading"\>;

NonNullable\<T\>  
Убирает null | undefined:  
type Safe \= NonNullable\<string | null\>;

**Короткий ответ для собеседования**

Для работы с частями интерфейса используются utility-типы: Pick — выбрать поля, Omit — исключить, Partial — сделать поля необязательными, Required — обязательными, Readonly — только для чтения. Они позволяют переиспользовать и модифицировать типы без дублирования.

Частая ошибка

❌ Модифицировать интерфейс вручную  
✅ Использовать utility types

### 5\. Какие модификаторы доступа существуют? Как происходит наследование? (Классы)

Модификаторы доступа в классах

TypeScript поддерживает три основных модификатора доступа:

| Модификатор | Доступ | Описание |
| ----- | ----- | ----- |
| public | Везде | Доступно из любого места. По умолчанию все поля и методы public. |
| private | Только внутри класса | Доступно **только в самом классе**. Наследники не видят. |
| protected | Внутри класса и наследников | Доступно внутри класса и классов-наследников. Вне класса недоступно. |

Пример

class User {  
  public name: string;  
  private password: string;  
  protected role: string;

  constructor(name: string, password: string, role: string) {  
    this.name \= name;  
    this.password \= password;  
    this.role \= role;  
  }

  private checkPassword(pwd: string) {  
    return this.password \=== pwd;  
  }  
}

* user.name — доступно  
* user.password — ❌ ошибка  
* this.role в наследнике — ✅ доступно

Наследование в классах  
Ключевое слово extends

* Позволяет создать класс-наследник, который **наследует свойства и методы родителя**.  
* Наследник может **переопределять методы** и использовать super для вызова родительского конструктора или методов.

class Admin extends User {  
  constructor(name: string, password: string) {  
    super(name, password, "admin"); // вызывает конструктор родителя  
  }

  showRole() {  
    console.log(this.role); // protected доступно  
  }  
}

* private поля родителя **невидимы** наследнику  
* protected поля доступны наследнику  
* public поля и методы доступны везде

Важные моменты

* Если метод наследника **переопределяет** метод родителя, можно вызывать super.method()  
* Конструктор наследника **обязано должен вызвать super()**, если родительский конструктор требует параметры  
* Наследование может быть **многоуровневым**, но TypeScript поддерживает только одиночное наследование (extends один класс)  
* Для множественного поведения используют **миксины или интерфейсы**

**Короткий ответ для собеседования**

В TypeScript классы имеют модификаторы доступа: public (везде), private (только внутри класса), protected (класс \+ наследники). Наследование происходит через extends. Наследник получает public и protected свойства родителя, может переопределять методы и вызывать родительский конструктор через super().

### 6\. Типизация параметров, опциональные параметры, возвращаемый тип. (Больше о функциях) 

Типизация параметров

В TypeScript **каждому параметру можно указать тип**:  
function sum(a: number, b: number): number {  
  return a \+ b;  
}

* a: number — параметр a типа number  
* b: number — параметр b типа number  
* : number после скобок — тип **возвращаемого значения**

**Примечание:** Если тип возвращаемого значения не указан, TypeScript **выведет его автоматически**.

Опциональные параметры

Используется ? после имени параметра:  
function greet(name: string, title?: string) {  
  console.log(\`Hello ${title ? title \+ " " : ""}${name}\`);  
}

* Параметр title может отсутствовать  
* Внутри функции его тип: string | undefined

Параметры по умолчанию

function greet(name: string, title: string \= "Mr./Ms.") {  
  console.log(\`Hello ${title} ${name}\`);  
}

* Если аргумент не передан, используется значение по умолчанию  
* Такой параметр автоматически считается опциональным

Остаточные параметры (rest)

Для передачи переменного числа аргументов:  
function sumAll(...numbers: number\[\]): number {  
  return numbers.reduce((a, b) \=\> a \+ b, 0);  
}

* numbers: number\[\] — массив чисел  
* Можно передавать любое количество аргументов

Тип возвращаемого значения

Указывается после скобок:  
function multiply(a: number, b: number): number {  
  return a \* b;  
}

* TypeScript проверяет, чтобы функция возвращала значение указанного типа  
* Можно явно указать void для функций без return:

function logMessage(msg: string): void {  
  console.log(msg);  
}

Типизация функций как переменных

let fn: (x: number, y: number) \=\> number;  
fn \= (a, b) \=\> a \+ b;

* (x: number, y: number) \=\> number — тип функции  
* Параметры и возвращаемое значение проверяются TypeScript

Полезные комбинации

function fetchData(id: number, options?: { cache?: boolean }): Promise\<string\> {  
  return Promise.resolve(\`Data for ${id}\`);  
}

* Опциональный объект с опциональными полями  
* Функция возвращает Promise\<string\>

**Короткий ответ для собеседования**

В TypeScript функция типизируется через указание типов параметров и возвращаемого значения. Опциональные параметры задаются через ?, параметры по умолчанию могут быть пропущены. Остаточные параметры позволяют передавать переменное число аргументов. Типизация функций как переменных позволяет проверять сигнатуру функции на этапе компиляции.

### 7\. Как у функции указать динамический тип? Зачем это нужно? Как указать что динамический тип должен иметь определнные свойства ? Динамический тип по умолчанию ? (Дженерики)

Что такое дженерики и зачем они нужны?

**Generics** позволяют задавать **динамический тип для функции, класса или интерфейса**, чтобы она могла работать с **разными типами данных** при сохранении **типовой безопасности**.

Пример без дженериков (небезопасно)

function identity(value: any) {  
  return value;  
}  
const num \= identity(42); // тип any  
num.toFixed(); // ✅, но TS не знает, что это число

* Использование any теряет проверку типов

Пример с дженериком

function identity\<T\>(value: T): T {  
  return value;  
}  
const num \= identity\<number\>(42); // T \= number  
num.toFixed(); // ✅ безопасно  
const str \= identity\<string\>("hello"); // T \= string  
str.toUpperCase(); // ✅ безопасно

* \<T\> — placeholder для типа  
* Тип определяется при вызове функции (или выводится TypeScript автоматически)

Как указать, что динамический тип должен иметь определённые свойства?

Используем **ограничение через extends**:  
interface HasId {  
  id: number;  
}

function getId\<T extends HasId\>(obj: T) {  
  return obj.id;  
}  
getId({ id: 10, name: "John" }); // ✅ работает  
getId({ name: "John" }); // ❌ ошибка, нет id

* Ограничение T extends HasId говорит: «тип T **должен иметь поле id**»

Как задать динамический тип по умолчанию?

Можно указать значение по умолчанию:  
function wrap\<T \= string\>(value: T) {  
  return { value };  
}

const a \= wrap("hello"); // T \= string  
const b \= wrap(42);      // T \= number, выведен автоматически

* Если тип не указан явно, используется string

Дженерики в классах и интерфейсах

class Box\<T\> {  
  constructor(public content: T) {}  
}  
const numBox \= new Box\<number\>(123);  
const strBox \= new Box("hello"); // TS выведет T \= string

* Работает также для интерфейсов и типов:

interface ApiResponse\<T\> {  
  data: T;  
  error?: string;  
}

Почему это важно?

* Позволяет **переиспользовать код** без потери типизации  
* Исключает использование any  
* Делает API функций и классов **гибким и безопасным**

**Короткий ответ для собеседования**

Дженерики позволяют задавать динамический тип для функции, класса или интерфейса. Ограничения через extends гарантируют, что тип имеет необходимые свойства. По умолчанию можно задать тип через \<T \= DefaultType\>. Это важно для переиспользуемого и типобезопасного кода.  
